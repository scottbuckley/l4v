(*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * SPDX-License-Identifier: GPL-2.0-only
 *)

theory DetSchedSchedule_AI
imports ArchDetSchedDomainTime_AI
begin

context begin interpretation Arch .

requalify_consts
  time_oracle

requalify_facts
  kernelWCET_us_non_zero
  kernelWCET_ticks_non_zero
  do_ipc_transfer_cur_thread
  machine_ops_last_machine_time
  handle_arch_fault_reply_typ_at
  getCurrentTime_def
  install_tcb_cap_sc_tcb_sc_at

end

lemmas [wp] =
  do_ipc_transfer_cur_thread
  handle_arch_fault_reply_typ_at
  machine_ops_last_machine_time

(* FIXME RT: move and rename *)
lemma hoare_drop_assertion:
  assumes "\<lbrace>\<lambda>s. P s \<longrightarrow> Q s\<rbrace> f \<lbrace>R\<rbrace>"
  shows "\<lbrace>Q\<rbrace> f \<lbrace>R\<rbrace>"
  by (wpsimp wp: assms)

lemma update_time_stamp_current_time_bounded:
  "\<lbrace>\<top>\<rbrace> update_time_stamp \<lbrace>\<lambda>_. current_time_bounded\<rbrace>"
  including no_take_bit
  supply minus_add_distrib[simp del]
  apply (clarsimp simp: update_time_stamp_def getCurrentTime_def)
  apply wpsimp
  apply (clarsimp simp: current_time_bounded_def)
  apply (rule_tac y="unat (-(getCurrentTime_buffer + 1))
                     + unat kernelWCET_ticks + 5 * unat MAX_PERIOD"
               in order_trans)
   apply (prop_tac "min (unat (-(getCurrentTime_buffer + 1)))
                        (unat (last_machine_time_of s) + time_oracle (Suc (time_state_of s)))
                    \<le> unat (-(getCurrentTime_buffer + 1))")
    apply (force simp: minus_add_distrib)
   apply clarsimp
  apply (clarsimp simp: minus_add_distrib)
  apply (meson le_trans min.cobounded1 unat_of_nat_closure)
  apply (subst unat_minus_plus_one)
   apply (insert getCurrentTime_buffer_no_overflow getCurrentTime_buffer_no_overflow')
   apply (clarsimp simp: kernelWCET_ticks_def MAX_PERIOD_def)
  apply (clarsimp)
  apply (insert getCurrentTime_buffer_no_overflow'_stronger getCurrentTime_buffer_no_overflow
                getCurrentTime_buffer_no_overflow' MAX_PERIOD_mult)
  by (fastforce simp: kernelWCET_ticks_def MAX_PERIOD_def unat_minus_one_word)

lemma as_user_cur_sc_chargeable[wp]:
  "as_user f d \<lbrace>cur_sc_chargeable\<rbrace>"
  unfolding as_user_def cur_sc_chargeable_def2
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: obj_at_def pred_tcb_at_def sc_at_pred_def dest!: get_tcb_SomeD)
  apply (case_tac "cur_thread s = f"; simp)
  apply fastforce
  by fastforce

definition
  "cur_sc_is_sc s \<equiv> obj_at (\<lambda>ko. case ko of SchedContext sc n \<Rightarrow> True | _ \<Rightarrow> False) (cur_sc s) s"

lemma machine_time_of_s[simp]:
  "last_machine_time_of (detype S s) = last_machine_time_of s"
  by (clarsimp simp: detype_def)

method overflow_hammer =
  ((assumption
    | subst power_two_max_word_fold olen_add_eqv[symmetric] diff_Suc_1
    | intro add_left_mono word_sub_le le_imp_less_Suc
            iffD2[OF no_olen_add_nat] order_refl
    | erule iffD1[OF word_le_nat_alt])+)[1]

lemma cur_time_no_overflow:
  "current_time_bounded s \<Longrightarrow> cur_time s \<le> cur_time s + kernelWCET_ticks"
  unfolding current_time_bounded_def
  apply (overflow_hammer, clarsimp)
  done

lemma is_round_robin_wp:
  "\<lbrace>\<lambda>s. \<forall> sc n. ko_at (SchedContext sc n) scp s \<longrightarrow> Q (sc_period sc = 0) s\<rbrace>
    is_round_robin scp
   \<lbrace>Q\<rbrace>" by (wpsimp simp: is_round_robin_def)

(* FIXME RT: replace is_round_robin_wp with this version. *)
lemma is_round_robin_wp':
  "\<lbrace>\<lambda>s. \<forall>scrc. pred_map_eq scrc (sc_refill_cfgs_of s) scp \<longrightarrow> Q (scrc_period scrc = 0) s\<rbrace>
    is_round_robin scp
   \<lbrace>Q\<rbrace>" by (wpsimp wp: is_round_robin_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

(* FIXME: move *)
lemma update_sk_obj_ref_lift:
  "(\<And>sc. \<lbrace>P\<rbrace> set_simple_ko C ref (f (K new) sc) \<lbrace>\<lambda>rv. P\<rbrace>) \<Longrightarrow>
   \<lbrace>P\<rbrace> update_sk_obj_ref C f ref new \<lbrace>\<lambda>rv. P\<rbrace>"
  apply (wpsimp simp: update_sk_obj_ref_def get_simple_ko_wp | assumption)+
  done

(* This rule can cause problems with the simplifier if rule unification chooses a Q that does not
   specify proj. If necessary, this can be worked around by manually specifying proj. *)
lemma update_sched_context_sc_at_pred_n_indep:
  "(\<And>sc. P (proj (f sc)) = P (proj sc)) \<Longrightarrow>
   update_sched_context csc_ptr f \<lbrace>\<lambda>s. Q (sc_at_pred_n N proj P sc_ptr s)\<rbrace>"
  by (wpsimp wp: update_sched_context_wp simp: sc_at_pred_n_def obj_at_def)

lemma tcb_sched_action_lift:
  "(\<And>f s. P s \<Longrightarrow> P (ready_queues_update f s))
  \<Longrightarrow> \<lbrace>P\<rbrace> tcb_sched_action a b \<lbrace>\<lambda>_. P\<rbrace>"
  by (wpsimp wp: set_tcb_queue_wp
           simp: tcb_sched_action_def etcb_at_def thread_get_def)

lemma update_sched_context_sc_tcb_sc_at:
  assumes f_act_triv: "sc_ptr = sc_ptr' \<Longrightarrow> \<forall>x. P (sc_tcb (f x)) = P (sc_tcb x)"
  shows "update_sched_context sc_ptr f \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr' s)\<rbrace>"
  apply (wpsimp simp: update_sched_context_def wp: set_object_wp get_object_wp)
  apply (case_tac "sc_ptr = sc_ptr'"; clarsimp simp: obj_at_def sc_at_pred_n_def f_act_triv)
  done

\<comment> \<open>Rules that completely describe the behaviour of functions w.r.t. the aspects of
    state relevant to valid_sched. They should be phrased with a postcondition that
    is at least as general as "valid_sched_pred P", for arbitrary P, and a precondition
    that can be written as "valid_sched_pred (f P)", for some f.\<close>

named_theorems valid_sched_wp

\<comment> \<open>Rules useful for simplifying goals resulting from valid_sched_wp rules.\<close>

named_theorems valid_sched_wpsimps

lemmas [valid_sched_wpsimps] =
  valid_sched_def obj_at_kh_kheap_simps

\<comment> \<open>tcb_sched_action\<close>

abbreviation tcb_sched_ready_q_update where
  "tcb_sched_ready_q_update domain prio action \<equiv>
    \<lambda>qs d p. if d = domain \<and> p = prio then action (qs domain prio) else qs d p"

lemma tcb_sched_action_wp[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>dom prio. etcb_eq' prio dom (etcbs_of s) thread
                   \<longrightarrow> Q (ready_queues_update (tcb_sched_ready_q_update dom prio (action thread)) s)\<rbrace>
   tcb_sched_action action thread
   \<lbrace>\<lambda>_. Q\<rbrace>"
  by (wpsimp simp: tcb_sched_action_def wp: thread_get_wp' set_tcb_queue_wp)
     (auto simp: obj_at_def vs_all_heap_simps elim!: rsubst[of Q])

lemma tcb_sched_action_valid_sched_misc[wp]:
  "tcb_sched_action act t \<lbrace>\<lambda>s. P (consumed_time s) (cur_time s) (cur_domain s) (cur_thread s) (cur_sc s)
                                 (idle_thread s) (release_queue s) (scheduler_action s)
                                 (kheap s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

abbreviation (input) tcb_sched_enqueue_valid_ready_qs_update where
  "tcb_sched_enqueue_valid_ready_qs_update domain prio thread queues ct etcbs tcb_sts
                                                  tcb_scps sc_refill_cfgs \<equiv>
    valid_ready_qs_2 queues ct etcbs tcb_sts tcb_scps sc_refill_cfgs
     \<and> (thread \<in> set (queues domain prio)
         \<or> (etcb_eq' prio domain etcbs thread
             \<and> pred_map runnable tcb_sts thread
             \<and> released_sc_tcb_at_pred ct tcb_scps sc_refill_cfgs thread))"

lemma tcb_sched_action_valid_ready_qs_simps[valid_sched_wpsimps]:
  shows "valid_ready_qs_2 (tcb_sched_ready_q_update domain prio (tcb_sched_enqueue thread) queues)
                          ct etcbs tcb_sts tcb_scps sc_refill_cfgs
         \<longleftrightarrow> tcb_sched_enqueue_valid_ready_qs_update domain prio thread queues ct etcbs tcb_sts
                                                     tcb_scps sc_refill_cfgs"
  and "valid_ready_qs_2 (tcb_sched_ready_q_update domain prio (tcb_sched_append thread) queues)
                        ct etcbs tcb_sts tcb_scps sc_refill_cfgs
       \<longleftrightarrow> tcb_sched_enqueue_valid_ready_qs_update domain prio thread queues ct etcbs tcb_sts
                                                   tcb_scps sc_refill_cfgs"
  and "valid_ready_qs_2 queues ct etcbs tcb_sts tcb_scps sc_refill_cfgs
       \<Longrightarrow> valid_ready_qs_2 (tcb_sched_ready_q_update domain prio (tcb_sched_dequeue thread) queues)
                            ct etcbs tcb_sts tcb_scps sc_refill_cfgs"
  by (auto simp: valid_ready_qs_def tcb_sched_enqueue_def tcb_sched_append_def tcb_sched_dequeue_def)

lemma tcb_sched_enqueue_valid_ready_qs[wp]:
  "\<lbrace>valid_ready_qs and st_tcb_at runnable thread and released_sc_tcb_at thread\<rbrace>
     tcb_sched_action tcb_sched_enqueue thread \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps released_sc_tcb_at_def)

lemma tcb_sched_append_valid_ready_qs[wp]:
  "\<lbrace>valid_ready_qs and st_tcb_at runnable thread and released_sc_tcb_at thread\<rbrace>
     tcb_sched_action tcb_sched_append thread \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps released_sc_tcb_at_def)

lemma tcb_sched_enqueue_in_ready_q[wp]:
  "\<lbrace>\<top>\<rbrace> tcb_sched_action tcb_sched_enqueue thread \<lbrace>\<lambda>_. in_ready_q thread\<rbrace>"
  by (wpsimp wp: tcb_sched_action_wp)
     (auto simp: vs_all_heap_simps in_queues_2_def tcb_sched_enqueue_def)

lemma tcb_sched_append_in_ready_q[wp]:
  "\<lbrace>\<top>\<rbrace> tcb_sched_action tcb_sched_append thread \<lbrace>\<lambda>_. in_ready_q thread\<rbrace>"
  by (wpsimp wp: tcb_sched_action_wp)
     (auto simp: vs_all_heap_simps in_queues_2_def tcb_sched_append_def)

(* this is not safe! *)
(* if in_ready_q thread then this will break valid_blocked  *)
lemma tcb_sched_dequeue_valid_ready_qs:
  "\<lbrace>valid_ready_qs\<rbrace> tcb_sched_action tcb_sched_dequeue thread \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_act_set_simps[valid_sched_wpsimps]:
  "t \<in> set (tcb_sched_enqueue thread queue) = (t \<in> set queue \<or> t = thread)"
  "t \<in> set (tcb_sched_append thread queue) = (t \<in> set queue \<or> t = thread)"
  "t \<in> set (tcb_sched_dequeue thread queue) = (t \<in> set queue \<and> t \<noteq> thread)"
  by (auto simp: tcb_sched_enqueue_def tcb_sched_append_def tcb_sched_dequeue_def)

lemma tcb_sched_act_in_queues_2_simps[valid_sched_wpsimps]:
  "in_queue_2 (tcb_sched_enqueue thread queue) t \<longleftrightarrow> t = thread \<or> in_queue_2 queue t"
  "in_queue_2 (tcb_sched_append thread queue) t \<longleftrightarrow> t = thread \<or> in_queue_2 queue t"
  "in_queue_2 (tcb_sched_dequeue thread queue) t \<longleftrightarrow> t \<in> set queue \<and> t \<noteq> thread"
  by (auto simp: in_queue_2_def valid_sched_wpsimps)

lemma tcb_sched_ready_q_update_set_simps[valid_sched_wpsimps]:
  "t \<in> set (tcb_sched_ready_q_update domain prio (tcb_sched_enqueue thread) queues d p)
   = (t \<in> set (queues d p) \<or> (d = domain \<and> p = prio \<and> t = thread))"
  "t \<in> set (tcb_sched_ready_q_update domain prio (tcb_sched_append thread) queues d p)
   = (t \<in> set (queues d p) \<or> (d = domain \<and> p = prio \<and> t = thread))"
  "t \<in> set (tcb_sched_ready_q_update domain prio (tcb_sched_dequeue thread) queues d p)
   = (t \<in> set (queues d p) \<and> (t,d,p) \<noteq> (thread,domain,prio))"
  by (auto simp: valid_sched_wpsimps)

lemma tcb_sched_ready_q_update_in_queues_2_simps[valid_sched_wpsimps]:
  "in_queues_2 (tcb_sched_ready_q_update domain prio (tcb_sched_enqueue thread) queues) t
   \<longleftrightarrow> t = thread \<or> in_queues_2 queues t"
  "in_queues_2 (tcb_sched_ready_q_update domain prio (tcb_sched_append thread) queues) t
   \<longleftrightarrow> t = thread \<or> in_queues_2 queues t"
  "in_queues_2 (tcb_sched_ready_q_update domain prio (tcb_sched_dequeue thread) queues) t
   \<longleftrightarrow> (\<exists>d p. t \<in> set (queues d p) \<and> (t,d,p) \<noteq> (thread,domain,prio))"
  by (auto simp: in_queues_2_def valid_sched_wpsimps)

lemma tcb_sched_action_ct_not_in_q_simps[valid_sched_wpsimps]:
  assumes "ct_not_in_q_2 queues sa ct"
  shows tcb_sched_enqueue_not_in_q_simp:
    "not_cur_thread_2 thread sa ct \<Longrightarrow> ct_not_in_q_2 (tcb_sched_ready_q_update domain prio
                                                     (tcb_sched_enqueue thread) queues) sa ct"
  and tcb_sched_append_not_in_q_simp:
    "not_cur_thread_2 thread sa ct \<Longrightarrow> ct_not_in_q_2 (tcb_sched_ready_q_update domain prio
                                                     (tcb_sched_append thread) queues) sa ct"
  and tcb_sched_dequeue_not_in_q_simp:
    "ct_not_in_q_2 (tcb_sched_ready_q_update domain prio (tcb_sched_dequeue thread) queues) sa ct"
  using assms by (auto simp: ct_not_in_q_2_def not_cur_thread_2_def valid_sched_wpsimps not_queued_2_def)

lemma tcb_sched_enqueue_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q and not_cur_thread thread\<rbrace>
     tcb_sched_action tcb_sched_enqueue thread
     \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_append_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q and not_cur_thread thread\<rbrace>
     tcb_sched_action tcb_sched_append thread
     \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_dequeue_ct_not_in_q:
  "tcb_sched_action tcb_sched_dequeue thread \<lbrace>ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_dequeue_sc_not_in_ready_q:
  "\<lbrace>\<lambda>s. heap_ref_eq sc_ptr tptr (tcb_scps_of s) \<and> heap_refs_inj (tcb_scps_of s) \<and> valid_ready_qs s
        \<and> tcb_at tptr s\<rbrace>
   tcb_sched_action tcb_sched_dequeue tptr
   \<lbrace>\<lambda>rv. sc_not_in_ready_q sc_ptr\<rbrace>"
  apply (clarsimp simp: tcb_sched_action_def set_tcb_queue_def)
  apply (wpsimp wp: thread_get_wp)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def tcb_sched_dequeue_def heap_refs_inj_eq
                        in_queues_2_def  valid_ready_qs_def is_tcb_def)
  apply (rename_tac ko)
  apply (case_tac ko; clarsimp)
  apply (drule_tac x=d in spec)
  apply (drule_tac x=p in spec)
  apply clarsimp
  apply (drule_tac x=t in bspec, blast)
  apply (prop_tac "t=tptr")
   apply (clarsimp simp:heap_refs_inj_eq)
  apply (clarsimp simp: vs_all_heap_simps)
  done

lemma valid_blocked_discharge_except:
  assumes "valid_blocked_thread id id S queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs t"
  shows "valid_blocked_except_set_2 (insert t S) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs
         \<longleftrightarrow> valid_blocked_except_set_2 S queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  using assms by (auto simp: valid_blocked_defs)

lemmas valid_blocked_discharge_except'
  = valid_blocked_discharge_except[unfolded valid_blocked_thread_def]

(* valid_blocked_except_set doesn't say much; S can contain anything that is not blocked *)
(* see also valid_blocked_except_set_subset *)
(* use in conjunction with valid_sched_except_blocked *)
lemmas valid_blocked_except_set_less
  = valid_blocked_discharge_except'[THEN iffD1, rotated]

lemma tcb_sched_insert_valid_blocked_simps[valid_sched_wpsimps]:
  "valid_blocked_except_set_2 S (tcb_sched_ready_q_update domain prio (tcb_sched_enqueue thread) queues)
                                    rlq sa ct tcb_sts tcb_scps sc_refill_cfgs
    \<longleftrightarrow> valid_blocked_except_set_2 (insert thread S) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  "valid_blocked_except_set_2 S (tcb_sched_ready_q_update domain prio (tcb_sched_append thread) queues)
                                    rlq sa ct tcb_sts tcb_scps sc_refill_cfgs
    \<longleftrightarrow> valid_blocked_except_set_2 (insert thread S) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  by (auto simp: valid_blocked_defs valid_sched_wpsimps)

lemma tcb_sched_dequeue_valid_blocked_simp:
  assumes "T \<subseteq> S"
  assumes "valid_blocked_except_set_2 T queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  assumes "valid_blocked_thread Not id S queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs t"
  shows "valid_blocked_except_set_2 S (tcb_sched_ready_q_update domain prio (tcb_sched_dequeue t) queues)
                                    rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  using assms by (auto simp: valid_blocked_thread_def in_queues_2_def valid_sched_wpsimps
                      elim!: valid_blockedE)

\<comment> \<open>Use more concrete T and S to avoid simplifier slow-down\<close>
lemmas tcb_sched_dequeue_valid_blocked_simps[valid_sched_wpsimps] =
  tcb_sched_dequeue_valid_blocked_simp[OF subset_refl]
  tcb_sched_dequeue_valid_blocked_simp[where T=S for S, OF subset_insertI[where a=t' for t'], simplified]

lemmas tcb_sched_dequeue_valid_blocked_bot_simps[valid_sched_wpsimps] =
  tcb_sched_dequeue_valid_blocked_simps[OF _ valid_blocked_thread_bot_queues]

lemma tcb_sched_enqueue_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set (insert thread S)\<rbrace>
    tcb_sched_action tcb_sched_enqueue thread
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_enqueue_valid_blocked_except_set_const:
  "tcb_sched_action tcb_sched_enqueue thread \<lbrace>valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_append_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set (insert thread S)\<rbrace>
    tcb_sched_action tcb_sched_append thread
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_sched_append_valid_blocked_except_set_const:
  "tcb_sched_action tcb_sched_append thread \<lbrace>valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

(* tcb_sched_dequeue *)
lemma tcb_sched_dequeue_valid_blocked_except_set':
  "\<lbrace>\<lambda>s. valid_blocked_except_set S s \<and> t \<in> S\<rbrace>
    tcb_sched_action tcb_sched_dequeue t
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps valid_blocked_thread_def)

lemmas tcb_sched_dequeue_valid_blocked_except_set
  = tcb_sched_dequeue_valid_blocked_except_set'[where S="insert t S" and t=t for t S, simplified]

lemma tcb_sched_dequeue_valid_blocked_except_set_const:
  "\<lbrace>valid_blocked_except_set S and valid_blocked_thread_of Not id S t\<rbrace>
    tcb_sched_action tcb_sched_dequeue t
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps valid_blocked_thread_def)

lemma tcb_sched_dequeue_valid_blocked_except_set_remove: (* valid_sched is broken at thread *)
  "\<lbrace>valid_blocked_except_set (insert t S) and valid_blocked_thread_of \<bottom> id S t\<rbrace>
    tcb_sched_action tcb_sched_dequeue t
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_blocked_defs valid_sched_wpsimps in_queues_2_def)

(* Move *)
lemma if_fun_simp2: "(\<lambda>x1 x2. if x1 = y1 \<and> x2 = y2 then f y1 y2 else f x1 x2) = f "
  by (rule all_ext) auto

lemma tcb_sched_dequeue_not_queued_inv:
  "\<lbrace>P and not_queued thread\<rbrace> tcb_sched_action tcb_sched_dequeue thread \<lbrace>\<lambda>_. P\<rbrace>"
  apply (wpsimp wp: thread_get_wp' set_tcb_queue_wp
              simp: tcb_sched_dequeue_def tcb_sched_action_def)
  apply (clarsimp simp: not_queued_def obj_at_def elim!: rsubst[where P=P])
  by (drule_tac x="tcb_domain tcb" and y="tcb_priority tcb" in spec2)
     (subst filter_True; clarsimp simp: if_fun_simp2)

lemma tcb_sched_dequeue_ready_or_release[wp]:
  "tcb_sched_action tcb_sched_dequeue t \<lbrace>\<lambda>s. ready_or_release s\<rbrace>"
  apply (wpsimp simp: tcb_sched_action_def thread_get_def wp: set_tcb_queue_wp)
  apply (clarsimp simp: tcb_sched_dequeue_def ready_or_release_2_def in_queues_2_def)
  by fastforce

lemma tcb_sched_enqueue_ready_or_release[wp]:
  "\<lbrace>ready_or_release and not_in_release_q t\<rbrace>
   tcb_sched_action tcb_sched_enqueue t
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  apply (wpsimp simp: tcb_sched_action_def thread_get_def wp: set_tcb_queue_wp)
  by (fastforce simp: tcb_sched_enqueue_def ready_or_release_2_def in_queues_2_def)

lemma tcb_sched_append_ready_or_release[wp]:
  "\<lbrace>ready_or_release and not_in_release_q t\<rbrace>
   tcb_sched_action tcb_sched_append t
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  apply (wpsimp simp: tcb_sched_action_def thread_get_def wp: set_tcb_queue_wp)
  by (fastforce simp: tcb_sched_append_def ready_or_release_2_def in_queues_2_def)

lemma tcb_sched_enqueue_valid_sched[wp]:
  "\<lbrace>valid_sched_except_blocked and st_tcb_at runnable thread
    and not_cur_thread thread
    and active_sc_tcb_at thread and valid_blocked_except thread
    and budget_ready thread and not_in_release_q thread\<rbrace>
     tcb_sched_action tcb_sched_enqueue thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: valid_sched_wp
              simp: valid_sched_wpsimps released_sc_tcb_at_def ready_or_release_2_def)
  by fast

lemma tcb_sched_enqueue_valid_sched_weak:
  "\<lbrace>valid_sched and st_tcb_at runnable thread
    and not_cur_thread thread
    and active_sc_tcb_at thread
    and budget_ready thread and budget_sufficient thread and not_in_release_q thread\<rbrace>
   tcb_sched_action tcb_sched_enqueue thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: valid_sched_wp
              simp: valid_sched_wpsimps released_sc_tcb_at_def ready_or_release_2_def)
  by fast

lemma tcb_sched_append_valid_sched[wp]:
  "\<lbrace>valid_sched_except_blocked and st_tcb_at runnable thread and active_sc_tcb_at thread
     and not_cur_thread thread and valid_blocked_except thread
    and budget_ready thread and budget_sufficient thread and not_in_release_q thread\<rbrace>
      tcb_sched_action tcb_sched_append thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: valid_sched_wp
              simp: valid_sched_wpsimps released_sc_tcb_at_def ready_or_release_2_def)
  by fast

lemma tcb_sched_dequeue_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked\<rbrace>
     tcb_sched_action tcb_sched_dequeue thread
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps ready_or_release_2_def in_ready_q_def)
  by blast

lemma tcb_sched_enqueue_not_queued:
  "\<lbrace>not_queued t and K (thread \<noteq> t)\<rbrace>
     tcb_sched_action tcb_sched_enqueue thread
   \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

\<comment> \<open>tcb_release_remove\<close>

lemma tcb_release_remove_wp[valid_sched_wp]:
  "\<lbrace>\<lambda>s. if release_queue s \<noteq> [] \<and> hd (release_queue s) = thread
        then P (s\<lparr>reprogram_timer := True,
                  release_queue := tcb_sched_dequeue thread (release_queue s)\<rparr>)
        else P (s\<lparr>release_queue := tcb_sched_dequeue thread (release_queue s)\<rparr>)\<rbrace>
   tcb_release_remove thread
   \<lbrace>\<lambda>_. P\<rbrace>"
  by (wpsimp simp: tcb_release_remove_def obj_at_def | intro conjI)+

lemma tcb_release_remove_valid_sched_misc[wp]:
  "tcb_release_remove t \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                               (ready_queues s) (scheduler_action s)
                               (kheap s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma tcb_release_remove_valid_blocked_simp:
  assumes "T \<subseteq> S"
  assumes " valid_blocked_except_set_2 T queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  assumes "valid_blocked_thread id Not S queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs thread"
  shows "valid_blocked_except_set_2 S queues (tcb_sched_dequeue thread rlq) sa ct tcb_sts
                                      tcb_scps sc_refill_cfgs"
  using assms
  by (auto simp: valid_blocked_thread_def tcb_sched_dequeue_def in_queue_2_def
          elim!: valid_blockedE)

\<comment> \<open>Use more concrete T and S to avoid simplifier slow-down\<close>
lemmas tcb_release_remove_valid_blocked_simps[valid_sched_wpsimps] =
  tcb_release_remove_valid_blocked_simp[OF subset_refl]
  tcb_release_remove_valid_blocked_simp[where T=S and S="insert t' S" for t' S
                                        , OF subset_insertI, simplified]

lemmas tcb_release_remove_valid_blocked_bot_simps[valid_sched_wpsimps] =
  tcb_release_remove_valid_blocked_simps[OF _ valid_blocked_thread_bot_release_q]

lemma tcb_release_remove_weak_valid_sched_action_simp[valid_sched_wpsimps]:
  "weak_valid_sched_action_2 S curtime sa rlq tcb_sts tcb_scps sc_refill_cfgs
    \<Longrightarrow> weak_valid_sched_action_2 S curtime sa (tcb_sched_dequeue thread rlq) tcb_sts tcb_scps
                                  sc_refill_cfgs"
  by (simp add: weak_valid_sched_action_2_def tcb_sched_dequeue_def)

lemma tcb_release_remove_valid_sched_action_simp[valid_sched_wpsimps]:
  "valid_sched_action_2 wk S curtime sa ct cdom rlq etcb_heap tcb_sts tcb_scps sc_refill_cfgs
    \<Longrightarrow> valid_sched_action_2 wk S curtime sa ct cdom (tcb_sched_dequeue thread rlq) etcb_heap tcb_sts
                             tcb_scps sc_refill_cfgs"
  by (simp add: valid_sched_action_2_def valid_sched_wpsimps)

lemma tcb_release_remove_valid_blocked_except:
  "\<lbrace>valid_blocked_except thread\<rbrace>
   tcb_release_remove thread
   \<lbrace>\<lambda>_. valid_blocked_except thread\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps valid_blocked_thread_def)

lemma tcb_release_remove_weak_valid_sched_action[wp]:
  "\<lbrace>weak_valid_sched_action\<rbrace>
     tcb_release_remove thread
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma tcb_release_remove_valid_sched_action[wp]:
  "\<lbrace>valid_sched_action\<rbrace>
     tcb_release_remove thread
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma release_queue_update_idem:
  "f (release_queue s) = release_queue s \<Longrightarrow> release_queue_update f s = s"
  by auto

lemma tcb_release_remove_not_in_release_q_inv:
  "\<lbrace>P and not_in_release_q thread\<rbrace> tcb_release_remove thread \<lbrace>\<lambda>_. P\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: not_in_release_q_def tcb_sched_dequeue_def filter_id_conv
          elim!: ssubst[OF release_queue_update_idem, rotated])

(* FIXME: move *)
lemma sorted_wrt_filter[elim!]:
  "sorted_wrt P xs \<Longrightarrow> sorted_wrt P (filter f xs)"
  by (induct xs) auto

lemma tcb_release_remove_sorted_release_q[wp]:
  "\<lbrace>sorted_release_q\<rbrace> tcb_release_remove thread \<lbrace>\<lambda>_. sorted_release_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: tcb_sched_dequeue_def sorted_release_q_2_def)

lemma tcb_release_remove_valid_release_q[wp]:
  "\<lbrace>valid_release_q\<rbrace> tcb_release_remove thread \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_release_q_def tcb_sched_dequeue_def sorted_release_q_2_def)

lemma tcb_release_remove_valid_blocked_except_set_incl:
  "\<lbrace>\<lambda>s. valid_blocked_except_set S s \<and> t \<in> S\<rbrace>
   tcb_release_remove t
   \<lbrace>\<lambda>rv s. valid_blocked_except_set S s\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto elim!: valid_blockedE' simp: valid_sched_wpsimps in_queue_2_def)

lemma tcb_release_remove_valid_blocked:
  "\<lbrace>valid_blocked_except_set S and valid_blocked_thread_of id Not S thread\<rbrace>
   tcb_release_remove thread
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps valid_blocked_thread_def)

lemma tcb_release_remove_valid_blocked_remove: (* valid_sched is broken at thread *)
  "\<lbrace>valid_blocked_except_set (insert thread S) and valid_blocked_thread_of id \<bottom> S thread\<rbrace>
   tcb_release_remove thread
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_blocked_defs valid_sched_wpsimps in_queue_2_def tcb_sched_dequeue_def)

\<comment> \<open>set_scheduler_action\<close>

lemma set_scheduler_action_wp[valid_sched_wp]:
  "\<lbrace>\<lambda>s. Q (scheduler_action_update (\<lambda>_. a) s)\<rbrace> set_scheduler_action a \<lbrace>\<lambda>_.Q\<rbrace>"
  by (wpsimp simp: set_scheduler_action_def)

lemma set_scheduler_action_valid_sched_misc[wp]:
  "set_scheduler_action a \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                                 (idle_thread s) (ready_queues s) (release_queue s)
                                 (kheap s)\<rbrace>"
  by (wpsimp wp: set_scheduler_action_wp)

lemma simple_sched_action_def2[valid_sched_wpsimps]:
  "simple_sched_action_2 action \<equiv> action = resume_cur_thread \<or> action = choose_new_thread"
  by (auto simp: atomize_eq simple_sched_action_2_def split: scheduler_action.splits)

lemmas [valid_sched_wpsimps] =
  ct_not_in_q_def is_activatable_def valid_sched_action_def ct_in_cur_domain_def

lemma set_scheduler_action_rct_ct_not_in_q:
  "\<lbrace>ct_not_queued\<rbrace> set_scheduler_action resume_cur_thread \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_scheduler_action_rct_is_activatable:
  "\<lbrace>st_tcb_at activatable t\<rbrace>
     set_scheduler_action resume_cur_thread
   \<lbrace>\<lambda>_. is_activatable t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_scheduler_action_rct_weak_valid_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action resume_cur_thread \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_rct_valid_sched_action:
  "\<lbrace>\<lambda>s. st_tcb_at activatable (cur_thread s) s\<rbrace>
     set_scheduler_action resume_cur_thread
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_scheduler_action_rct_ct_in_cur_domain:
  "\<lbrace>\<lambda>s. in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s\<rbrace>
     set_scheduler_action resume_cur_thread  \<lbrace>\<lambda>_. ct_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_scheduler_action_valid_blocked_simple:
  "\<lbrace>valid_blocked_except_set S and simple_sched_action and (K (simple_sched_action_2 schact)) \<rbrace>
   set_scheduler_action schact
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_valid_blocked: (* when the next one doesn't hold *)
  "\<lbrace>valid_blocked_except_set S and (\<lambda>s. scheduler_action s = switch_thread t) \<rbrace>
     set_scheduler_action act
   \<lbrace>\<lambda>_. valid_blocked_except_set (insert t S)\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_valid_blocked_const:
  "\<lbrace>valid_blocked_except_set S and
      (\<lambda>s. \<forall>t. scheduler_action s = switch_thread t \<longrightarrow>
                t \<in> S \<or> in_ready_q t s \<or> in_release_q t s \<or> t = cur_thread s
                  \<or> \<not> (st_tcb_at active t s \<and> active_sc_tcb_at t s)) \<rbrace>
     set_scheduler_action act
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_valid_blocked_remove:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert t S) (s\<lparr>scheduler_action := switch_thread t\<rparr>)\<rbrace>
     set_scheduler_action (switch_thread t)
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_rct_valid_sched_simple:
  "\<lbrace>valid_sched and ct_not_queued
          and (\<lambda>s. st_tcb_at activatable (cur_thread s) s)
          and (\<lambda>s. in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s)
          and simple_sched_action\<rbrace>
     set_scheduler_action resume_cur_thread \<lbrace>\<lambda>_.valid_sched\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_rct_valid_sched_ct:
  "\<lbrace>valid_sched and ct_not_queued and (\<lambda>s. scheduler_action s = switch_thread (cur_thread s))
          and (\<lambda>s. st_tcb_at activatable (cur_thread s) s)
          and (\<lambda>s. in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s)\<rbrace>
     set_scheduler_action resume_cur_thread \<lbrace>\<lambda>_.valid_sched\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_cnt_ct_not_in_q[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_scheduler_action_cnt_is_activatable[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. is_activatable t\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_is_activatable'[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>r s. is_activatable (t s) s\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_switch_in_cur_domain[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. switch_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_ct_in_cur_domain[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. ct_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_weak_valid_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_valid_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_weak_valid_sched:
  "\<lbrace>valid_sched and simple_sched_action\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto elim!: valid_blockedE' simp: valid_sched_wpsimps)

lemma set_scheduler_action_simple_sched_action:
  "\<lbrace>K $ simple_sched_action_2 action\<rbrace>
    set_scheduler_action action
   \<lbrace>\<lambda>rv. simple_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemmas [valid_sched_wpsimps] = not_cur_thread_def

lemma set_sched_action_cnt_not_cur_thread[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>rv. not_cur_thread t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_sched_action_st_not_cur_thread[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action (switch_thread thread) \<lbrace>\<lambda>rv. not_cur_thread t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

\<comment> \<open>schedule_tcb\<close>

(* FIXME RT: simplify the spec for schedule_tcb? *)
lemma reschedule_required_resume_cur_thread_choose_new_thread_rewrite:
  "monadic_rewrite False True (\<lambda>s. scheduler_action s = resume_cur_thread)
                   reschedule_required (set_scheduler_action choose_new_thread)"
  apply (simp add: reschedule_required_def)
  apply (rule monadic_rewrite_trans[where Q=\<top>, OF monadic_rewrite_gets_known[where rv=resume_cur_thread], simplified])
  by (simp add: monadic_rewrite_refl)

(* FIXME RT: simplify the spec for schedule_tcb? *)
lemma schedule_tcb_choose_new_thread_rewrite:
  "monadic_rewrite False True \<top> (schedule_tcb t)
                   (do cur \<leftarrow> gets cur_thread;
                       sched_act \<leftarrow> gets scheduler_action;
                       schedulable \<leftarrow> is_schedulable t;
                       when (t = cur \<and> sched_act = resume_cur_thread \<and> \<not>schedulable)
                         $ set_scheduler_action choose_new_thread
                     od)"
  apply (simp add: schedule_tcb_def)
  apply (rule monadic_rewrite_bind_tail[OF _ gets_inv])
  apply (rule monadic_rewrite_bind_tail[OF _ hoare_gets_sp], simp)
  apply (rule monadic_rewrite_bind_tail[OF _ is_schedulable_inv])
  apply (simp add: when_def split del: if_split)
  apply (rule monadic_rewrite_imp[OF monadic_rewrite_if])
    apply (rule reschedule_required_resume_cur_thread_choose_new_thread_rewrite)
   apply (rule monadic_rewrite_refl)
  by simp

lemmas schedule_tcb_def2 = monadic_rewrite_to_eq[OF schedule_tcb_choose_new_thread_rewrite]

(* FIXME RT: move near is_schedulable_wp *)
lemma is_schedulable_wp':
  "\<lbrace>\<lambda>s. P (pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s \<and> \<not> (in_release_queue t s)) s\<rbrace>
   is_schedulable t
   \<lbrace>P\<rbrace>"
  by (wpsimp wp: is_schedulable_wp) (auto simp: obj_at_kh_kheap_simps schedulable_def2)

lemma schedule_tcb_wp:
  "\<lbrace>\<lambda>s. if t = cur_thread s \<and> scheduler_action s = resume_cur_thread
            \<and> (pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s \<longrightarrow> in_release_q t s)
        then P (s\<lparr>scheduler_action := choose_new_thread\<rparr>) else P s\<rbrace>
   schedule_tcb t
   \<lbrace>\<lambda>_. P\<rbrace>"
  by (wpsimp simp: schedule_tcb_def2 wp: set_scheduler_action_wp is_schedulable_wp')

lemma schedule_tcb_valid_sched_misc[wp]:
  "schedule_tcb t \<lbrace>\<lambda>s. P (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                         (ready_queues s) (release_queue s)
                         (kheap s)\<rbrace>"
  by (wpsimp wp: schedule_tcb_wp)

lemma schedule_tcb_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. P (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
          (if t = cur_thread s \<and> scheduler_action s = resume_cur_thread
              \<and> (pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s \<longrightarrow> in_release_q t s)
           then choose_new_thread else (scheduler_action s))
          (etcbs_of s) (tcb_sts_of s)
          (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   schedule_tcb t
   \<lbrace>\<lambda>_. valid_sched_pred P\<rbrace>"
  by (wpsimp wp: schedule_tcb_wp split: if_splits)

(* FIXME: move up *)
lemma not_cur_thread_2_simps[simp]:
  "not_cur_thread_2 t choose_new_thread ct"
  "not_cur_thread_2 t (switch_thread t') ct"
  "t \<noteq> ct \<Longrightarrow> not_cur_thread_2 t sa ct"
  by (auto simp: not_cur_thread_2_def)

(* FIXME: move up *)
lemma ct_not_in_q_2_simps[simp]:
  "ct_not_in_q_2 qs choose_new_thread ct"
  "ct_not_in_q_2 qs (switch_thread t) ct"
  "not_queued_2 qs ct \<Longrightarrow> ct_not_in_q_2 qs sa ct"
  by (auto simp: ct_not_in_q_2_def)

lemma schedule_tcb_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q\<rbrace> schedule_tcb ref \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

\<comment> \<open>reschedule_required\<close>

abbreviation (input) reschedule_required_wp where
  "reschedule_required_wp P s \<equiv>
    if \<forall>t. scheduler_action s = switch_thread t
            \<and> pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s
           \<longrightarrow> in_release_q t s
    then P (s\<lparr>scheduler_action := choose_new_thread\<rparr>)
    else \<forall>t p d. scheduler_action s = switch_thread t
                  \<and> etcb_eq p d t s \<and> budget_ready t s \<and> budget_sufficient t s
                 \<longrightarrow> P (ready_queues_update (tcb_sched_ready_q_update d p (tcb_sched_enqueue t)) s
                         \<lparr>scheduler_action := choose_new_thread\<rparr>)"

lemma reschedule_required_wp[valid_sched_wp]:
  "\<lbrace>reschedule_required_wp P\<rbrace> reschedule_required \<lbrace>\<lambda>rv. P\<rbrace>"
  apply (wpsimp simp: reschedule_required_def
                  wp: set_scheduler_action_wp tcb_sched_action_wp thread_get_wp' is_schedulable_wp')
  by (auto simp: vs_all_heap_simps obj_at_kh_kheap_simps)

lemma reschedule_required_valid_sched_misc[wp]:
  "reschedule_required \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                              (idle_thread s) (release_queue s) (kheap s)\<rbrace>"
  by (wpsimp wp: reschedule_required_wp)

lemma reschedule_required_ready_or_release[wp]:
  "reschedule_required \<lbrace>ready_or_release\<rbrace>"
  unfolding reschedule_required_def
  apply (wpsimp wp: thread_get_wp is_schedulable_wp)
  by (clarsimp simp: obj_at_def schedulable_def split: option.splits dest!: get_tcb_SomeD)

lemma reschedule_required_valid_ready_qs[wp]:
  "reschedule_required \<lbrace>valid_ready_qs\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps released_sc_tcb_at_def)

lemma reschedule_required_lift:
  assumes A: "\<And>t. \<lbrace>P\<rbrace> tcb_sched_action (tcb_sched_enqueue) t \<lbrace>\<lambda>_. P\<rbrace>"
  assumes B: "\<lbrace>P\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. P\<rbrace>"
  shows "\<lbrace>P\<rbrace> reschedule_required \<lbrace>\<lambda>_. P\<rbrace>"
  unfolding reschedule_required_def
  by (wpsimp wp: A B is_schedulable_wp' thread_get_wp')

lemma reschedule_required_ct_not_in_q[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_is_activatable[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. is_activatable t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_weak_valid_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_valid_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_ct_in_cur_domain[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. ct_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_scheduler_act_not[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. scheduler_act_not t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma reschedule_required_valid_blocked:
  "reschedule_required \<lbrace>valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (auto elim!: valid_blockedE' simp: valid_sched_wpsimps runnable_eq_active)

lemma reschedule_required_valid_sched_except_blocked:
  "\<lbrace>valid_release_q and valid_ready_qs
                    and ready_or_release
                    and weak_valid_sched_action
                    and valid_idle_etcb
                    and released_ipc_queues
                    and active_reply_scs
                    and active_sc_valid_refills\<rbrace>
   reschedule_required
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_sched_wpsimps released_sc_tcb_at_def runnable_eq_active
                 ready_or_release_2_def
          elim!: valid_blockedE')

lemma reschedule_required_valid_sched':
  "\<lbrace>valid_release_q and valid_ready_qs
                    and ready_or_release
                    and valid_blocked
                    and valid_idle_etcb
                    and released_ipc_queues
                    and active_reply_scs
                    and active_sc_valid_refills\<rbrace>
   reschedule_required
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def
  by (wpsimp wp: reschedule_required_valid_blocked)

lemma reschedule_required_switch_ct_not_in_q[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. not_cur_thread t\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma switch_thread_weak_valid_sched_action_is_schedulable:
  "\<lbrakk>scheduler_action s = switch_thread t; weak_valid_sched_action s\<rbrakk>
      \<Longrightarrow> the (is_schedulable_opt t s)"
  by (auto simp: is_schedulable_opt_def in_queue_2_def weak_valid_sched_action_def
                 obj_at_kh_kheap_simps vs_all_heap_simps
          split: option.splits)

lemma switch_thread_valid_sched_is_schedulable:
  "\<lbrakk>scheduler_action s = switch_thread t; valid_sched s\<rbrakk>
      \<Longrightarrow> the (is_schedulable_opt t s)"
  by (intro switch_thread_weak_valid_sched_action_is_schedulable
            valid_sched_weak_valid_sched_action)

lemma reschedule_valid_sched_except_blocked_const:
  "reschedule_required \<lbrace>valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: reschedule_required_valid_sched_except_blocked)
  by (simp add: valid_sched_def valid_sched_action_def)

lemma reschedule_valid_sched_const:
  "reschedule_required \<lbrace>valid_sched\<rbrace>"
  apply (wpsimp wp: reschedule_required_valid_sched')
  by (simp add: valid_sched_def valid_sched_action_def)

lemma reschedule_required_simple_sched_action[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required  \<lbrace>\<lambda>rv. simple_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma reschedule_required_not_queued:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace>
    reschedule_required
   \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps scheduler_act_not_def)

lemma reschedule_required_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane\<rbrace> reschedule_required \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps scheduler_act_not_def)

lemma reschedule_required_scheduler_act_sane[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

\<comment> \<open>test_reschedule\<close>

lemma test_reschedule_wp[valid_sched_wp]:
  "\<lbrace>\<lambda>s. if scheduler_action s \<noteq> switch_thread t \<and> cur_thread s \<noteq> t
        then P s
        else if \<forall>t. scheduler_action s = switch_thread t
                     \<and> pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s
                    \<longrightarrow> in_release_q t s
        then P (s\<lparr>scheduler_action := choose_new_thread\<rparr>)
        else \<forall>t p d. scheduler_action s = switch_thread t
                      \<and> etcb_eq p d t s \<and> budget_ready t s \<and> budget_sufficient t s
                     \<longrightarrow> P (ready_queues_update (tcb_sched_ready_q_update d p (tcb_sched_enqueue t)) s
                             \<lparr>scheduler_action := choose_new_thread\<rparr>)\<rbrace>
   test_reschedule t
   \<lbrace>\<lambda>rv. P\<rbrace>"
  supply if_split[split del]
  apply (wpsimp simp: test_reschedule_def wp: reschedule_required_wp)
  apply (clarsimp simp: if_distribR if_swap[where P="_ \<or> _"] elim!: if_weak_cong[THEN iffD1, rotated])
  by (auto split: scheduler_action.splits)

lemma test_reschedule_valid_sched_misc[wp]:
  "test_reschedule t \<lbrace>\<lambda>s. P (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                            (release_queue s) (kheap s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma test_reschedule_valid_sched_action:
  "test_reschedule t \<lbrace>valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

\<comment> \<open>set_thread_state\<close>

definition
  set_thread_state_only :: "obj_ref \<Rightarrow> thread_state \<Rightarrow> (unit,'z::state_ext) s_monad"
where
  "set_thread_state_only ref ts \<equiv> do
     tcb \<leftarrow> gets_the $ get_tcb ref;
     set_object ref (TCB (tcb \<lparr> tcb_state := ts \<rparr>))
   od"

lemma set_thread_state_def2:
  "set_thread_state ref ts \<equiv> do
     set_thread_state_only ref ts;
     set_thread_state_act ref
   od"
  by (simp add: set_thread_state_def set_thread_state_only_def bind_assoc)

crunches set_thread_state_act
  for valid_sched_except_sched_act[wp]:
    "\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
           (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
           (machine_state s) (kheap s)"

lemma set_thread_state_only_valid_sched_except_tcb_st[wp]:
  "set_thread_state_only t st
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
          (scheduler_action s) (etcbs_of s) (machine_state s) (tcb_scps_of s)
          (tcb_faults_of s) (scs_of s)\<rbrace>"
  by (wpsimp simp: set_thread_state_only_def vs_all_heap_simps obj_at_kh_kheap_simps sc_heap.all_simps
               wp: gets_the_wp' set_object_wp)

lemma set_thread_state_valid_sched_misc[wp]:
  "set_thread_state t st \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                                (cur_time s) (cur_domain s)
                                (cur_thread s) (idle_thread s)
                                (ready_queues s) (release_queue s)
                                (etcbs_of s) (machine_state s)
                                (tcb_scps_of s) (tcb_faults_of s) (scs_of s)\<rbrace>"
  by (wpsimp simp: set_thread_state_def2)

lemma set_thread_state_act_wp[valid_sched_wp]:
  "\<lbrace>\<lambda>s. if t = cur_thread s
           \<and> scheduler_action s = resume_cur_thread
           \<and> (pred_map runnable (tcb_sts_of s) t \<longrightarrow> active_sc_tcb_at t s \<longrightarrow> in_release_q t s)
        then P (s\<lparr>scheduler_action := choose_new_thread\<rparr>) else P s\<rbrace>
   set_thread_state_act t
   \<lbrace>\<lambda>rv. P\<rbrace>"
  by (wpsimp simp: set_thread_state_act_def wp: set_scheduler_action_wp is_schedulable_wp')

lemma set_thread_state_only_wp:
  "\<lbrace>\<lambda>s. \<forall>tcb. kheap s t = Some (TCB tcb)
              \<longrightarrow> P (kheap_update (\<lambda>kh. kh(t \<mapsto> TCB (tcb\<lparr>tcb_state := st\<rparr>))) s)\<rbrace>
   set_thread_state_only t st
   \<lbrace>\<lambda>rv. P\<rbrace>"
  apply (wpsimp simp: set_thread_state_only_def fun_upd_def wp: set_object_wp, rename_tac tcb)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps elim!: rsubst[of P])

lemma set_thread_state_only_tcb_st_heap:
  "\<lbrace>\<lambda>s. pred_map \<top> (tcbs_of s) t \<longrightarrow>
        P (tcb_sts_of s(t \<mapsto> st))
          (tcb_scps_of s) (tcb_faults_of s) (scs_of s)
          (cur_thread s) (scheduler_action s) (release_queue s)\<rbrace>
   set_thread_state_only t st
   \<lbrace>\<lambda>rv s. P (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (scs_of s)
             (cur_thread s) (scheduler_action s) (release_queue s)\<rbrace>"
  by (wpsimp wp: set_thread_state_only_wp simp: fun_upd_def vs_all_heap_simps sc_heap.all_simps)

lemma set_thread_state_scheduler_action_tcb_st_heap:
  "\<lbrace>\<lambda>s. pred_map \<top> (tcbs_of s) t \<longrightarrow>
        P (tcb_sts_of s(t \<mapsto> st))
          (if t = cur_thread s
              \<and> scheduler_action s = resume_cur_thread
              \<and> (runnable st \<longrightarrow> active_sc_tcb_at t s \<longrightarrow> in_release_q t s)
           then choose_new_thread else scheduler_action s)
          (cur_thread s) (release_queue s) (tcb_scps_of s) (tcb_faults_of s) (scs_of s)\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>rv s. P (tcb_sts_of s) (scheduler_action s) (cur_thread s) (release_queue s)
             (tcb_scps_of s) (tcb_faults_of s) (scs_of s)\<rbrace>"
  apply (wpsimp simp: set_thread_state_def2 wp: set_thread_state_act_wp set_thread_state_only_tcb_st_heap)
  by (auto simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps split: if_splits)

lemma set_thread_state_valid_sched_pred_strong':
  "\<lbrace>\<lambda>s. pred_map \<top> (tcbs_of s) t \<longrightarrow>
        P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s)
          (if t = cur_thread s
              \<and> scheduler_action s = resume_cur_thread
              \<and> (runnable st \<longrightarrow> active_sc_tcb_at t s \<longrightarrow> in_release_q t s)
           then choose_new_thread else scheduler_action s)
          (etcbs_of s)
          (tcb_sts_of s(t \<mapsto> st))
          (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  apply (rule hoare_lift_Pf2[where f=consumed_time, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=cur_sc, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=ep_send_qs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=ep_recv_qs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=cur_time, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=cur_domain, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=idle_thread, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=ready_queues, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=etcbs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=last_machine_time_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf2[where f=time_state_of, rotated], wpsimp)
  by (rule set_thread_state_scheduler_action_tcb_st_heap)

lemmas set_thread_state_valid_sched_pred_strong[valid_sched_wp]
  = set_thread_state_valid_sched_pred_strong'[THEN hoare_drop_assertion]

lemmas set_thread_state_valid_sched_pred
  = set_thread_state_valid_sched_pred_strong[where P="\<lambda>_ _ _ _ _ _ _. P :: valid_sched_t" for P]

lemma set_thread_state_valid_ready_qs:
  "\<lbrace>valid_ready_qs and (\<lambda>s. \<not> runnable ts \<longrightarrow> not_queued thread s)\<rbrace>
   set_thread_state thread ts
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_ready_qs_def vs_all_heap_simps not_queued_def, fastforce)

lemma set_thread_state_valid_release_q:
  "\<lbrace>valid_release_q
    and (\<lambda>s. \<not> runnable ts \<longrightarrow> not_in_release_q ref s)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_release_q_def vs_all_heap_simps in_release_q_def)

lemma set_thread_state_act_ct_not_in_q:
  "\<lbrace>ct_not_in_q\<rbrace> set_thread_state_act ref \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_thread_state_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q\<rbrace> set_thread_state ref ts \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma set_thread_state_act_is_activatable:
  "\<lbrace>\<lambda>s. ref \<noteq> cur_thread s \<longrightarrow> is_activatable (cur_thread s) s\<rbrace>
     set_thread_state_act ref
   \<lbrace>\<lambda>_ s. is_activatable (cur_thread s) s\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: is_activatable_def vs_all_heap_simps)

lemma set_thread_state_cur_is_activatable:
  "\<lbrace>\<lambda>s. is_activatable (cur_thread s) s\<rbrace>
     set_thread_state ref ts
   \<lbrace>\<lambda>_ s. is_activatable (cur_thread s) s\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: is_activatable_def vs_all_heap_simps)

lemma set_thread_state_act_weak_valid_sched_action:
  "set_thread_state_act ref \<lbrace>weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_thread_state_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action and (\<lambda>s. \<not> runnable ts \<longrightarrow> scheduler_act_not ref s)\<rbrace>
      set_thread_state ref ts
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: weak_valid_sched_action_def vs_all_heap_simps scheduler_act_not_def)

lemma set_thread_state_switch_in_cur_domain:
  "\<lbrace>switch_in_cur_domain\<rbrace>
      set_thread_state ref ts \<lbrace>\<lambda>_. switch_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_thread_state_valid_sched_action:
  "\<lbrace>valid_sched_action and (\<lambda>s. \<not> runnable ts \<longrightarrow> scheduler_act_not ref s)\<rbrace>
      set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp
           simp: valid_sched_wpsimps weak_valid_sched_action_def vs_all_heap_simps scheduler_act_not_def, fastforce)

lemma set_thread_state_cur_ct_in_cur_domain[wp]:
  "set_thread_state ref ts \<lbrace>ct_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

(* FIXME: move *)
lemma set_thread_state_ep_at_ppred[wp]:
  "set_thread_state t st \<lbrace>\<lambda>s. N (ep_at_ppred proj P p s)\<rbrace>"
  by (wpsimp simp: ep_at_ppred_def wp: sts_obj_at_impossible')

(* FIXME: move *)
lemma set_thread_state_ntfn_at_ppred[wp]:
  "set_thread_state t st \<lbrace>\<lambda>s. N (ntfn_at_ppred proj P p s)\<rbrace>"
  by (wpsimp simp: ntfn_at_ppred_def wp: sts_obj_at_impossible')

(* FIXME: replace existibg sts_obj_at_impossible'? *)
lemma sts_obj_at_impossible'':
  assumes "\<And>tcb st. P (TCB tcb) \<Longrightarrow> P (TCB (tcb\<lparr>tcb_state := st\<rparr>))"
  shows "set_thread_state t st \<lbrace>\<lambda>s. N (obj_at P p s)\<rbrace>"
  apply (wpsimp simp: set_thread_state_def wp: set_object_wp)
  apply (rename_tac tcb)
  apply (clarsimp elim!: rsubst[of N] dest!: get_tcb_SomeD simp: obj_at_def)
  apply (rule iffI, erule assms)
  apply (drule_tac st="tcb_state tcb" in assms, simp)
  done

lemma set_thread_state_runnable_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked and (\<lambda>s. runnable ts)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: set_thread_state_valid_ready_qs
                    set_thread_state_valid_release_q
                    set_thread_state_ct_not_in_q
                    set_thread_state_valid_sched_action
                    set_thread_state_cur_ct_in_cur_domain
                    set_thread_state_valid_sched_pred[where P=valid_sched_ipc_queues]
                    valid_idle_etcb_lift
              simp: valid_sched_def)
  by (auto simp: fun_upd_def vs_all_heap_simps is_blocked_thread_state_defs runnable_eq_active
          split: if_splits
          elim!: released_ipc_queuesE)

lemma set_thread_state_act_valid_blocked:
  "set_thread_state_act ref \<lbrace>valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto simp: valid_sched_wpsimps elim: valid_blockedE')

(* This is very close to a true weakest precondition statement *)
lemma set_thread_state_valid_blocked:
  "\<lbrace>valid_blocked_except_set (insert t S) and
      (\<lambda>s. runnable ts \<longrightarrow> active_sc_tcb_at t s
           \<longrightarrow> (t \<in> S \<or> in_ready_q t s \<or> in_release_q t s \<or> t = cur_thread s
               \<or> scheduler_action s = switch_thread t)) \<rbrace>
   set_thread_state t ts
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  apply (intro conjI impI; clarsimp simp: vs_all_heap_simps valid_blocked_defs split: if_splits)
  by auto

(* FIXME RT: remove, use set_thread_state_valid_blocked instead. *)
lemma set_thread_state_valid_blocked_const:
  "\<lbrace>valid_blocked_except_set S and
      (\<lambda>s. t \<in> S \<or> in_ready_q t s \<or> in_release_q t s \<or> t = cur_thread s
                  \<or> scheduler_action s = switch_thread t
                  \<or> (runnable ts \<longrightarrow> \<not> active_sc_tcb_at t s)) \<rbrace>
      set_thread_state t ts
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: set_thread_state_valid_blocked)

(* FIXME RT: remove, use set_thread_state_valid_blocked instead. *)
lemma set_thread_state_not_runnable_valid_blocked_remove:
  "\<lbrace>valid_blocked_except_set (insert ref S) and K (\<not> runnable ts)\<rbrace>
      set_thread_state ref ts
   \<lbrace>\<lambda>_. (valid_blocked_except_set S)\<rbrace>"
  by (wpsimp wp: set_thread_state_valid_blocked)

lemma set_thread_state_active_valid_sched:
  "active st \<Longrightarrow>
   \<lbrace>valid_sched and ct_active and (\<lambda>s. cur_thread s = ct) and active_sc_tcb_at ct\<rbrace>
     set_thread_state ct st \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp simp: valid_sched_def runnable_eq ct_in_state_def runnable_eq_active
                  wp: set_thread_state_valid_sched_action
                      set_thread_state_valid_blocked
                      set_thread_state_valid_ready_qs
                      set_thread_state_valid_release_q
                      set_thread_state_ct_not_in_q
                      set_thread_state_cur_ct_in_cur_domain
                      set_thread_state_valid_sched_pred[where P=valid_sched_ipc_queues])
  by (auto simp: vs_all_heap_simps fun_upd_def is_blocked_thread_state_defs
          elim!: released_ipc_queuesE split: if_splits)

lemma set_thread_state_Running_valid_sched:
  "\<lbrace>valid_sched and ct_active and (\<lambda>s. cur_thread s = ct) and active_sc_tcb_at ct\<rbrace>
     set_thread_state ct Running \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (rule set_thread_state_active_valid_sched) simp

lemma set_thread_state_Restart_valid_sched:
  "\<lbrace>valid_sched and ct_active and (\<lambda>s. cur_thread s = ct) and active_sc_tcb_at ct\<rbrace>
     set_thread_state ct Restart \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (rule set_thread_state_active_valid_sched) simp

lemma set_thread_state_act_sched_act_not[wp]:
  "\<lbrace>scheduler_act_not t\<rbrace> set_thread_state_act tp  \<lbrace>\<lambda>_. scheduler_act_not t\<rbrace>"
  apply (clarsimp simp: set_thread_state_act_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ is_schedulable_inv])
  apply (wpsimp simp: set_scheduler_action_def)
  done

crunch sched_act_not[wp]: set_thread_state "scheduler_act_not t"

lemma set_thread_state_not_runnable_valid_ready_qs:
  "\<lbrace>valid_ready_qs and (\<lambda>s. st_tcb_at (\<lambda>ts. \<not> runnable ts) ref s)\<rbrace>
     set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (wpsimp wp: set_thread_state_valid_ready_qs)
  apply (simp add: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (simp add: valid_ready_qs_def in_ready_q_def)
  by (fastforce simp: vs_all_heap_simps)

lemma set_thread_state_not_runnable_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> pred_map (\<lambda>ts. \<not> runnable ts) (tcb_sts_of s) ref\<rbrace>
     set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (wpsimp simp: set_thread_state_def set_thread_state_act_def wp: set_object_wp, rename_tac tcb)
  apply (simp add: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (simp add: valid_release_q_def, elim conjE ballEI)
  by (clarsimp simp add: vs_all_heap_simps)

lemma set_thread_state_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> (in_ready_q t s \<or> in_release_q t s \<or> scheduler_action s = switch_thread t \<longrightarrow> runnable st)
         \<and> (is_blocked_on_recv_ntfn st \<longrightarrow> released_if_bound_sc_tcb_at t s)
         \<and> (is_blocked_on_send st \<longrightarrow> valid_sender_sc_tcb_at t s)
         \<and> (is_blocked_on_reply st \<longrightarrow> active_if_bound_sc_tcb_at t s)\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: valid_sched_wp simp: valid_sched_def split_del: if_split)
  apply (intro conjI)
       apply (clarsimp simp: valid_ready_qs_def vs_all_heap_simps in_queues_2_def)
      apply (clarsimp simp: valid_release_q_def vs_all_heap_simps in_queue_2_def)
     apply clarsimp
    apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def is_activatable_def
                          vs_all_heap_simps)
   apply clarsimp
  by (clarsimp simp: vs_all_heap_simps is_blocked_thread_state_defs
              elim!: released_ipc_queuesE)

lemma set_thread_state_not_runnable_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> \<not> pred_map runnable (tcb_sts_of s) t
         \<and> (is_blocked_on_recv_ntfn st \<longrightarrow> released_if_bound_sc_tcb_at t s)
         \<and> (is_blocked_on_send st \<longrightarrow> valid_sender_sc_tcb_at t s)
         \<and> (is_blocked_on_reply st \<longrightarrow> active_if_bound_sc_tcb_at t s)\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: set_thread_state_valid_sched_except_blocked simp: valid_sched_def)
  apply (intro conjI; clarsimp)
    apply (fastforce simp: valid_ready_qs_def in_queues_2_def vs_all_heap_simps)
   apply (fastforce simp: valid_release_q_def in_queue_2_def vs_all_heap_simps)
  apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def)
  done

(* FIXME RT: see if it's possible to use set_thread_state_valid_sched_except_blocked instead. *)
lemmas set_thread_state_Inactive_not_runnable_valid_sched_except_blocked
  = set_thread_state_not_runnable_valid_sched_except_blocked[where st=Inactive, simplified]

lemma set_thread_state_Inactive_not_queued_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> valid_blocked_except ref s
        \<and> scheduler_act_not ref s \<and> not_queued ref s \<and> not_in_release_q ref s\<rbrace>
   set_thread_state ref Inactive
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: set_thread_state_valid_sched_except_blocked
                 set_thread_state_valid_blocked
           simp: valid_sched_valid_sched_except_blocked scheduler_act_not_def)

lemma set_thread_state_Inactive_not_runnable_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> valid_blocked_except ref s
        \<and> \<not> pred_map runnable (tcb_sts_of s) ref\<rbrace>
   set_thread_state ref Inactive
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: set_thread_state_Inactive_not_runnable_valid_sched_except_blocked
                 set_thread_state_valid_blocked
           simp: valid_sched_valid_sched_except_blocked)

crunch simple_sched_action[wp]: set_thread_state_act,schedule_tcb simple_sched_action
  (wp: hoare_vcg_if_lift2 hoare_drop_imp)

lemma set_thread_state_simple_sched_action[wp]:
  "\<lbrace>simple_sched_action\<rbrace> set_thread_state param_a param_b \<lbrace>\<lambda>_. simple_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

crunch not_cur_thread[wp]: schedule_tcb "not_cur_thread thread"
  (wp: crunch_wps hoare_vcg_if_lift2 reschedule_required_wp)

lemma set_thread_state_not_cur_thread[wp]:
  "\<lbrace>not_cur_thread thread\<rbrace> set_thread_state ref ts \<lbrace>\<lambda>rv. not_cur_thread thread\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

(* FIXME: move *)
lemma if_cancel_eq_True:
  "(c \<Longrightarrow> x = y) \<Longrightarrow> (if c then x else y) = y"
  by simp

(* FIXME: move *)
lemma if_cancel_eq_False:
  "(\<not>c \<Longrightarrow> x = y) \<Longrightarrow> (if c then x else y) = x"
  by auto

(* FIXME: move *)
lemmas if_cancel_eq_assm =
  if_cancel_eq_True if_cancel_eq_False

lemma set_thread_state_valid_release_q_except:
  "\<lbrace>valid_release_q\<rbrace>
      set_thread_state thread ts
   \<lbrace>\<lambda>rv. valid_release_q_except thread\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_release_q_def vs_all_heap_simps)

lemma tcb_release_remove_valid_release_q_except:
  "\<lbrace>valid_release_q_except thread\<rbrace>
      tcb_release_remove thread
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_release_q_def tcb_sched_dequeue_def sorted_release_q_def
      | rule conjI)+

lemma set_thread_state_Inactive_simple_sched_action_not_runnable:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> valid_blocked_except thread s
        \<and> simple_sched_action s \<and> \<not> pred_map runnable (tcb_sts_of s) thread\<rbrace>
   set_thread_state thread Inactive
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp wp: set_thread_state_Inactive_not_runnable_valid_sched)

global_interpretation schedule_tcb: non_heap_op "schedule_tcb t"
  by unfold_locales (wpsimp wp: schedule_tcb_wp)

crunches schedule_tcb
  for ct_active[wp]: ct_active

lemmas set_thread_state_active_valid_sched_except_blocked =
  set_thread_state_runnable_valid_sched_except_blocked[simplified runnable_eq_active]

lemma set_thread_state_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s
         \<and> (is_blocked_on_recv_ntfn ts \<longrightarrow> released_if_bound_sc_tcb_at ref s)
         \<and> (is_blocked_on_send ts \<longrightarrow> valid_sender_sc_tcb_at ref s)
         \<and> (is_blocked_on_reply ts \<longrightarrow> active_if_bound_sc_tcb_at ref s)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  apply (erule released_ipc_queuesE)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps runnable_eq)

lemma set_thread_state_runnable_released_ipc_queues:
  "\<lbrace>released_ipc_queues and (\<lambda>s. runnable ts)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (wpsimp wp: set_thread_state_released_ipc_queues)
  by (case_tac ts; simp)

lemma set_thread_state_runnable_valid_sched:
  "\<lbrace>valid_sched and st_tcb_at runnable ref and (\<lambda>s. runnable ts)\<rbrace> set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: set_thread_state_valid_ready_qs set_thread_state_valid_blocked_const
                    set_thread_state_valid_sched_action set_thread_state_runnable_released_ipc_queues
                    set_thread_state_valid_release_q simp: valid_sched_def)
  by (auto simp: valid_blocked_defs runnable_eq_active obj_at_kh_kheap_simps)

lemma set_thread_state_break_valid_sched:  (* ref is previously blocked *)
  "\<lbrace>valid_sched and K (runnable ts)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. valid_sched_except_blocked and valid_blocked_except ref\<rbrace>"
  apply (wpsimp wp: set_thread_state_runnable_valid_sched_except_blocked
                    set_thread_state_valid_blocked_const)
  apply (clarsimp simp: valid_sched_def)
  done

crunch ct_sched_act_not[wp]: set_thread_state "\<lambda>s. scheduler_act_not (cur_thread s) s"
  (wp: set_scheduler_action_wp gts_wp hoare_drop_imp
   simp: crunch_simps
   ignore: set_scheduler_action)

(* FIXME: move to KHeap_AI *)
lemma set_tcb_obj_ref_pred_tcb_at:
  assumes "\<And>tcb. proj (tcb_to_itcb (f (\<lambda>_. v) tcb)) = proj (tcb_to_itcb tcb)"
  shows "set_tcb_obj_ref f ref v \<lbrace>\<lambda>s. N (pred_tcb_at proj P t s)\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: pred_tcb_at_def obj_at_def assms)

lemma set_tcb_obj_ref_sc_at_pred_n[wp]:
  "set_tcb_obj_ref f ref v \<lbrace>\<lambda>s. R (sc_at_pred_n N proj P p s)\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: sc_at_pred_n_def obj_at_def)

lemma set_tcb_obj_ref_is_sc_active[wp]:
  "set_tcb_obj_ref f ref tptr \<lbrace>\<lambda>s. P (is_sc_active scp s)\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma set_tcb_obj_ref_is_refill_ready[wp]:
  "set_tcb_obj_ref f ref tptr \<lbrace>is_refill_ready scp\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma set_tcb_obj_ref_valid_sched_except_tcb_heap[wp]:
  "set_tcb_obj_ref f ref v \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                                  (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                                  (ready_queues s) (release_queue s) (scheduler_action s)
                                  (last_machine_time_of s) (scs_of s)\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp
           simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps sc_heap.all_simps)

lemma set_tcb_obj_ref_valid_sched_except_tcb_scp_heap:
  assumes "\<And>tcb. tcb_state (f (\<lambda>_. v) tcb) = tcb_state tcb"
  assumes "\<And>tcb. tcb_fault (f (\<lambda>_. v) tcb) = tcb_fault tcb"
  assumes "\<And>tcb. etcb_of (f (\<lambda>_. v) tcb) = etcb_of tcb"
  shows "set_tcb_obj_ref f ref v \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s)
                                        (ep_recv_qs_of s) (sc_tcbs_of s) (sc_replies_of s)
                                        (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                                        (ready_queues s) (release_queue s) (scheduler_action s)
                                        (etcbs_of s) (tcb_sts_of s)
                                        (tcb_faults_of s) (scs_of s)\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp
           simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps sc_heap.all_simps assms)

lemma set_tcb_obj_ref_valid_sched_pred:
  assumes "\<And>tcb. tcb_state (f (\<lambda>_. v) tcb) = tcb_state tcb"
  assumes "\<And>tcb. tcb_sched_context (f (\<lambda>_. v) tcb) = tcb_sched_context tcb"
  assumes "\<And>tcb. tcb_fault (f (\<lambda>_. v) tcb) = tcb_fault tcb"
  assumes "\<And>tcb. etcb_of (f (\<lambda>_. v) tcb) = etcb_of tcb"
  shows "set_tcb_obj_ref f ref v \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps assms)

lemmas set_bound_notification_valid_sched_pred[wp] =
  set_tcb_obj_ref_valid_sched_pred[where f=tcb_bound_notification_update, simplified]

lemmas set_tcb_yield_to_valid_ready_qs[wp] =
  set_tcb_obj_ref_valid_sched_pred[where f=tcb_yield_to_update, simplified]

lemmas set_tcb_sched_context_valid_sched_except_tcb_scp_heap[wp] =
  set_tcb_obj_ref_valid_sched_except_tcb_scp_heap[where f=tcb_sched_context_update, simplified]

lemma set_tcb_sched_context_valid_sched_pred':
  "\<lbrace>\<lambda>s. pred_map \<top> (tcb_sts_of s) ref
        \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
              (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
              (scheduler_action s) (etcbs_of s) (tcb_sts_of s)
              (tcb_scps_of s(ref \<mapsto> scpo)) (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref scpo
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps)

\<comment> \<open>The implication in the set_tcb_sched_context_valid_sched_pred' precondition
    is probably not useful, but this is to document that we are throwing away some
    information.\<close>
lemmas set_tcb_sched_context_valid_sched_pred[valid_sched_wp] =
  set_tcb_sched_context_valid_sched_pred'[THEN hoare_drop_assertion]

lemma set_tcb_sched_context_valid_ready_qs:
  "\<lbrace>valid_ready_qs and (\<lambda>s. in_ready_q ref s \<longrightarrow> (\<exists>p. sc = Some p \<and> released_sc_at p s))\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref sc
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding set_tcb_obj_ref_def
  apply simp
  apply (rule hoare_seq_ext[OF _ gets_the_sp])
  apply (wpsimp simp: vs_all_heap_simps obj_at_def set_object_def
                  wp: get_object_wp split: option.splits)
  apply (cases sc; simp)
   apply (clarsimp simp: valid_ready_qs_def vs_all_heap_simps not_queued_def dest!: get_tcb_SomeD)+
  apply (drule_tac x=d and y=p in spec2, clarsimp, drule_tac x=ref in bspec, simp, clarsimp)
  apply (clarsimp simp: in_queues_2_def)
  done

lemma set_tcb_sched_context_None_released_ipc_queues:
  "\<lbrace>released_ipc_queues\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref None
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: released_ipc_queues_defs vs_all_heap_simps not_queued_def)

lemma set_tcb_sched_context_None_valid_blocked:
  "\<lbrace>valid_blocked_except ref\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref None
   \<lbrace>\<lambda>_. valid_blocked\<rbrace>"
  apply (wpsimp wp: valid_sched_wp simp: valid_blocked_defs vs_all_heap_simps)
  by auto

lemma valid_ready_qs_no_sc_not_queued:
  "\<lbrakk>valid_ready_qs s; pred_map_eq None (tcb_scps_of s) ref\<rbrakk> \<Longrightarrow> not_queued ref s"
  by (fastforce simp: valid_ready_qs_def in_ready_q_def vs_all_heap_simps)

lemma set_tcb_sched_context_valid_release_q_not_queued:
  "\<lbrace>valid_release_q and not_in_release_q ref\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref sc
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (wpsimp wp: valid_sched_wp simp: valid_release_q_def vs_all_heap_simps not_in_release_q_def)
  apply (clarsimp elim!: sorted_release_qE simp: sc_ready_time_eq_iff)
  by (clarsimp simp: tcb_ready_times_defs map_project_simps opt_map_simps map_join_simps)

lemma valid_release_q_no_sc_not_in_release_q:
  "\<lbrakk>valid_release_q s; pred_map_eq None (tcb_scps_of s) ref\<rbrakk> \<Longrightarrow> not_in_release_q ref s"
  by (auto simp: valid_release_q_def in_release_q_def vs_all_heap_simps)

lemma set_tcb_sched_context_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s
        \<and> (in_release_q ref s \<longrightarrow>(\<exists>sp. scopt = Some sp \<and> is_active_sc sp s
                                       \<and> sc_ready_times_of s sp = tcb_ready_times_of s ref)) \<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref scopt
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding set_tcb_obj_ref_def
  apply simp
  apply (rule hoare_seq_ext[OF _ gets_the_sp])
  apply (wpsimp simp: vs_all_heap_simps obj_at_def set_object_def
                  wp: get_object_wp split: option.splits)
  by (clarsimp simp: valid_release_q_def vs_all_heap_simps in_release_q_def dest!: get_tcb_SomeD;
      fastforce elim!: sorted_release_qE split: option.splits
                 simp: tcb_ready_times_defs map_project_def map_join_def opt_map_def)

lemma set_tcb_sched_context_simple_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action and simple_sched_action\<rbrace>
      set_tcb_obj_ref tcb_sched_context_update ref scp
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp
           simp: weak_valid_sched_action_def simple_sched_action_def vs_all_heap_simps)

lemma set_tcb_obj_ref_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q scp s \<and> (sc_opt = Some scp \<longrightarrow> not_in_release_q ref s)\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update ref sc_opt
   \<lbrace>\<lambda>_ s. sc_not_in_release_q scp s\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto simp: vs_all_heap_simps split: if_splits)

lemma set_tcb_sched_context_simple_valid_sched_action:
  "\<lbrace>valid_sched_action and simple_sched_action\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update ref scptr \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: valid_sched_action_def wp: set_tcb_sched_context_simple_weak_valid_sched_action)

lemma set_tcb_sched_context_weak_valid_sched_action_act_not:
  "\<lbrace>weak_valid_sched_action and scheduler_act_not ref\<rbrace>
      set_tcb_obj_ref tcb_sched_context_update ref scp
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp
           simp: weak_valid_sched_action_def scheduler_act_not_def vs_all_heap_simps)

lemma set_tcb_sched_context_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action
    and (\<lambda>s. scheduler_action s = switch_thread ref
             \<longrightarrow> (\<exists>scp. scp_opt = Some scp \<and> released_sc_at scp s))\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref scp_opt
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp
           simp: weak_valid_sched_action_def obj_at_kh_kheap_simps vs_all_heap_simps)

lemma set_tcb_sched_context_valid_sched_action_Some:
  "\<lbrace>\<lambda>s. valid_sched_action s
         \<and> (scheduler_action s = switch_thread ref \<longrightarrow> released_sc_at scp s)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref (Some scp)
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: valid_sched_action_def wp: set_tcb_sched_context_weak_valid_sched_action)

lemma set_tcb_sched_context_valid_sched_action_act_not:
  "\<lbrace>valid_sched_action and scheduler_act_not ref\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref scp
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: valid_sched_action_def wp: set_tcb_sched_context_weak_valid_sched_action_act_not)

lemma set_tcb_sched_context_None_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set (insert thread S)\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update thread None
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp simp: obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps)
  by (auto elim!: valid_blockedE' simp: vs_all_heap_simps split: if_splits)

lemma set_tcb_sched_context_None_valid_blocked_except_set_const:
  "\<lbrace>valid_blocked_except_set S\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update thread None
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: set_tcb_sched_context_None_valid_blocked_except_set)

lemma set_tcb_sched_context_valid_blocked_Some':
  "\<lbrace>valid_blocked_except_set (insert t S) and
    (\<lambda>s. pred_map runnable (tcb_sts_of s) t \<and> is_active_sc sp s
         \<longrightarrow> t \<in> S \<or> in_ready_q t s \<or> in_release_q t s
             \<or> t = cur_thread s \<or> scheduler_action s = switch_thread t)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t (Some sp)
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp simp: obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps)
  by (auto elim!: valid_blockedE' split: if_splits simp: vs_all_heap_simps in_ready_q_def in_release_q_def)

lemma set_tcb_sched_context_valid_blocked_Some:
  "\<lbrace>valid_blocked_except_set S and
    (\<lambda>s. pred_map runnable (tcb_sts_of s) t \<and> is_active_sc sp s
         \<longrightarrow> t \<in> S \<or> in_ready_q t s \<or> in_release_q t s
             \<or> t = cur_thread s \<or> scheduler_action s = switch_thread t)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t (Some sp)
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: set_tcb_sched_context_valid_blocked_Some')

lemma set_tcb_sched_context_valid_blocked:
  "\<lbrace>valid_blocked and
    (\<lambda>s. case sc_opt of Some sp \<Rightarrow>
            not_queued t s \<and> not_in_release_q t s \<longrightarrow> (\<not> st_tcb_at active t s) \<or> \<not> is_sc_active sp s
          | _ \<Rightarrow> True)\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update t sc_opt \<lbrace>\<lambda>_. valid_blocked\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  by (auto simp: valid_blocked_defs obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps
                 not_queued_def not_in_release_q_def)

lemma set_tcb_sched_context_Some_valid_blocked_except:
  "\<lbrace>valid_blocked\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t (Some s)
   \<lbrace>\<lambda>_. valid_blocked_except t\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp simp: obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps)
  by (auto simp: valid_blocked_defs vs_all_heap_simps)

(* FIXME: move *)
lemma bool_to_bool_impE:
  "N P \<Longrightarrow> N (P \<longrightarrow> Q) \<Longrightarrow> N Q"
  by (rule bool_to_bool_cases[of N]; simp)

\<comment> \<open>Neither of the next two lemmas seems to be stronger than the other.\<close>
lemma set_tcb_sc_update_bound_sc_obj_tcb_at_eq':
  "\<lbrace>\<lambda>s. N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)
        \<and> (t' = t \<longrightarrow> N (bound_sc_obj_tcb_at (P (cur_time s)) t' s
                          \<longrightarrow> (\<exists>scp. scopt = Some scp
                                     \<and> pred_map (P (cur_time s)) (sc_refill_cfgs_of s) scp)))\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t scopt
   \<lbrace>\<lambda>rv s. N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (rule bool_to_bool_cases[of N]
         ; clarsimp simp: obj_at_kh_kheap_simps pred_map2'_pred_maps vs_all_heap_simps
                    cong: conj_cong)
  by auto

lemma set_tcb_sc_update_bound_sc_obj_tcb_at_eq:
  "\<lbrace>\<lambda>s. N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)
        \<and> (t' = t \<longrightarrow> bound_sc_obj_tcb_at (P (cur_time s)) t' s
                       = (\<exists>scp. scopt = Some scp
                                 \<and> pred_map (P (cur_time s)) (sc_refill_cfgs_of s) scp))\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t scopt
   \<lbrace>\<lambda>rv s. N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  by (auto elim!: rsubst[of N]
            simp: pred_map2'_pred_maps obj_at_kh_kheap_simps vs_all_heap_simps
            cong: option.case_cong conj_cong)

lemma set_tcb_pred_tcb_const:
  "\<forall>tcb. p (tcb_to_itcb (f (\<lambda>_. val) tcb)) = p (tcb_to_itcb (tcb)) \<Longrightarrow>
  set_tcb_obj_ref f ref val \<lbrace>(\<lambda>s. Q (pred_tcb_at p P t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  by (clarsimp simp: pred_tcb_at_def obj_at_def)

lemma set_tcb_obj_ref_obj_at_const:
  " \<forall>tcb. P (TCB (f (\<lambda>_. val) tcb)) = P (TCB (tcb)) \<Longrightarrow>
  \<lbrace>\<lambda>s. Q (obj_at P t s)\<rbrace> set_tcb_obj_ref f ref val \<lbrace>\<lambda>_. (\<lambda>s. Q (obj_at P t s))::det_state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: set_tcb_obj_ref_wp, clarsimp simp: obj_at_def)

lemma set_sc_obj_ref_obj_at_const:
  "\<forall>sc n. P (SchedContext (f (\<lambda>_. val) sc) n) = P (SchedContext ( sc) n) \<Longrightarrow>
  \<lbrace>\<lambda>s. Q (obj_at P t s)\<rbrace> set_sc_obj_ref f ref val \<lbrace>\<lambda>_. (\<lambda>s. Q (obj_at P t s))::det_state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: update_sched_context_wp, clarsimp simp: obj_at_def)

lemma set_tcb_active_sc_tcb_at_const:
  "\<forall>tcb. tcb_sched_context (f (\<lambda>_. val) tcb) = tcb_sched_context tcb \<Longrightarrow>
  set_tcb_obj_ref f ref val \<lbrace>(\<lambda>s. Q (active_sc_tcb_at t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def cong: conj_cong)
  by auto

lemma set_sc_active_sc_tcb_at_const:
  "\<forall>sc. sc_refill_max (f (\<lambda>_. val) sc) = sc_refill_max (sc) \<Longrightarrow>
  set_sc_obj_ref f ref val \<lbrace>(\<lambda>s. Q (active_sc_tcb_at t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def cong: conj_cong)
  by auto

lemma set_tcb_budget_sufficient_const:
  "\<forall>tcb. tcb_sched_context (f (\<lambda>_. val) tcb) = tcb_sched_context tcb \<Longrightarrow>
  set_tcb_obj_ref f ref val \<lbrace>(\<lambda>s. Q (budget_sufficient t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def  cong: conj_cong)
  by auto

lemma set_sc_budget_sufficient_const:
  "\<forall>sc. sc_refills (f (\<lambda>_. val) sc) = sc_refills (sc) \<Longrightarrow>
  set_sc_obj_ref f ref val \<lbrace>(\<lambda>s. Q (budget_sufficient t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def  cong: conj_cong)
  by auto

lemma set_tcb_obj_ref_budget_ready_const:
  "\<forall>tcb. tcb_sched_context (f (\<lambda>_. val) tcb) = tcb_sched_context tcb \<Longrightarrow>
  set_tcb_obj_ref f ref val \<lbrace>(\<lambda>s. Q (budget_ready t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def  cong: conj_cong)
  by auto

lemma set_sc_obj_ref_budget_ready_const:
  "\<forall>sc. r_time (refill_hd (f (\<lambda>_. val) sc)) = r_time (refill_hd (sc)) \<Longrightarrow>
  set_sc_obj_ref f ref val \<lbrace>(\<lambda>s. Q (budget_ready t s))::det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (erule back_subst[where P=Q])
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refill_ready_def cong: conj_cong)
  by auto

lemma set_tcb_sc_update_bound_sc_obj_tcb_at:
  "\<lbrace>\<lambda>s. (tptr \<noteq> t \<longrightarrow> bound_sc_obj_tcb_at (P (cur_time s)) t s)
        \<and> (tptr = t \<longrightarrow> pred_map (P (cur_time s)) (sc_refill_cfgs_of s) scp)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr (Some scp)
   \<lbrace>\<lambda>rv s. bound_sc_obj_tcb_at (P (cur_time s)) t s\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (case_tac "tptr = t"; clarsimp simp: vs_all_heap_simps obj_at_def)
  by (rule_tac x=ref' in exI, fastforce)

lemmas set_tcb_sc_update_active_sc_tcb_at =
  set_tcb_sc_update_bound_sc_obj_tcb_at[where P="\<lambda>_. active_scrc", folded obj_at_kh_kheap_simps]

lemma set_tcb_sc_update_bound_sc_obj_tcb_at_neq:
  "\<lbrace>\<lambda>s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s) \<and> t \<noteq> tptr \<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr scopt
   \<lbrace>\<lambda>rv s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  by (wpsimp wp: set_tcb_sc_update_bound_sc_obj_tcb_at_eq)

lemma set_tcb_sc_update_active_sc_tcb_at_eq:
  "\<lbrace>\<lambda>s. P (active_sc_tcb_at t s) \<and>
   (active_sc_tcb_at t s \<longleftrightarrow> (\<exists>scp. scopt = Some scp \<and> is_sc_active scp s)) \<rbrace>
      set_tcb_obj_ref tcb_sched_context_update t scopt \<lbrace>\<lambda>rv s. P (active_sc_tcb_at t s)\<rbrace>"
  by (wpsimp simp: obj_at_kh_kheap_simps wp: set_tcb_sc_update_bound_sc_obj_tcb_at_eq)

\<comment> \<open>update_sched_context, set_refills\<close>

(* FIXME RT: move *)
definition heap_upd :: "('v \<Rightarrow> 'v) \<Rightarrow> 'a \<Rightarrow> ('a \<rightharpoonup> 'v) \<Rightarrow> 'a \<rightharpoonup> 'v" where
  "heap_upd f ref heap \<equiv> \<lambda>x. if x = ref then map_option f (heap ref) else heap x"

(* FIXME RT: move *)
lemma heap_upd_id[simp]:
  "heap_upd id ref = id"
  by (fastforce simp: heap_upd_def map_option.id)

(* FIXME RT: figure out a systematic way to generate rules like these. *)
lemma sc_heap_proj_known_sc:
  assumes "kh scp = Some (SchedContext sc n)"
  shows "P (sc_refill_cfgs_of_kh kh scp) = P (Some (sc_refill_cfg_of sc))"
    and "Q (sc_tcbs_of_kh kh scp) = Q (Some (sc_tcb sc))"
    and "R (sc_replies_of_kh kh scp) = R (Some (sc_replies sc))"
  by (rule arg_cong[where f=P] arg_cong[where f=Q] arg_cong[where f=R], simp add: vs_all_heap_simps assms)+

lemma update_sched_context_sc_heap:
  "\<lbrace>\<lambda>s. \<forall>sc. scs_of s scp = Some sc \<longrightarrow> P (scs_of s(scp \<mapsto> f sc))\<rbrace>
   update_sched_context scp f
   \<lbrace>\<lambda>rv s. P (scs_of s)\<rbrace>"
  by (wpsimp wp: update_sched_context_wp
           simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps sc_heap.all_simps)

lemma update_sched_context_valid_sched_pred':
  assumes "\<And>sc. sc_refill_cfg_of (f sc) = g (sc_refill_cfg_of sc)"
  assumes "\<And>sc. sc_tcb (f sc) = h (sc_tcb sc)"
  assumes "\<And>sc. sc_replies (f sc) = k (sc_replies sc)"
  shows "\<lbrace>\<lambda>s. pred_map \<top> (scs_of s) scp
              \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                    (heap_upd h scp (sc_tcbs_of s)) (last_machine_time_of s) (time_state_of s)
                    (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                    (ready_queues s) (release_queue s) (scheduler_action s)
                    (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                    (heap_upd g scp (sc_refill_cfgs_of s)) (heap_upd k scp (sc_replies_of s))\<rbrace>
         update_sched_context scp f
         \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: update_sched_context_wp
           simp: fun_upd_def heap_upd_def obj_at_kh_kheap_simps vs_all_heap_simps
                 sc_heap_proj_known_sc assms)

lemmas update_sched_context_valid_sched_pred =
  update_sched_context_valid_sched_pred'[THEN hoare_drop_assertion]

lemmas update_sched_context_valid_sched_pred_inv =
  update_sched_context_valid_sched_pred[where g=id and h=id and k=id and f="\<lambda>sc. upd (f sc) sc" for upd f
                                        , simplified]

lemmas update_sched_context_valid_sched_pred_invs[wp] =
  update_sched_context_valid_sched_pred_inv[where upd=sc_consumed_update, simplified]
  update_sched_context_valid_sched_pred_inv[where upd=sc_ntfn_update, simplified]
  update_sched_context_valid_sched_pred_inv[where upd=sc_badge_update, simplified]
  update_sched_context_valid_sched_pred_inv[where upd=sc_sporadic_update, simplified]
  update_sched_context_valid_sched_pred_inv[where upd=sc_yield_from_update, simplified]

lemmas update_sc_refills_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_refills_update f" and g="scrc_refills_update f" and h=id and k=id for f, simplified]

lemmas update_sc_refill_max_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_refill_max_update f" and g="scrc_refill_max_update f" and h=id and k=id for f, simplified]

lemmas update_sc_period_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_period_update f" and g="scrc_period_update f" and h=id and k=id for f, simplified]

lemmas update_sc_budget_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_budget_update f" and g="scrc_budget_update f" and h=id and k=id for f, simplified]

lemmas update_sc_refill_cfg_valid_sched_misc =
  update_sched_context_valid_sched_pred
    [where h=id and k=id
       and P="\<lambda>cons csc ep_send_qs ep_recv_qs sc_tcbs lmt ts ctime cdom ct it rqs rlq sa etcbs sts scps faults _ repl.
                P cons csc ep_send_qs ep_recv_qs sc_tcbs lmt ts ctime cdom ct it rqs rlq sa etcbs sts scps faults repl :: bool" for P
     , simplified]

lemmas update_sc_refill_cfg_valid_sched_miscs[wp] =
  update_sc_refill_cfg_valid_sched_misc[where f="sc_refills_update f" and g="scrc_refills_update f" for f, simplified]
  update_sc_refill_cfg_valid_sched_misc[where f="sc_refill_max_update f" and g="scrc_refill_max_update f" for f, simplified]
  update_sc_refill_cfg_valid_sched_misc[where f="sc_period_update f" and g="scrc_period_update f" for f, simplified]
  update_sc_refill_cfg_valid_sched_misc[where f="sc_budget_update f" and g="scrc_budget_update f" for f, simplified]

lemmas update_sc_tcb_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_tcb_update f" and g=id and h=f and k=id for f, simplified]

lemmas update_sc_tcb_valid_sched_misc[wp] =
  update_sc_tcb_valid_sched_pred[where P="\<lambda>cons csc ep_send_qs ep_recv_qs _ lmt ts. P cons csc ep_send_qs ep_recv_qs lmt ts :: valid_sched_t" for P]

lemmas update_sc_replies_valid_sched_pred[valid_sched_wp] =
  update_sched_context_valid_sched_pred
    [where f="sc_replies_update f" and g=id and h=id and k=f for f, simplified]

lemmas update_sc_replies_valid_sched_misc[wp] =
  update_sc_replies_valid_sched_pred[where P="\<lambda>cons csc ep_send_qs ep_recv_qs sc_tcbs lmt ts ctime cdom ct it rqs rlq sa etcbs sts scps faults rcs _.
                                             P cons csc ep_send_qs ep_recv_qs sc_tcbs lmt ts ctime cdom ct it rqs rlq sa etcbs sts scps faults rcs :: bool" for P]

lemma set_refills_valid_sched_pred':
  "\<lbrace>\<lambda>s. pred_map \<top> (scs_of s) scp
        \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
              (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
              (ready_queues s) (release_queue s) (scheduler_action s)
              (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
              (heap_upd (scrc_refills_update (\<lambda>_. refills)) scp (sc_refill_cfgs_of s))
              (sc_replies_of s)\<rbrace>
   set_refills scp refills
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: set_refills_def fun_upd_def heap_upd_def vs_all_heap_simps sc_heap_proj_known_sc
               wp: update_sched_context_valid_sched_pred'
                     [where f="sc_refills_update f" and g="scrc_refills_update f" and h=id and k=id for f, simplified])

lemmas set_refills_valid_sched_pred[valid_sched_wp] =
  set_refills_valid_sched_pred'[THEN hoare_drop_assertion]

lemma update_sched_context_valid_sched_misc[wp]:
  "update_sched_context scp f \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                                     (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                                     (ready_queues s) (release_queue s) (scheduler_action s)
                                     (last_machine_time_of s) (tcbs_of s)\<rbrace>"
  by (wpsimp wp: update_sched_context_wp
           simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps tcb_heap.all_simps)

lemma set_refills_valid_sched_misc[wp]:
  "set_refills scp refills \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                                  (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_domain s)
                                  (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
                                  (scheduler_action s) (tcbs_of s)\<rbrace>"
  apply (rule hoare_lift_Pf[where f=sc_tcbs_of, rotated], wp valid_sched_wp)
  apply (rule hoare_lift_Pf[where f=sc_replies_of, rotated], wp valid_sched_wp)
  by (wpsimp simp: set_refills_def)

lemma update_sched_context_is_sc_active_indep:
  "\<forall>sc. sc_active (f sc) \<longleftrightarrow> sc_active sc
   \<Longrightarrow> update_sched_context ref f \<lbrace>\<lambda>s. P (is_sc_active scp s)\<rbrace>"
  apply (wpsimp simp: update_sched_context_def set_object_def
                  wp: get_object_wp)
  by (clarsimp simp: is_sc_active_def obj_at_def)

lemma sc_tcb_update_is_sc_active[wp]:
  "update_sched_context ref (sc_tcb_update f) \<lbrace>\<lambda>s. P (is_sc_active scp s)\<rbrace>"
  by (clarsimp simp: update_sched_context_is_sc_active_indep)

lemma sc_replies_update_is_sc_active[wp]:
  "update_sched_context ref (sc_replies_update f) \<lbrace>\<lambda>s. P (is_sc_active t s)\<rbrace>"
  by (clarsimp simp: update_sched_context_is_sc_active_indep)

lemma update_sched_context_is_refill_sufficient_indep:
  "\<forall>sc. sc_refills (f sc) = sc_refills sc
   \<Longrightarrow> update_sched_context ref f \<lbrace>is_refill_sufficient y scp\<rbrace>"
  by (wpsimp wp: update_sched_context_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma update_sched_context_is_refill_ready_indep:
  "\<forall>sc. sc_refills (f sc) = sc_refills sc
   \<Longrightarrow> update_sched_context ref f \<lbrace>is_refill_ready scp\<rbrace>"
  by (wpsimp wp: update_sched_context_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma sc_replies_update_sc_tcb_sc_at[wp]:
  "update_sched_context scp (sc_replies_update f) \<lbrace>\<lambda>s. N (sc_tcb_sc_at P t s)\<rbrace>"
  apply (clarsimp simp: update_sched_context_def)
  apply (wpsimp simp: set_object_def wp: get_object_wp)
  by (auto simp: sc_tcb_sc_at_def pred_tcb_at_def obj_at_def)

lemma set_refills_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and>
    (\<forall>tcb_ptr. pred_map_eq (Some sc_ptr) (tcb_scps_of s) tcb_ptr \<longrightarrow>
               in_ready_q tcb_ptr s \<longrightarrow>
               refill_sufficient 0 (hd refills) \<and> refill_ready (cur_time s) (hd refills))\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce simp: valid_ready_qs_def vs_all_heap_simps in_ready_q_def heap_upd_def)

lemma active_sc_refills_update_eq[simp]:
  "active_sc_tcb_at_pred tcb_scps (heap_upd (scrc_refills_update f) scp sc_refill_cfgs) t
   \<longleftrightarrow> active_sc_tcb_at_pred tcb_scps sc_refill_cfgs t"
  apply (clarsimp simp: active_sc_def heap_upd_def pred_map_simps opt_map_simps map_join_simps split: if_splits)
  apply (rule iffI, fastforce)
  apply (clarsimp, rename_tac sc scp')
  apply (rule_tac x="if scp' = scp then scrc_refills_update f sc else sc" in exI)
  by auto

lemma set_refills_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s
        \<and> (\<forall>t. heap_ref_eq sc_ptr t (tcb_scps_of s)
               \<longrightarrow> requires_released_if_bound_sc_tcb_at t s
               \<longrightarrow> refill_sufficient 0 (hd refills) \<and> refill_ready (cur_time s) (hd refills))\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  apply (clarsimp simp: elim!: released_ipc_queuesE)
  by (fastforce simp: vs_all_heap_simps heap_upd_def split: if_splits)

lemma set_refills_valid_ready_qs_not_queued:
  "\<lbrace>valid_ready_qs and sc_not_in_ready_q sc_ptr\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  by (wpsimp wp: set_refills_valid_ready_qs simp: obj_at_kh_kheap_simps in_queues_2_def)

(* FIXME RT: find a nicer calculus for dealing with sorted_release_q *)
lemma set_refills_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s
        \<and> (\<forall>t. pred_map_eq (Some sc_ptr) (tcb_scps_of s) t
               \<longrightarrow> in_release_q t s
               \<longrightarrow> tcb_ready_times_of s t = Some (r_time (hd refills)))\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  apply (clarsimp simp: valid_release_q_def heap_upd_def vs_all_heap_simps in_release_q_def)
  apply (rule conjI, fastforce)
  apply (erule sorted_release_qE)
  apply (rule option_eqI)
   apply (clarsimp simp: tcb_ready_times_defs map_project_simps opt_map_simps map_join_simps vs_all_heap_simps)
   apply fastforce
  apply (drule (1) bspec)
  apply (clarsimp simp: tcb_ready_times_defs map_project_simps opt_map_simps map_join_simps vs_all_heap_simps)
  by (case_tac "ref' = sc_ptr"; fastforce)

lemma set_refills_sc_tcb_sc_at[wp]:
  "set_refills sc_ptr' refills \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  unfolding set_refills_def
  apply (wpsimp wp: update_sched_context_wp )
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  done

lemmas set_refills_budget_ready = set_refills_bound_sc_obj_tcb_at_refills_cur_time[where P="\<lambda>curtime refills. refill_ready curtime (hd refills)"]
lemmas set_refills_budget_sufficient = set_refills_bound_sc_obj_tcb_at_refills_simple[where P="\<lambda>refills. refill_sufficient 0 (hd refills)"]

lemma set_refills_budget_ready_other:
  "\<lbrace>budget_ready t and
    (\<lambda>s. bound_sc_tcb_at (\<lambda>x. x \<noteq> (Some sc_ptr)) t s)\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. budget_ready t\<rbrace>"
  by (wpsimp wp: set_refills_budget_ready simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma set_refills_budget_sufficient_other:
  "\<lbrace>budget_sufficient t and
    (\<lambda>s. bound_sc_tcb_at (\<lambda>x. x \<noteq> (Some sc_ptr)) t s)\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. budget_sufficient t\<rbrace>"
  by (wpsimp wp: set_refills_budget_sufficient simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemmas update_sc_refills_active_sc_tcb_at[wp]
  = bound_sc_obj_tcb_at_update_sched_context_no_change[where P=active_scrc and f="\<lambda>sc. sc\<lparr>sc_refills := f sc\<rparr>" for f, simplified]

lemmas set_refills_active_sc_tcb_at[wp]
  = bound_sc_obj_tcb_at_set_refills_no_change[where P=active_scrc, simplified]

lemma set_refills_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action and
    (\<lambda>s. \<forall>tcb_ptr. pred_map_eq (Some sc_ptr) (tcb_scps_of s) tcb_ptr \<longrightarrow>
                   scheduler_action s = switch_thread tcb_ptr \<longrightarrow>
                   refill_sufficient 0 (hd refills) \<and> refill_ready (cur_time s) (hd refills))\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce simp: heap_upd_def weak_valid_sched_action_def vs_all_heap_simps cong: conj_cong)

lemma set_refills_weak_valid_sched_action_act_not:
  "\<lbrace>weak_valid_sched_action and sc_scheduler_act_not sc_ptr\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: set_refills_weak_valid_sched_action
           simp: scheduler_act_not_def) fastforce

lemma set_refills_valid_sched_action:
  "\<lbrace>valid_sched_action and
    (\<lambda>s. \<forall>tcb_ptr. pred_map_eq (Some sc_ptr) (tcb_scps_of s) tcb_ptr \<longrightarrow>
                   scheduler_action s = switch_thread tcb_ptr \<longrightarrow>
                   refill_sufficient 0 (hd refills) \<and> refill_ready (cur_time s) (hd refills))\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: valid_sched_action_def wp: set_refills_weak_valid_sched_action)

lemma set_refills_valid_sched_action_act_not:
  "\<lbrace>valid_sched_action and sc_scheduler_act_not sc_ptr\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: scheduler_act_not_def obj_at_def
               wp: set_refills_valid_sched_action) fastforce

lemma set_refills_valid_blocked_except_set[wp]:
  "set_refills sc_ptr refills \<lbrace>valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto elim!: valid_blockedE' simp: heap_upd_def vs_all_heap_simps split: if_splits)

lemma set_refills_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills and
    (\<lambda>s. is_active_sc sc_ptr s \<longrightarrow>
         pred_map (\<lambda>sc. cfg_valid_refills (sc\<lparr>scrc_refills := refills\<rparr>)) (sc_refill_cfgs_of s) sc_ptr
         \<and> pred_map (\<lambda>sc. cfg_bounded_release_time (sc\<lparr>scrc_refills := refills\<rparr>))
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>rv. active_sc_valid_refills\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (clarsimp simp: active_sc_valid_refills_def vs_all_heap_simps heap_upd_def)

lemma set_refills_active_reply_scs[wp]:
  "set_refills scp refills \<lbrace>active_reply_scs\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto elim!: active_reply_scsE simp: heap_upd_def vs_all_heap_simps)

lemma set_refills_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s
        \<and> (\<forall>t. pred_map_eq (Some scp) (tcb_scps_of s) t
               \<longrightarrow> (scheduler_action s = switch_thread t \<or> in_ready_q t s \<or> requires_released_if_bound_sc_tcb_at t s
                    \<longrightarrow> refill_sufficient 0 (hd refills) \<and> refill_ready (cur_time s) (hd refills))
                   \<and> (in_release_q t s \<longrightarrow> tcb_ready_times_of s t = Some (r_time (hd refills))))
        \<and> (is_active_sc scp s \<longrightarrow>
           pred_map (\<lambda>sc. cfg_valid_refills (sc\<lparr>scrc_refills := refills\<rparr>)) (sc_refill_cfgs_of s) scp \<and>
           pred_map (\<lambda>sc. cfg_bounded_release_time (sc\<lparr>scrc_refills := refills\<rparr>))
                          (sc_refill_cfgs_of s) scp)\<rbrace>
   set_refills scp refills
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def
               wp: set_refills_valid_ready_qs set_refills_valid_release_q valid_idle_etcb_lift
                   set_refills_valid_sched_action set_refills_active_sc_valid_refills
                   set_refills_released_ipc_queues)

lemma set_refills_valid_sched_not_in:
  "\<lbrace>valid_sched and sc_not_in_release_q sc_ptr and
     sc_not_in_ready_q sc_ptr and sc_scheduler_act_not sc_ptr and sc_not_in_ep_q sc_ptr
    and (\<lambda>s. is_active_sc sc_ptr s
             \<longrightarrow> pred_map (\<lambda>sc. cfg_valid_refills (sc\<lparr>scrc_refills := refills\<rparr>)) (sc_refill_cfgs_of s) sc_ptr
                 \<and> pred_map (\<lambda>sc. cfg_bounded_release_time (sc\<lparr>scrc_refills := refills\<rparr>))
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def
  by (wpsimp wp: set_refills_valid_release_q set_refills_active_sc_valid_refills
                 set_refills_valid_ready_qs_not_queued
                 set_refills_valid_sched_action_act_not
                 set_refills_released_ipc_queues
           simp: pred_map_ipc_queued_thread_state_iff)

\<comment> \<open>sched_context_donate\<close>

crunches sched_context_donate
  for consumed_time[wp]: "\<lambda>s. P (consumed_time s)"
  and cur_time[wp]: "\<lambda>s. P (cur_time s)"
  and cur_domain[wp]: "\<lambda>s. P (cur_domain s)"
  and last_machine_time_of[wp]: "\<lambda>s. P (last_machine_time_of s)"
  and ep_send_qs_of[wp]: "\<lambda>s. P (ep_send_qs_of s)"
  and ep_recv_qs_of[wp]: "\<lambda>s. P (ep_recv_qs_of s)"
  (wp: crunch_wps)

lemma sched_context_donate_etcb_heap[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (etcbs_of s)\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: tcb_release_remove_wp)

lemma sched_context_donate_tcb_st_heap[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (tcb_sts_of s)\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: tcb_release_remove_wp)

lemma sched_context_donate_tcb_fault_heap[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (tcb_faults_of s)\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: tcb_release_remove_wp)

lemma sched_context_donate_sc_refill_cfg_heap[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: tcb_release_remove_wp)

lemma sched_context_donate_sc_replies_heap[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (sc_replies_of s)\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: tcb_release_remove_wp)

lemma sched_context_donate_valid_sched_misc[wp]:
  "sched_context_donate scp t \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                                     (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                                     (etcbs_of s) (tcb_sts_of s)
                                     (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>"
  apply (rule hoare_lift_Pf[where f=consumed_time, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=cur_sc, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=ep_send_qs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=ep_recv_qs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=cur_time, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=cur_domain, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=cur_thread, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=idle_thread, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=last_machine_time_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=etcbs_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=tcb_sts_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=tcb_faults_of, rotated], wpsimp)
  apply (rule hoare_lift_Pf[where f=sc_refill_cfgs_of, rotated], wpsimp)
  by wpsimp

crunches sched_context_donate
  for simple[wp]: simple_sched_action
  (simp: crunch_simps)

(* FIXME RT: this naming is inconsistent *)
abbreviation cur_sc_offset_sufficient :: "time \<Rightarrow> 'z state \<Rightarrow> bool"
where
  "cur_sc_offset_sufficient usage s \<equiv>
      cur_sc s \<noteq> idle_sc_ptr \<longrightarrow> is_refill_sufficient usage (cur_sc s) s"

abbreviation cur_sc_budget_sufficient :: "'z state \<Rightarrow> bool"
where
  "cur_sc_budget_sufficient s \<equiv>
      is_refill_sufficient 0 (cur_sc s) s"

(* FIXME RT: move *)
definition cur_sc_not_blocked_2 where
  "cur_sc_not_blocked_2 csc tcbspcs tcbsts \<equiv>
     \<forall>t. pred_map_eq (Some csc) (tcbspcs) t
         \<longrightarrow> \<not> pred_map ipc_queued_thread_state tcbsts t"

abbreviation cur_sc_not_blocked where
  "cur_sc_not_blocked s \<equiv> cur_sc_not_blocked_2 (cur_sc s) (tcb_scps_of s) (tcb_sts_of s)"

lemmas cur_sc_not_blocked_def = cur_sc_not_blocked_2_def

lemma as_user_tcb_arch_inv:
  assumes "\<And>s tcb upd. \<lbrakk> kheap s t = Some (TCB tcb); P s \<rbrakk>
                        \<Longrightarrow> P (kheap_update (\<lambda>kh. kh(t \<mapsto> TCB (tcb_arch_update upd tcb))) s)"
  shows "as_user t m \<lbrace>P\<rbrace>"
  apply (wpsimp simp: as_user_def wp: set_object_wp)
  by (clarsimp simp: get_tcb_ko_at obj_at_def assms cong: abstract_state.fold_congs)

lemma as_user_sk_obj_at_pred:
  assumes "\<And>tcb obj. TCB tcb \<noteq> C obj"
  shows "as_user t m \<lbrace>\<lambda>s. N (sk_obj_at_pred C proj P p s)\<rbrace>"
  by (clarsimp intro!: as_user_tcb_arch_inv simp: sk_obj_at_pred_def2 assms)

lemmas as_user_sk_obj_at_preds[wp] =
  as_user_sk_obj_at_pred[where C=Endpoint, simplified]
  as_user_sk_obj_at_pred[where C=Notification, simplified]
  as_user_sk_obj_at_pred[where C=Reply, simplified]

lemma as_user_valid_sched_pred[wp]:
  "as_user t m \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: as_user_tcb_arch_inv simp: fun_upd_def vs_all_heap_simps)

\<comment> \<open>complete_yield_to\<close>

lemma sched_context_update_consumed_valid_sched_pred[wp]:
  "sched_context_update_consumed scp \<lbrace>valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp simp: sched_context_update_consumed_def wp: update_sched_context_wp)
  by (clarsimp simp: fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps)

crunches complete_yield_to
  for valid_sched_pred[wp]: "valid_sched_pred_strong P"
  (wp: crunch_wps ignore: update_sched_context)

(* FIXME RT: move to DetSchedInvs_AI *)
\<comment> \<open>This version composes with valid_sched_pred rules\<close>
lemma gts_wp':
  "\<lbrace>\<lambda>s. \<forall>st. pred_map_eq st (tcb_sts_of s) t \<longrightarrow> P st s\<rbrace> get_thread_state t \<lbrace>P\<rbrace>"
  by (wpsimp wp: gts_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma handle_arch_fault_reply_cur'[wp]:
  "handle_arch_fault_reply f t x y \<lbrace>cur_tcb :: 'z::state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cur_tcb_def by (rule hoare_lift_Pf[where f=cur_thread]; wpsimp wp: tcb_at_typ_at')

(* FIXME rt: Move to DetSchedInvs_AI? *)
definition
  ct_ready_if_schedulable_2
where
  "ct_ready_if_schedulable_2 ctime curtcb tcbsts tcbscps sc_cfgs rlq \<equiv>
     active_sc_tcb_at_pred tcbscps sc_cfgs curtcb
       \<and> pred_map runnable tcbsts curtcb
       \<and> not_in_release_q_2 rlq curtcb
     \<longrightarrow> budget_ready_pred ctime tcbscps sc_cfgs curtcb"

abbreviation ct_ready_if_schedulable where
  "ct_ready_if_schedulable s \<equiv>
     ct_ready_if_schedulable_2 (cur_time s) (cur_thread s) (tcb_sts_of s)
                               (tcb_scps_of s) (sc_refill_cfgs_of s) (release_queue s)"

lemmas ct_ready_if_schedulable_def = ct_ready_if_schedulable_2_def

definition cur_sc_in_release_q_imp_zero_consumed_2 where
  "cur_sc_in_release_q_imp_zero_consumed_2 csc rlq cons_time tcb_scps \<equiv>
    \<forall>t. pred_map_eq (Some csc) tcb_scps t \<longrightarrow> in_queue_2 rlq t \<longrightarrow> cons_time = 0"

abbreviation cur_sc_in_release_q_imp_zero_consumed where
  "cur_sc_in_release_q_imp_zero_consumed s \<equiv>
   cur_sc_in_release_q_imp_zero_consumed_2 (cur_sc s) (release_queue s) (consumed_time s) (tcb_scps_of s)"

lemmas cur_sc_in_release_q_imp_zero_consumed_def = cur_sc_in_release_q_imp_zero_consumed_2_def

lemma cur_sc_in_release_q_imp_zero_consumed_trivial[simp]:
  "cur_sc_in_release_q_imp_zero_consumed_2 csc rlq 0 tcb_scps = True"
  by (simp add: cur_sc_in_release_q_imp_zero_consumed_def)

definition cur_sc_more_than_ready_2 where
  "cur_sc_more_than_ready_2 cons_time c_time rf_cfgs csc \<equiv>
     cons_time \<noteq> 0
     \<longrightarrow> pred_map active_scrc rf_cfgs csc
     \<longrightarrow> csc \<noteq> idle_sc_ptr
     \<longrightarrow> pred_map (refill_ready_no_overflow_sc cons_time c_time) rf_cfgs csc
          \<and> pred_map (refill_sufficient_sc cons_time) rf_cfgs csc"

abbreviation cur_sc_more_than_ready where
  "cur_sc_more_than_ready s \<equiv> cur_sc_more_than_ready_2
     (consumed_time s) (cur_time s) (sc_refill_cfgs_of s) (cur_sc s)"

lemmas cur_sc_more_than_ready_def = cur_sc_more_than_ready_2_def

lemma cur_sc_more_than_ready_trivial[simp]:
  "cur_sc_more_than_ready_2 0 c_time rfcfg csc = True"
  by (simp add: cur_sc_more_than_ready_2_def)

locale DetSchedSchedule_AI =
  fixes state_ext_t :: "'state_ext::state_ext itself"
  assumes kernel_irq_timer_is_kernel_IRQ[simp]:
    "timerIRQ \<notin> non_kernel_IRQs"
  assumes arch_switch_to_thread_valid_sched_pred[wp]:
    "\<And>t P. arch_switch_to_thread t \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_switch_to_idle_thread_valid_sched_pred[wp]:
    "\<And>P. arch_switch_to_idle_thread \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_switch_to_idle_thread_valid_idle[wp]:
    "arch_switch_to_idle_thread \<lbrace>valid_idle::'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_finalise_cap_valid_sched_pred[wp]:
    "\<And>cap final P. arch_finalise_cap cap final \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes make_arch_fault_msg_valid_sched_pred[wp]:
    "\<And>flt t P. make_arch_fault_msg flt t \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_invoke_irq_control_valid_sched_pred[wp]:
    "\<And>airq P. arch_invoke_irq_control airq \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_post_modify_registers_valid_sched_pred[wp]:
    "\<And>c t P. arch_post_modify_registers c t \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_arch_fault_reply_valid_sched_pred[wp]:
    "\<And>f t x y P. handle_arch_fault_reply f t x y \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_activate_idle_thread_valid_sched_pred[wp]:
    "\<And>t P. arch_activate_idle_thread t \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  \<comment> \<open>Due to delete_objects in perform_asid_control_invocation,
      arch_perform_invocation doesn't preserve valid_sched_pred\<close>
  assumes arch_perform_invocation_valid_sched[wp]:
    "\<And>i. \<lbrace>invs and valid_sched and valid_machine_time and ct_active and valid_arch_inv i and
            (\<lambda>s. scheduler_action s = resume_cur_thread)\<rbrace>
          arch_perform_invocation i
          \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_perform_invocation_cur_sc_tcb_only_sym_bound[wp]:
    "\<And>i. arch_perform_invocation i \<lbrace>cur_sc_tcb_only_sym_bound :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_perform_invocation_cur_sc_more_than_ready[wp]:
    "\<And>i. arch_perform_invocation i \<lbrace>cur_sc_more_than_ready :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_perform_invocation_cur_sc_in_release_q_imp_zero_consumed[wp]:
    "\<And>i. arch_perform_invocation i \<lbrace>cur_sc_in_release_q_imp_zero_consumed :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_perform_invocation_cur_sc_chargeableE_E[wp]:
    "\<And>i. \<lbrace>cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace> arch_perform_invocation i -, \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  assumes arch_perform_invocation_ct_not_blockedE_E[wp]:
    "\<And>i. \<lbrace>ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace> arch_perform_invocation i -, \<lbrace>\<lambda>_. ct_not_blocked\<rbrace>"
  assumes arch_perform_invocation_cur_sc_offset_readyE_E[wp]:
    "\<And>i. \<lbrace>\<lambda>s::'state_ext state. cur_sc_active s\<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>
          arch_perform_invocation i
          -, \<lbrace>\<lambda>rv s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  assumes arch_perform_invocation_valid_sched_misc[wp]:
    "\<And>i P. arch_perform_invocation i
            \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_time s) (cur_domain s) (cur_thread s)
                                     (cur_sc s) (idle_thread s)
                                     (ready_queues s) (release_queue s) (scheduler_action s)
                                     (last_machine_time_of s) (time_state_of s)\<rbrace>"
  assumes arch_perform_invocation_bound_sc_obj_tcb_at[wp]:
    "\<And>i. \<lbrace>\<lambda>s. bound_sc_obj_tcb_at (P (cur_time s)) t s
               \<and> ex_nonz_cap_to t s \<and> invs s \<and> ct_active s \<and> valid_arch_inv i s
               \<and> scheduler_action s = resume_cur_thread\<rbrace>
          arch_perform_invocation i
          \<lbrace>\<lambda>_ s. bound_sc_obj_tcb_at (P (cur_time s)) t (s :: 'state_ext state)\<rbrace>"
  assumes arch_perform_invocation_cur_sc_active[wp]:
    "\<And>i. \<lbrace>cur_sc_active and invs and ct_active and schact_is_rct and valid_arch_inv i\<rbrace>
          arch_perform_invocation i
          \<lbrace>\<lambda>_. cur_sc_active :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_vm_fault_valid_sched_pred[wp]:
    "\<And>t f P. handle_vm_fault t f \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes prepare_thread_delete_valid_sched_pred[wp]:
    "\<And>t P. prepare_thread_delete t \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_post_cap_deletion_valid_sched_pred[wp] :
    "\<And>c P. arch_post_cap_deletion c \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_invoke_irq_handler_valid_sched_pred[wp] :
    "\<And>c P. arch_invoke_irq_handler c \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_mask_irq_signal_valid_sched_pred[wp] :
    "\<And>c P. arch_mask_irq_signal c \<lbrace>valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes prepare_thread_delete_ct_in_state[wp]:
    "\<And>t P. prepare_thread_delete t \<lbrace>ct_in_state P ::det_state \<Rightarrow> _\<rbrace>"
  assumes arch_invoke_irq_handler_ct_active[wp]:
    "\<And>i. arch_invoke_irq_handler i \<lbrace>ct_active::'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_reserved_irq_ct_active[wp]:
    "\<And>i P. handle_reserved_irq i \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_mask_irq_signal_ct_in_state[wp]:
    "\<And>i P. arch_mask_irq_signal i \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes prepare_thread_delete_current_time_bounded[wp]:
    "\<And>t. prepare_thread_delete t \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_post_cap_deletion_current_time_bounded[wp] :
    "\<And>c. arch_post_cap_deletion c \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes arch_finalise_cap_current_time_bounded[wp]:
    "\<And>cap final. arch_finalise_cap cap final \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes prepare_thread_delete_tcb_scps_of[wp]:
    "\<And>t P. prepare_thread_delete t \<lbrace>\<lambda>s :: 'state_ext state. P (tcb_scps_of s)\<rbrace>"
  assumes arch_post_cap_deletion_tcb_scps_of[wp] :
    "\<And>c P. arch_post_cap_deletion c \<lbrace>\<lambda>s :: 'state_ext state. P (tcb_scps_of s)\<rbrace>"
  assumes arch_finalise_cap_tcb_scps_of[wp]:
    "\<And>cap final P. arch_finalise_cap cap final \<lbrace>\<lambda>s :: 'state_ext state. P (tcb_scps_of s)\<rbrace>"
  assumes handle_hypervisor_fault_ct_in_state[wp]:
     "\<And>t fault P. handle_hypervisor_fault t fault \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
   assumes handle_hypervisor_fault_scheduler_action[wp]:
     "\<And>t fault P. handle_hypervisor_fault t fault \<lbrace>\<lambda>s :: 'state_ext state. P (scheduler_action s)\<rbrace>"

locale DetSchedSchedule_AI_det_ext = DetSchedSchedule_AI "TYPE(det_ext)" +
  assumes arch_activate_idle_thread_valid_list'[wp]:
    "\<And>t P. arch_activate_idle_thread t \<lbrace>\<lambda>s. P (cdt s) (cdt_list s)\<rbrace>"
  assumes arch_switch_to_thread_valid_list'[wp]:
    "\<And>t P. arch_switch_to_thread t \<lbrace>\<lambda>s. P (cdt s) (cdt_list s)\<rbrace>"
  assumes arch_switch_to_idle_thread_valid_list'[wp]:
    "\<And>P. arch_switch_to_idle_thread \<lbrace>\<lambda>s. P (cdt s) (cdt_list s)\<rbrace>"
  assumes arch_switch_to_thread_exst[wp]:
    "\<And>P t. arch_switch_to_thread t \<lbrace>\<lambda>s::det_state. P (exst s)\<rbrace>"

context DetSchedSchedule_AI begin

sublocale arch_switch_to_thread: valid_sched_pred_locale state_ext_t "arch_switch_to_thread t" by unfold_locales wp
sublocale arch_switch_to_idle_thread: valid_sched_pred_locale state_ext_t arch_switch_to_idle_thread by unfold_locales wp
sublocale arch_finalise_cap: valid_sched_pred_locale state_ext_t "arch_finalise_cap cap final" by unfold_locales wp
sublocale make_arch_fault_msg: valid_sched_pred_locale state_ext_t "make_arch_fault_msg flt t" by unfold_locales wp
sublocale arch_invoke_irq_control: valid_sched_pred_locale state_ext_t "arch_invoke_irq_control airq" by unfold_locales wp
sublocale arch_post_modify_registers: valid_sched_pred_locale state_ext_t "arch_post_modify_registers c t" by unfold_locales wp
sublocale handle_arch_fault_reply: valid_sched_pred_locale state_ext_t "handle_arch_fault_reply f t x y" by unfold_locales wp
sublocale arch_activate_idle_thread: valid_sched_pred_locale state_ext_t "arch_activate_idle_thread t" by unfold_locales wp
sublocale handle_vm_fault: valid_sched_pred_locale state_ext_t "handle_vm_fault t f" by unfold_locales wp
sublocale prepare_thread_delete: valid_sched_pred_locale state_ext_t "prepare_thread_delete t" by unfold_locales wp
sublocale arch_get_sanitise_register_info: valid_sched_pred_locale state_ext_t "arch_get_sanitise_register_info ft" by unfold_locales wp
sublocale arch_post_cap_deletion: valid_sched_pred_locale state_ext_t "arch_post_cap_deletion c" by unfold_locales wp

context begin
interpretation Arch .

(* we assume this crunch works for all architectures *)
crunches arch_invoke_irq_handler, handle_reserved_irq, arch_mask_irq_signal
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  and cur_time[wp]: "\<lambda>s. P (cur_time s)"
  and consumed_time[wp]: "\<lambda>s. P (consumed_time s)"
  and consumed_time_bounded[wp]: "consumed_time_bounded"
  and release_queue[wp]: "\<lambda>s. P (release_queue s)"
  and valid_release_q[wp]: "\<lambda>s. valid_release_q s"
  and cur_thread[wp]: "\<lambda>s::det_state. P (cur_thread s)"
  (wp: crunch_wps)

crunches arch_mask_irq_signal
  for cur_sc_in_release_q_imp_zero_consumed[wp]: "cur_sc_in_release_q_imp_zero_consumed"

crunches handle_reserved_irq
  for valid_sched_pred_strong[wp]: "valid_sched_pred_strong P"

end

lemma switch_to_idle_thread_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (idle_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s)
          (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   switch_to_idle_thread
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: switch_to_idle_thread_def)

lemmas switch_to_idle_thread_valid_sched_misc[wp] =
  switch_to_idle_thread_valid_sched_pred[where P="\<lambda>cont csc sc_tcbs lmt ts sc_replies ctime cdom ct. P cont csc sc_tcbs lmt ts sc_replies ctime cdom" for P]

lemma switch_to_idle_thread_ct_not_in_q[wp]:
  "\<lbrace>valid_ready_qs and valid_idle\<rbrace> switch_to_idle_thread \<lbrace>\<lambda>_. ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (fastforce simp: valid_ready_qs_def ct_not_in_q_def not_queued_def valid_idle_def
                      pred_tcb_at_def obj_at_def vs_all_heap_simps)

lemma switch_to_idle_thread_valid_sched_action[wp]:
  "\<lbrace>valid_sched_action and valid_idle\<rbrace> switch_to_idle_thread \<lbrace>\<lambda>_. valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (auto simp: valid_sched_action_def valid_idle_def pred_tcb_at_def obj_at_def
                 is_activatable_def vs_all_heap_simps)

lemma switch_to_idle_thread_ct_in_cur_domain[wp]:
  "\<lbrace>\<top>\<rbrace> switch_to_idle_thread \<lbrace>\<lambda>_. ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (auto simp: ct_in_cur_domain_def)

lemma switch_to_idle_thread_ct_not_queued[wp]:
  "\<lbrace>valid_ready_qs and valid_idle\<rbrace>
   switch_to_idle_thread
   \<lbrace>\<lambda>rv s::'state_ext state. not_queued (cur_thread s) s\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (fastforce simp add: valid_ready_qs_def valid_idle_def in_ready_q_def
                          pred_tcb_at_def obj_at_def vs_all_heap_simps)

lemma switch_to_idle_thread_valid_blocked[wp]:
  "\<lbrace>valid_blocked and ct_in_q\<rbrace> switch_to_idle_thread \<lbrace>\<lambda>rv. valid_blocked::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (auto simp: valid_blocked_defs ct_in_q_def vs_all_heap_simps)

lemma stit_activatable':
  "\<lbrace>valid_idle\<rbrace> switch_to_idle_thread \<lbrace>\<lambda>rv. ct_in_state activatable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: switch_to_idle_thread_def ct_in_state_def obj_at_kh_kheap_simps)
  by (auto simp: valid_idle_def pred_tcb_at_def obj_at_def vs_all_heap_simps)

lemma activate_thread_valid_sched_pred_misc[wp]:
  "activate_thread
   \<lbrace>\<lambda>s::'state_ext state. P (cur_time s) (cur_domain s) (ep_send_qs_of s) (ep_recv_qs_of s)
                            (sc_tcbs_of s) (sc_replies_of s) (cur_thread s) (idle_thread s)
                            (ready_queues s) (release_queue s)
                            (etcbs_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp gts_wp' simp: activate_thread_def)

lemma activate_thread_valid_ready_qs[wp]:
  "activate_thread \<lbrace>valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')
  by (clarsimp simp: valid_ready_qs_def vs_all_heap_simps)

lemma activate_thread_valid_release_q[wp]:
  "activate_thread \<lbrace>valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')
  by (clarsimp simp: valid_release_q_def vs_all_heap_simps)

lemma activate_thread_ct_not_in_q[wp]:
  "activate_thread \<lbrace>ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')

lemma activate_thread_valid_sched_action[wp]:
  "activate_thread \<lbrace>valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')
  by (auto simp: valid_sched_action_def is_activatable_def weak_valid_sched_action_def vs_all_heap_simps)

lemma activate_thread_ct_in_cur_domain[wp]:
  "activate_thread \<lbrace>ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')

lemma activate_thread_valid_blocked[wp]:
  "activate_thread \<lbrace>valid_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')
  by (auto simp: valid_blocked_defs vs_all_heap_simps)

lemma activate_thread_released_ipc_queues[wp]:
  "activate_thread \<lbrace>released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: activate_thread_def wp: valid_sched_wp gts_wp')
  by (clarsimp simp: vs_all_heap_simps elim!: released_ipc_queuesE)

lemma activate_thread_valid_sched[wp]:
  "activate_thread \<lbrace>valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: valid_sched_def)

\<comment> \<open>We can't write a wp-style rule, because we don't know how some arch functions update arch state.\<close>
lemma switch_to_thread_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>d p. etcb_eq p d t s
               \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
                     (cur_time s) (cur_domain s) t (idle_thread s)
                     (tcb_sched_ready_q_update d p (tcb_sched_dequeue t) (ready_queues s))
                     (release_queue s) (scheduler_action s)
                     (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                     (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   switch_to_thread t
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: switch_to_thread_def
               wp: get_tcb_obj_ref_wp valid_sched_wp)

lemma guarded_switch_to_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>d p. etcb_eq p d t s
               \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
                     (cur_time s) (cur_domain s) t (idle_thread s)
                     (tcb_sched_ready_q_update d p (tcb_sched_dequeue t) (ready_queues s))
                     (release_queue s) (scheduler_action s)
                     (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                     (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   guarded_switch_to t
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: guarded_switch_to_def released_sc_tcb_at_def
               wp: valid_sched_wp thread_get_wp' is_schedulable_wp')

lemma switch_to_thread_valid_sched_misc[wp]:
  "switch_to_thread t
   \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                            (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_domain s)
                            (idle_thread s) (release_queue s) (scheduler_action s)
                            (etcbs_of s) (tcb_sts_of s)
                            (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma guarded_switch_to_valid_sched_misc[wp]:
  "guarded_switch_to t
   \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (ep_send_qs_of s ) (ep_recv_qs_of s)
                            (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_domain s)
                            (idle_thread s) (release_queue s) (scheduler_action s)
                            (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
                            (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

crunches switch_to_thread
  for valid_ready_qs[wp]: "valid_ready_qs::'state_ext state \<Rightarrow> _"
  (ignore: tcb_sched_action wp: hoare_drop_imp tcb_sched_dequeue_valid_ready_qs)

end

lemma tcb_sched_dequeue_valid_sched_action_2_ct_upd:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> is_activatable_2 thread (scheduler_action s) (tcb_sts_of s)\<rbrace>
   tcb_sched_action tcb_sched_dequeue thread
   \<lbrace>\<lambda>r s. valid_sched_action_2 True {} (cur_time s) (scheduler_action s) thread (cur_domain s)
                               (release_queue s) (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
                               (sc_refill_cfgs_of s)\<rbrace>"
  apply (simp add: tcb_sched_action_def unless_def set_tcb_queue_def)
  apply (wpsimp simp: thread_get_def)
  apply (clarsimp simp: etcb_at_def valid_sched_action_def split: option.split)
  done

lemma tcb_dequeue_not_queued:
  "\<lbrace>\<lambda>s. (t = tptr \<and> ready_qs_etcb_eq s) \<or> not_queued t s\<rbrace>
    tcb_sched_action tcb_sched_dequeue tptr
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
     (fastforce simp: valid_ready_qs_def vs_all_heap_simps valid_sched_wpsimps not_queued_def)

lemma tcb_release_remove_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. t = tptr \<or> not_in_release_q t s\<rbrace> tcb_release_remove tptr \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps not_in_release_q_def)

context DetSchedSchedule_AI begin

lemma switch_to_thread_ct_not_queued[wp]:
  "\<lbrace>valid_ready_qs\<rbrace> switch_to_thread t \<lbrace>\<lambda>rv. ct_not_queued::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce simp: valid_ready_qs_def vs_all_heap_simps valid_sched_wpsimps)

lemma switch_to_thread_ct_not_in_q[wp]:
  "\<lbrace>valid_ready_qs\<rbrace> switch_to_thread t \<lbrace>\<lambda>_. ct_not_in_q::'state_ext state \<Rightarrow> _\<rbrace>"
  by (simp add: hoare_post_imp[OF _ switch_to_thread_ct_not_queued])

lemma switch_to_thread_ct_not_in_release_q[wp]:
  "\<lbrace>not_in_release_q t\<rbrace> switch_to_thread t \<lbrace>\<lambda>rv s::'state_ext state. ct_not_in_release_q s\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: in_release_q_def)

end

lemma tcb_sched_action_dequeue_ct_in_cur_domain':
  "\<lbrace>\<lambda>s. ct_in_cur_domain_2 thread (idle_thread s) (scheduler_action s) (cur_domain s) (etcbs_of s)\<rbrace>
   tcb_sched_action tcb_sched_dequeue thread
   \<lbrace>\<lambda>_ s. ct_in_cur_domain (s\<lparr>cur_thread := thread\<rparr>)\<rbrace>"
  by (wpsimp wp: tcb_sched_action_wp)

context DetSchedSchedule_AI begin

lemma switch_to_thread_valid_sched_action[wp]:
  "\<lbrace>valid_sched_action and is_activatable t\<rbrace>
     switch_to_thread t
   \<lbrace>\<lambda>_. valid_sched_action::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: tcb_sched_dequeue_valid_sched_action_2_ct_upd hoare_drop_imp
          simp: switch_to_thread_def)

lemma switch_to_thread_ct_in_cur_domain[wp]:
  "\<lbrace>\<lambda>s. ct_in_cur_domain_2 thread (idle_thread s) (scheduler_action s) (cur_domain s) (etcbs_of s)\<rbrace>
  switch_to_thread thread \<lbrace>\<lambda>_. ct_in_cur_domain::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma switch_to_thread_valid_blocked[wp]:
  "\<lbrace>valid_blocked
    and (\<lambda>s. active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s
             \<longrightarrow> ct_in_q s)\<rbrace>
   switch_to_thread thread
   \<lbrace>\<lambda>_. valid_blocked::'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce simp: valid_sched_wpsimps in_ready_q_def ct_in_q_def runnable_eq_active
               elim!: valid_blockedE')

lemma switch_to_thread_ready_or_release[wp]:
  "switch_to_thread t \<lbrace>ready_or_release :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding switch_to_thread_def
  by (wpsimp simp: get_tcb_obj_ref_def wp: thread_get_wp)

lemma switch_to_thread_valid_sched:
  "\<lbrace>is_activatable t and in_cur_domain t and valid_sched_action and valid_ready_qs
    and valid_release_q and ready_or_release and valid_blocked and valid_idle_etcb
    and released_ipc_queues and active_reply_scs and active_sc_valid_refills
    and (\<lambda>s. (active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s)
             \<longrightarrow> ct_in_q s)\<rbrace>
    switch_to_thread t
   \<lbrace>\<lambda>_. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: valid_sched_def, simp add: ct_in_cur_domain_def)

crunch valid_idle[wp]: switch_to_idle_thread "valid_idle :: 'state_ext state \<Rightarrow> _"

end

lemma guarded_switch_to_lift:
  assumes "\<lbrace>P\<rbrace> switch_to_thread thread \<lbrace>Q\<rbrace>"
  shows "\<lbrace>P\<rbrace> guarded_switch_to thread \<lbrace>Q\<rbrace>"
  by (wpsimp simp: guarded_switch_to_def wp: assms thread_get_wp' is_schedulable_wp')

lemma next_domain_valid_idle[wp]:
  "\<lbrace> valid_idle \<rbrace> next_domain \<lbrace> \<lambda>_. valid_idle\<rbrace>"
  apply (wpsimp simp: next_domain_def wp: dxo_wp_weak)
  by (clarsimp simp: valid_idle_def Let_def)

(* FIXME move *)
lemma in_release_q_valid_blocked_ct_upd:
  "\<lbrakk>in_release_q (cur_thread s) s; valid_blocked s\<rbrakk> \<Longrightarrow> valid_blocked (s\<lparr>cur_thread := thread\<rparr>)"
  by (clarsimp elim!: valid_blockedE')

context DetSchedSchedule_AI begin

lemma switch_to_idle_thread_valid_sched:
  "\<lbrace>valid_sched_action and valid_idle and valid_ready_qs and valid_release_q
      and valid_blocked and ct_in_q and valid_idle_etcb and released_ipc_queues and ready_or_release
      and active_reply_scs and active_sc_valid_refills\<rbrace>
   switch_to_idle_thread
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: valid_sched_def)

crunch etcb_at[wp]: choose_thread "etcb_at P t :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma choose_thread_valid_sched[wp]:
  "\<lbrace>valid_sched_action and valid_idle and valid_ready_qs and valid_release_q and ready_or_release
    and valid_blocked and ct_in_q and valid_idle_etcb and released_ipc_queues and active_reply_scs
    and active_sc_valid_refills\<rbrace>
   choose_thread
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: choose_thread_def
                  wp: switch_to_idle_thread_valid_sched guarded_switch_to_lift
                      switch_to_thread_valid_sched)
  apply (clarsimp simp: valid_ready_qs_def next_thread_def is_activatable_2_def
                 dest!: next_thread_queued)
  by (fastforce simp: tcb_sts.pred_map_simps in_cur_domain_def etcb_at_def etcbs.pred_map_simps)

end

lemma do_extended_op_valid_sched_pred[wp]:
  "do_extended_op eop \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: do_extended_op_def)

\<comment> \<open>We leave the resulting cur_domain unspecified, since we can't specify it in terms of state
    projections that are part of valid_sched_pred\<close>
lemma next_domain_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>cdom'. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
                  (cur_time s) cdom' (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
                  (scheduler_action s)
                  (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                  (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   next_domain
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: next_domain_def Let_def)

crunches next_domain
  for valid_sched_misc[wp]: "\<lambda>s. P (consumed_time s) (cur_sc s)
                                   (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_thread s)
                                   (idle_thread s) (ready_queues s) (release_queue s)
                                   (scheduler_action s) (kheap s)"
  (simp: Let_def wp: dxo_wp_weak)

lemma next_domain_valid_sched_action:
  "\<lbrace>\<lambda>s. scheduler_action s = choose_new_thread\<rbrace> next_domain \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

context DetSchedSchedule_AI begin
lemma switch_to_thread_cur_in_cur_domain[wp]:
  "\<lbrace>in_cur_domain t\<rbrace> switch_to_thread t \<lbrace>\<lambda>_ s::'state_ext state. in_cur_domain (cur_thread s) s\<rbrace>"
  by (wpsimp wp: valid_sched_wp)
end

lemma tcb_sched_enqueue_cur_ct_in_q:
  "\<lbrace>\<lambda>s. cur = cur_thread s\<rbrace> tcb_sched_action tcb_sched_enqueue cur \<lbrace>\<lambda>_. ct_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps in_queues_2_def ct_in_q_def)

lemma tcb_sched_enqueue_ct_in_q:
  "\<lbrace> ct_in_q \<rbrace> tcb_sched_action tcb_sched_enqueue cur \<lbrace>\<lambda>_. ct_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: ct_in_q_def valid_sched_wpsimps)

lemma tcb_sched_append_ct_in_q:
  "\<lbrace> ct_in_q \<rbrace> tcb_sched_action tcb_sched_append cur \<lbrace>\<lambda>_. ct_in_q\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: ct_in_q_def valid_sched_wpsimps)

context DetSchedSchedule_AI begin

lemma switch_to_idle_thread_ct_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s::'state_ext state. valid_release_q s \<and> valid_idle s\<rbrace>
   switch_to_idle_thread
   \<lbrace>\<lambda>rv. ct_not_in_release_q\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_idle_def valid_release_q_def pred_tcb_at_def obj_at_def in_release_q_def
                 vs_all_heap_simps)

lemma switch_to_thread_sched_act_is_cur:
  "\<lbrace>\<lambda>s::'state_ext state. scheduler_action s = switch_thread word\<rbrace>
   switch_to_thread word
   \<lbrace>\<lambda>rv s. scheduler_action s = switch_thread (cur_thread s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

end

lemma set_scheduler_action_switch_ct_not_in_q[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action (switch_thread t) \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  apply (simp add: set_scheduler_action_def, wp)
  apply (simp add: ct_not_in_q_def)
  done

lemma possible_switch_to_valid_sched_misc[wp]:
  "possible_switch_to t \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                               (idle_thread s) (release_queue s) (kheap s)\<rbrace>"
  by (wpsimp simp: possible_switch_to_def wp: valid_sched_wp get_tcb_obj_ref_wp thread_get_wp')

abbreviation (input) possible_switch_to_wp where
  "possible_switch_to_wp t P s \<equiv>
    \<forall>d p. etcb_eq p d t s
          \<longrightarrow> (if pred_map_eq None (tcb_scps_of s) t \<or> t \<in> set (release_queue s)
               then P s
               else let enq_t = ready_queues_update (tcb_sched_ready_q_update d p (tcb_sched_enqueue t)) in
                    if d \<noteq> cur_domain s
                    then P (enq_t s)
                    else if scheduler_action s = resume_cur_thread
                         then P (s\<lparr>scheduler_action := switch_thread t\<rparr>)
                         else reschedule_required_wp (\<lambda>s. P (enq_t s)) s)"

lemma possible_switch_to_wp:
  "\<lbrace>possible_switch_to_wp t P\<rbrace> possible_switch_to t \<lbrace>\<lambda>rv. P\<rbrace>"
  supply if_split[split del] if_cong[cong del]
  apply (wpsimp simp: possible_switch_to_def wp: valid_sched_wp get_tcb_obj_ref_wp thread_get_wp')
  apply (simp add: obj_at_def etcbs.pred_map_simps Let_def if_distribR)
  apply (simp add: tcb_scps.pred_map_simps in_queue_2_def)
  by (case_tac "tcb_sched_context tcb = None \<or> t \<in> set (release_queue s)", fastforce, clarsimp)

lemma possible_switch_to_ct_not_in_q:
  "\<lbrace>ct_not_in_q and (\<lambda>s. t \<noteq> cur_thread s)\<rbrace> possible_switch_to t \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: possible_switch_to_wp simp: ct_not_in_q_def not_queued_def tcb_sched_enqueue_def)

lemma possible_switch_to_not_it_ct_not_in_q:
  "\<lbrace>\<lambda>s. ct_not_in_q s \<and> ct_in_cur_domain s \<and> t \<noteq> idle_thread s\<rbrace>
   possible_switch_to t
   \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: possible_switch_to_wp
           simp: ct_not_in_q_def in_queues_2_def tcb_sched_enqueue_def ct_in_cur_domain_def
                 vs_all_heap_simps in_cur_domain_def etcb_at_def)

crunch ct_not_in_q[wp]: test_reschedule ct_not_in_q
  (wp: crunch_wps hoare_drop_imps hoare_vcg_if_lift2)

lemma sched_context_donate_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q\<rbrace> sched_context_donate scp tp \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp simp: sched_context_donate_def wp: get_sc_obj_ref_wp tcb_sched_dequeue_ct_not_in_q)

lemma sched_context_unbind_tcb_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q\<rbrace> sched_context_unbind_tcb scp \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  by (wpsimp wp: get_sched_context_wp valid_sched_wp
           simp: sched_context_unbind_tcb_def valid_sched_wpsimps in_queues_2_def)

crunch ct_not_in_q[wp]: reply_unlink_sc ct_not_in_q
  (wp: crunch_wps hoare_drop_imps)

crunch ct_not_in_q[wp]: reply_unlink_tcb ct_not_in_q
  (wp: crunch_wps hoare_drop_imps)

lemma reply_remove_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q\<rbrace> reply_remove t r \<lbrace>\<lambda>_. ct_not_in_q\<rbrace>"
  apply (simp add: reply_remove_def)
  apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
  done

definition choose_thread_spec_2 where
  "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_rcs ct' qs' \<equiv>
    if \<forall>prio. qs cdom prio = []
    then ct' = it \<and> qs' = qs
    else let t = hd (max_non_empty_queue (qs cdom)) in
         \<exists>d' p'. etcb_eq' p' d' etcbs t
                 \<and> ct' = t
                 \<and> qs' = tcb_sched_ready_q_update d' p' (tcb_sched_dequeue t) qs"

lemma set_refills_budget_ready_wp:
  "\<lbrace>(\<lambda>s. if bound_sc_tcb_at ((=) (Some sc_ptr)) t s
         then refill_ready (cur_time s) (hd refills)
         else budget_ready t s)\<rbrace>
   set_refills sc_ptr refills
   \<lbrace>\<lambda>_. budget_ready t\<rbrace>"
  unfolding set_refills_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps
                 split: if_splits
                  cong: conj_cong)
  by fastforce


abbreviation choose_thread_spec where
  "choose_thread_spec s \<equiv> choose_thread_spec_2 (cur_domain s) (cur_time s) (idle_thread s)
                                               (ready_queues s) (release_queue s)
                                               (etcbs_of s) (tcb_scps_of s) (sc_refill_cfgs_of s)"

lemmas choose_thread_spec_def = choose_thread_spec_2_def

context DetSchedSchedule_AI begin

lemma choose_thread_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>ct' qs'. choose_thread_spec s ct' qs'
                  \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                        (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s) (cur_time s) (cur_domain s) ct' (idle_thread s) qs'
                        (release_queue s) (scheduler_action s)
                        (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                        (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   choose_thread
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: choose_thread_def wp: valid_sched_wp)
  by (auto simp: choose_thread_spec_def Let_def
          split: option.splits list.splits if_splits)

lemma choose_thread_valid_sched_misc[wp]:
  "choose_thread
   \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                            (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_domain s)
                            (idle_thread s) (release_queue s) (scheduler_action s)
                            (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
                            (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma choose_thread_ct_not_queued:
  "\<lbrace> valid_ready_qs and valid_idle \<rbrace> choose_thread \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: choose_thread_def wp: guarded_switch_to_lift)

lemma max_non_empty_queue_non_empty:
  "ready_queues s domd prio \<noteq> [] \<Longrightarrow> max_non_empty_queue (ready_queues s domd) \<noteq> []"
   unfolding max_non_empty_queue_def
   apply (rule Max_prop)
  apply clarsimp
  by fastforce

lemma hd_max_non_empty_queue_in_ready_queues:
  "ready_queues s domd prio \<noteq> [] \<Longrightarrow>
   (\<exists>prio. (hd (max_non_empty_queue (ready_queues s domd))) \<in> set (ready_queues s domd prio))"
   apply (drule max_non_empty_queue_non_empty)
   apply (frule hd_in_set)
   unfolding max_non_empty_queue_def
   by fastforce

lemma choose_thread_ct_not_in_release_q:
  "\<lbrace>valid_release_q and valid_idle and ready_or_release\<rbrace>
   choose_thread
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: choose_thread_def wp: switch_to_thread_ct_not_in_release_q guarded_switch_to_lift)
  apply (frule hd_max_non_empty_queue_in_ready_queues)
  apply (fastforce simp: ready_or_release_def in_release_q_def in_ready_q_def)
  done

lemma choose_thread_spec_idle_or_was_queued_in_cur_domain:
  "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_rcs ct' qs'
   \<Longrightarrow> ct' = it \<or> (\<exists>p. ct' \<in> set (qs cdom p))"
  by (auto simp: choose_thread_spec_2_def Let_def next_thread_def
          split: if_splits
          dest!: next_thread_queued)

lemma choose_thread_cur_dom_or_idle:
  "\<lbrace> valid_ready_qs \<rbrace>
   choose_thread
   \<lbrace>\<lambda>_ s::'state_ext state. (in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s) \<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce dest!: choose_thread_spec_idle_or_was_queued_in_cur_domain
                 simp: in_cur_domain_def etcb_at_def vs_all_heap_simps valid_ready_qs_def)

lemma choose_thread_ct_activatable:
  "\<lbrace> valid_ready_qs and valid_idle \<rbrace>
   choose_thread
   \<lbrace>\<lambda>_ s::'state_ext state. pred_map activatable (tcb_sts_of s) (cur_thread s)\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (fastforce dest!: choose_thread_spec_idle_or_was_queued_in_cur_domain
                 simp: valid_idle_def pred_tcb_at_def obj_at_def valid_ready_qs_def vs_all_heap_simps)

lemmas choose_thread_ct_activatable' =
  choose_thread_ct_activatable[folded obj_at_kh_kheap_simps]

lemma schedule_choose_new_thread_valid_sched_misc[wp]:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (idle_thread s) (release_queue s) resume_cur_thread
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)
          (sc_replies_of s)\<rbrace>
   schedule_choose_new_thread
   \<lbrace>\<lambda>_ s::'state_ext state. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                              (sc_tcbs_of s) (cur_time s) (idle_thread s) (release_queue s)
                              (scheduler_action s) (etcbs_of s)
                              (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)
                              (sc_replies_of s)\<rbrace>"
  unfolding schedule_choose_new_thread_def
  by (wpsimp wp: set_scheduler_action_wp)

end

lemma valid_sched_action_from_choose_thread:
  "scheduler_action s = choose_new_thread \<Longrightarrow> valid_sched_action s"
  unfolding valid_sched_action_def by simp

lemma set_scheduler_action_cnt_simple[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. simple_sched_action \<rbrace>"
  by (wpsimp wp: set_scheduler_action_wp)

lemma set_scheduler_action_obvious[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action a \<lbrace>\<lambda>_ s. scheduler_action s = a\<rbrace>"
  by (wpsimp wp: set_scheduler_action_wp)

lemma set_scheduler_action_cnt_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> (\<forall>t. scheduler_action s = switch_thread t \<longrightarrow> in_ready_q t s)\<rbrace>
   set_scheduler_action choose_new_thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def
               wp: set_scheduler_action_cnt_ct_not_in_q
                   set_scheduler_action_cnt_valid_sched_action
                   set_scheduler_action_cnt_ct_in_cur_domain
                   set_scheduler_action_valid_blocked_const)

lemma append_thread_queued[wp]:
  "\<lbrace>\<top>\<rbrace> tcb_sched_action tcb_sched_append thread \<lbrace>\<lambda>_ s. thread \<in> ready_queued_threads s\<rbrace>"
  by (wpsimp wp: valid_sched_wp) (fastforce simp: tcb_sched_append_def vs_all_heap_simps)

(* having is_highest_prio match gets_wp makes it very hard to stop and drop imps etc. *)
definition
  "wrap_is_highest_prio cur_dom target_prio \<equiv> gets (is_highest_prio cur_dom target_prio)"

\<comment> \<open>As for next_domain, we leave the resulting cur_domain unspecified\<close>
abbreviation schedule_choose_new_thread_spec where
  "schedule_choose_new_thread_spec s cdom' \<equiv>
    choose_thread_spec_2 cdom' (cur_time s) (idle_thread s) (ready_queues s) (release_queue s)
                               (etcbs_of s) (tcb_scps_of s) (sc_refill_cfgs_of s)"

lemmas schedule_choose_new_thread_spec_def = choose_thread_spec_2_def

(* FIXME: move up *)
lemma choose_thread_spec_valid_ready_qs[valid_sched_wpsimps]:
  assumes "valid_ready_qs_2 qs ctime etcbs tcb_sts tcb_scps sc_refill_cfgs"
  assumes "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_refill_cfgs ct' qs'"
  shows "valid_ready_qs_2 qs' ctime etcbs tcb_sts tcb_scps sc_refill_cfgs"
  using assms by (auto simp: valid_ready_qs_def choose_thread_spec_def Let_def tcb_sched_dequeue_def
                      split: if_splits)

lemma choose_thread_spec_ct_not_queued[valid_sched_wpsimps]:
  assumes "valid_ready_qs_2 qs ctime etcbs tcb_sts tcb_scps sc_refill_cfgs"
  assumes "pred_map idle tcb_sts it"
  assumes "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_refill_cfgs ct' qs'"
  shows "not_queued_2 qs' ct'"
  using assms
  by (fastforce simp: valid_ready_qs_def in_queues_2_def choose_thread_spec_def Let_def
                      pred_map_simps runnable_eq tcb_sched_dequeue_def
               split: if_splits)

lemma valid_idle_idle_thread:
  "valid_idle s \<Longrightarrow> pred_map idle (tcb_sts_of s) (idle_thread s)"
  by (auto simp: valid_idle_def pred_tcb_at_def obj_at_def vs_all_heap_simps)

lemmas choose_thread_spec_ct_not_queued'[valid_sched_wpsimps] =
  choose_thread_spec_ct_not_queued[OF _ valid_idle_idle_thread]

lemma choose_thread_spec_ct_activatable[valid_sched_wpsimps]:
  assumes "valid_ready_qs_2 qs ctime etcbs tcb_sts tcb_scps sc_refill_cfgs"
  assumes "pred_map idle tcb_sts it"
  assumes "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_refill_cfgs ct' qs'"
  shows "pred_map activatable tcb_sts ct'"
  using assms
  by (fastforce simp: valid_ready_qs_def choose_thread_spec_def Let_def pred_map_simps
                      next_thread_def runnable_eq
               dest!: next_thread_queued
               split: if_splits)

lemmas choose_thread_spec_ct_activatable'[valid_sched_wpsimps] =
  choose_thread_spec_ct_activatable[OF _ valid_idle_idle_thread]

lemma choose_thread_spec_ct_in_cur_domain[valid_sched_wpsimps]:
  assumes "valid_ready_qs_2 qs ctime etcbs tcb_sts tcb_scps sc_refill_cfgs"
  assumes "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_refill_cfgs ct' qs'"
  shows "ct' = it \<or> in_cur_domain_2 ct' cdom etcbs"
  using assms
  by (fastforce simp: valid_ready_qs_def choose_thread_spec_def ct_in_cur_domain_def
                      in_cur_domain_def Let_def etcb_at'_def pred_map_simps
                      next_thread_def runnable_eq
               dest!: next_thread_queued
               split: if_splits)

lemma not_queued_dequeue_but_was_queued_eq:
  assumes "not_queued_2 (tcb_sched_ready_q_update d' p' (tcb_sched_dequeue t') qs) t"
  assumes "in_queues_2 qs t"
  shows "t = t'"
  using assms by (auto simp: in_queues_2_def tcb_sched_dequeue_def split: if_splits)

lemma choose_thread_spec_valid_blocked[valid_sched_wpsimps]:
  assumes "valid_blocked_2 qs rlq choose_new_thread ct tcb_sts tcb_scps sc_refill_cfgs"
  assumes "choose_thread_spec_2 cdom ctime it qs rlq etcbs tcb_scps sc_refill_cfgs ct' qs'"
  assumes "active_sc_tcb_at_pred tcb_scps sc_refill_cfgs ct \<and> not_in_release_q_2 rlq ct
           \<Longrightarrow> ct_in_q_2 ct qs tcb_sts"
  shows "valid_blocked_2 qs' rlq resume_cur_thread ct' tcb_sts tcb_scps sc_refill_cfgs"
  using assms
  by (fastforce simp: choose_thread_spec_def Let_def not_queued_dequeue_but_was_queued_eq
                      ct_in_q_def next_thread_def runnable_eq_active
               dest!: next_thread_queued elim!: valid_blockedE'
               split: if_splits)

lemma set_irq_state_valid_sched_pred[wp]:
  "set_irq_state irq_st irq \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: set_irq_state_def)

lemma deleted_irq_handler_valid_sched_pred[wp]:
  "deleted_irq_handler irq \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: deleted_irq_handler_def)

lemma cap_swap_valid_sched_pred[wp]:
  "cap_swap cap1 slot1 cap2 slot2 \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: cap_swap_def)

lemma cap_swap_for_delete_valid_sched_pred[wp]:
  "cap_swap_for_delete slot1 slot2 \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: cap_swap_for_delete_def)

context DetSchedSchedule_AI begin

lemma schedule_choose_new_thread_valid_sched_except_domain[valid_sched_wp]:
  "\<lbrace>\<lambda>s. \<forall>cdom' ct' qs'. schedule_choose_new_thread_spec s cdom' ct' qs'
                        \<longrightarrow> P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
                              (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s) (cur_time s) cdom' ct' (idle_thread s) qs'
                              (release_queue s) resume_cur_thread
                              (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
                              (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   schedule_choose_new_thread
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: schedule_choose_new_thread_def wp: valid_sched_wp)

lemma schedule_choose_new_thread_valid_ready_qs[wp]:
  "schedule_choose_new_thread \<lbrace>valid_ready_qs::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

crunches schedule_choose_new_thread
  for ready_or_release[wp]: "ready_or_release :: 'state_ext state \<Rightarrow> _"
  (wp: hoare_drop_imps)

lemma schedule_choose_new_thread_valid_sched:
  "\<lbrace> valid_idle and valid_idle_etcb and valid_ready_qs and valid_release_q
     and ready_or_release and valid_blocked
     and (\<lambda>s. scheduler_action s = choose_new_thread)
     and (\<lambda>s. active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s \<longrightarrow> ct_in_q s)
     and released_ipc_queues and active_reply_scs
     and active_sc_valid_refills\<rbrace>
   schedule_choose_new_thread
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: valid_sched_wpsimps wp: valid_sched_wp)
  apply (clarsimp simp: ready_or_release_2_def schedule_choose_new_thread_spec_def Let_def
                        in_queues_2_def in_release_q_def
                 split: if_splits
         ; blast?)
  apply (prop_tac "t \<in> set (ready_queues s d' p')")
   using tcb_sched_act_set_simps(3) apply blast
  by blast

lemma schedule_choose_new_thread_ct_not_queued:
  "\<lbrace>valid_ready_qs and valid_idle\<rbrace>
   schedule_choose_new_thread
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: schedule_choose_new_thread_def wp: choose_thread_ct_not_queued)

lemma schedule_choose_new_thread_ct_not_in_release_q:
  "\<lbrace>valid_release_q and valid_idle and ready_or_release\<rbrace>
   schedule_choose_new_thread
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: schedule_choose_new_thread_def wp: choose_thread_ct_not_in_release_q)

end

(* FIXME: Should tcb_release_enqueue be defined using takeWhile/dropWhile?
          As shown here, they're equivalent for sorted lists, so perhaps it doesn't matter. *)
definition insort_filter :: "('a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "insort_filter P x xs \<equiv> filter P xs @ x # filter (\<lambda>x. \<not> P x) xs"

definition insort_partition :: "('a \<Rightarrow> bool) \<Rightarrow> 'a \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "insort_partition P x xs \<equiv> takeWhile P xs @ x # dropWhile P xs"

lemma sorted_filter_takeWhile:
  assumes tr: "transp cmp"
  shows "sorted_wrt cmp xs \<Longrightarrow> filter (\<lambda>x. cmp x y) xs = takeWhile (\<lambda>x. cmp x y) xs"
proof (induct xs)
  case (Cons x xs)
  have xs: "sorted_wrt cmp xs" and x: "\<forall>z\<in>set xs. cmp x z" using Cons.prems by auto
  note eq = Cons.hyps[OF xs, symmetric]
  show ?case
    apply (clarsimp simp: eq filter_empty_conv dest!: bspec[OF x])
    by (drule (1) transpD[OF tr], simp)
qed auto

lemma sorted_not_filter_dropWhile:
  assumes tr: "transp cmp"
  shows "sorted_wrt cmp xs \<Longrightarrow> filter (\<lambda>x. \<not> cmp x y) xs = dropWhile (\<lambda>x. cmp x y) xs"
proof (induct xs)
  case (Cons x xs)
  have xs: "sorted_wrt cmp xs" and x: "\<forall>z\<in>set xs. cmp x z" using Cons.prems by auto
  note eq = Cons.hyps[OF xs, symmetric]
  show ?case
    apply (clarsimp simp: eq filter_id_conv dest!: bspec[OF x])
    by (drule (1) transpD[OF tr], simp)
qed auto

lemma sorted_insort_filter_eq_insort_partition:
  assumes "transp cmp"
  assumes "sorted_wrt cmp xs"
  shows "insort_filter (\<lambda>x. cmp x y) x xs = insort_partition (\<lambda>x. cmp x y) x xs"
  by (auto simp: insort_filter_def insort_partition_def
                 sorted_filter_takeWhile[OF assms] sorted_not_filter_dropWhile[OF assms])

lemma total_reflD:
  "total {(x,y). cmp x y} \<Longrightarrow> reflp cmp \<Longrightarrow> \<not> cmp a b \<Longrightarrow> cmp b a"
  apply (case_tac "a=b")
   apply (fastforce dest: reflpD)
  by (fastforce simp: total_on_def)

lemma sorted_insort_partition:
  assumes tot: "total {(x,y). cmp x y}"
  assumes tr: "transp cmp"
  assumes re: "reflp cmp"
  assumes sorted: "sorted_wrt cmp xs"
  shows "sorted_wrt cmp (insort_partition (\<lambda>x. cmp x z) z xs)"
  unfolding insort_partition_def
  apply (clarsimp simp: sorted_wrt_append, intro conjI)
     apply (subst sorted_filter_takeWhile[symmetric, OF tr sorted])
     apply (rule sorted_wrt_filter, rule sorted)
    apply (clarsimp simp: sorted_not_filter_dropWhile[symmetric, OF tr sorted])
    apply (fastforce dest: total_reflD[OF tot re])
   apply (subst sorted_not_filter_dropWhile[symmetric, OF tr sorted])
   apply (rule sorted_wrt_filter, rule sorted)
  apply (clarsimp, intro conjI)
   apply (erule takeWhile_taken_P)
  apply (clarsimp simp: sorted_not_filter_dropWhile[symmetric, OF tr sorted])
  apply (drule takeWhile_taken_P)
  apply (rule transpD[OF tr], assumption)
  apply (fastforce dest: total_reflD[OF tot re])
  done

lemma sorted_insort_filter:
  assumes tot: "total {(x,y). cmp x y}"
  assumes tr: "transp cmp"
  assumes re: "reflp cmp"
  assumes sorted: "sorted_wrt cmp xs"
  shows "sorted_wrt cmp (insort_filter (\<lambda>x. cmp x z) z xs)"
  apply (subst sorted_insort_filter_eq_insort_partition[OF tr sorted])
  by (rule sorted_insort_partition[OF tot tr re sorted])

definition tcb_release_enqueue_upd :: "(obj_ref \<rightharpoonup> time) \<Rightarrow> obj_ref \<Rightarrow> obj_ref list \<Rightarrow> obj_ref list" where
  "tcb_release_enqueue_upd tcb_ready_times t \<equiv> insort_filter (\<lambda>t'. img_ord (the \<circ> tcb_ready_times) (\<le>) t' t) t"

lemma map_fst_filter_zip_map_reduce:
  "map fst (filter P (zip xs (map f xs))) = filter (\<lambda>x. P (x, f x)) xs"
  by (induct xs) auto

lemma tcb_release_enqueue_wp':
  "\<lbrace>\<lambda>s. tcb_sc_refill_cfgs_of s t \<noteq> None \<longrightarrow>
          (\<forall>rt. tcb_ready_times_of s t = Some rt \<longrightarrow>
            (if filter (\<lambda>(_, t'). t' \<le> rt) (zip (release_queue s) (map (the \<circ> tcb_ready_times_of s) (release_queue s))) = []
             then P (reprogram_timer_update \<top> (release_queue_update (tcb_release_enqueue_upd (tcb_ready_times_of s) t) s))
             else P (release_queue_update (tcb_release_enqueue_upd (tcb_ready_times_of s) t) s)))\<rbrace>
   tcb_release_enqueue t
   \<lbrace>\<lambda>rv. P\<rbrace>"
  apply (wpsimp simp: tcb_release_enqueue_def wp: mapM_get_sc_time_wp get_sc_time_wp)
  apply (drule mp, fastforce simp: sc_ready_times_2_def map_project_simps)
  apply (erule_tac x=rt in allE)
  apply (intro conjI; clarsimp dest!: map_Some_implies_map_the)
   apply (auto simp: map_is_Nil_conv[symmetric, where f=fst] tcb_release_enqueue_upd_def
                     insort_filter_def map_fst_filter_zip_map_reduce img_ord_def
              elim!: rsubst[of P])
  done

lemmas tcb_release_enqueue_wp[valid_sched_wp] = tcb_release_enqueue_wp'[THEN hoare_drop_assertion]

lemma tcb_release_enqueue_valid_sched_misc[wp]:
  "tcb_release_enqueue t \<lbrace>\<lambda>s. P (consumed_time s) (cur_time s) (cur_domain s) (cur_thread s) (cur_sc s)
                                (idle_thread s) (ready_queues s) (scheduler_action s)
                                (kheap s)\<rbrace>"
  by (wpsimp wp: tcb_release_enqueue_wp)

lemma tcb_dequeue_sc_not_in_ready_q[wp]:
  "tcb_sched_action tcb_sched_dequeue tptr' \<lbrace>sc_not_in_ready_q scp\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps vs_all_heap_simps in_queues_2_def)

lemma tcb_dequeue_sc_not_in_ready_q_cur[wp]:
  "tcb_sched_action tcb_sched_dequeue tptr' \<lbrace>\<lambda>s. sc_not_in_ready_q (cur_sc s) s\<rbrace>"
  by (rule hoare_lift_Pf[where f=cur_sc]; wp)

context DetSchedSchedule_AI begin

lemma switch_to_thread_sc_not_in_ready_q[wp]:
  "switch_to_thread t \<lbrace>\<lambda>s::'state_ext state. sc_not_in_ready_q scp s\<rbrace>"
  by (wpsimp simp: switch_to_thread_def get_tcb_obj_ref_def thread_get_def)

lemma switch_to_thread_sc_not_in_ready_q_cur[wp]:
  "switch_to_thread t \<lbrace>\<lambda>s::'state_ext state. sc_not_in_ready_q (cur_sc s) s\<rbrace>"
  by (rule hoare_lift_Pf[where f=cur_sc]; wp)

lemma choose_thread_sc_not_in_ready_q[wp]:
  "choose_thread \<lbrace>sc_not_in_ready_q scp :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: choose_thread_def wp: guarded_switch_to_lift)

lemma choose_thread_sc_not_in_ready_q_cur[wp]:
  "choose_thread \<lbrace>\<lambda>s::'state_ext state. sc_not_in_ready_q (cur_sc s) s\<rbrace>"
  by (wpsimp simp: choose_thread_def wp: choose_thread_sc_not_in_ready_q guarded_switch_to_lift)

crunch valid_sched[wp]: empty_slot "valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _"
  (simp: unless_def wp: maybeM_inv ignore: set_object)

end

(* valid_sched for refill_budget_check *)
lemma hd_last_length_2: "length ls = 2 \<Longrightarrow> [hd ls, last ls] = ls"
  apply (cases ls; clarsimp)
  by (case_tac list; clarsimp)

(* FIXME: move *)
lemma pred_map_heap_upd_no_change[simp]:
  assumes "\<And>v. P (f v) \<longleftrightarrow> P v"
  shows "pred_map P (heap_upd f ref heap) = pred_map P heap"
  by (rule ext, auto simp: pred_map_simps heap_upd_def assms)

(* FIXME: move *)
crunches refill_budget_check
  for ready_queues[wp]: "\<lambda>s. P (ready_queues s)"
  and release_queue[wp]: "\<lambda>s::det_state. P (release_queue s)"
  and cur_domain[wp]: "\<lambda>s::det_state. P (cur_domain s)"
  and idle_thread[wp]: "\<lambda>s. P (idle_thread s)"
  (simp: crunch_simps wp: crunch_wps)

lemma pred_map2_heap_upd_no_change[simp]:
  assumes "\<And>v. P (f v) \<longleftrightarrow> P v"
  shows "pred_map2 P heap' (heap_upd f ref heap) = pred_map2 P heap' heap"
  by (simp add: pred_map2_pred_maps pred_map_heap_upd_no_change[where P=P, OF assms])

crunches check_domain_time
  for obj_at[wp]: "\<lambda>s. N (obj_at P t s)"
  and kheap[wp]: "\<lambda>s. P (kheap s)"

lemma set_next_interrupt_valid_sched[wp]:
  "set_next_interrupt \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: set_next_interrupt_def wp: hoare_drop_imp)

context DetSchedSchedule_AI begin

crunch ct_not_in_q[wp]: finalise_cap "ct_not_in_q :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps maybeM_inv tcb_sched_dequeue_ct_not_in_q ignore: tcb_sched_action)

end

lemma set_scheduler_action_swt_weak_valid_sched:
  "\<lbrace>valid_sched and st_tcb_at runnable t and released_sc_tcb_at t and not_in_release_q t
      and in_cur_domain t and simple_sched_action\<rbrace>
     set_scheduler_action (switch_thread t)
   \<lbrace>\<lambda>_.valid_sched\<rbrace>"
  apply (wpsimp simp: valid_sched_def ct_not_in_q_def valid_sched_action_def valid_blocked_defs
                      weak_valid_sched_action_def switch_in_cur_domain_def simple_sched_action_def
                      obj_at_kh_kheap_simps set_scheduler_action_def in_queue_2_def
               split: scheduler_action.splits)
  by auto

lemma set_scheduler_action_swt_valid_sched:
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except t and st_tcb_at runnable t
      and released_sc_tcb_at t and not_in_release_q t
      and in_cur_domain t and simple_sched_action\<rbrace>
     set_scheduler_action (switch_thread t)
   \<lbrace>\<lambda>_.valid_sched\<rbrace>"
  apply (wpsimp simp: valid_sched_def ct_not_in_q_def valid_sched_action_def valid_blocked_defs
                      weak_valid_sched_action_def switch_in_cur_domain_def simple_sched_action_def
                      obj_at_kh_kheap_simps set_scheduler_action_def in_queue_2_def
               split: scheduler_action.splits)
  by auto

lemma set_scheduler_action_cnt_valid_blocked_except:
  "\<lbrace>\<lambda>s. valid_blocked_except target s
        \<and> (\<forall>t. scheduler_action s = switch_thread t \<longrightarrow> \<not> not_queued t s) \<rbrace>
   set_scheduler_action choose_new_thread
   \<lbrace>\<lambda>rv. valid_blocked_except target\<rbrace>"
  apply (wpsimp wp: set_scheduler_action_wp)
  apply (fastforce simp: valid_blocked_defs simple_sched_action_def
                   split: scheduler_action.splits)
  done

lemma set_scheduler_action_swt_valid_sched':
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except t and st_tcb_at runnable t
    and active_sc_tcb_at t and budget_sufficient t and budget_ready t and in_cur_domain t
    and simple_sched_action and (\<lambda>s. \<not> in_release_q t s)\<rbrace>
   set_scheduler_action (switch_thread t)
   \<lbrace>\<lambda>_.valid_sched\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  apply (clarsimp simp: valid_sched_wpsimps switch_in_cur_domain_2_def weak_valid_sched_action_2_def
                        in_queue_2_def released_sc_tcb_at_def)
  by (fastforce elim!: valid_blockedE')

lemma possible_switch_to_valid_sched_strong:
  "\<lbrace>\<lambda>s. if pred_map bound (tcb_scps_of s) target \<and> not_in_release_q target s
        then valid_sched_except_blocked s \<and> valid_blocked_except target s
              \<and> pred_map runnable (tcb_sts_of s) target \<and> target \<noteq> idle_thread s
              \<and> released_sc_tcb_at target s
        else valid_sched s\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding possible_switch_to_def gets_the_def
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (simp only: fun_app_def pred_tcb_at_eq_commute)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac "sc_opt = None \<or> inq"; clarsimp)
   apply (wpsimp, fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (wpsimp wp: set_scheduler_action_swt_valid_sched'
                    tcb_sched_enqueue_valid_sched reschedule_valid_sched_except_blocked_const
                    reschedule_required_valid_blocked thread_get_wp')
  apply (prop_tac "pred_map bound (tcb_scps_of s) target")
   apply (clarsimp simp: pred_map_def tcb_at_kh_simps)
  apply (clarsimp simp: released_sc_tcb_at_def tcb_at_kh_simps[symmetric])
  apply (prop_tac "budget_sufficient target s")
   apply (clarsimp simp: valid_sched_def elim!: valid_refills_budget_sufficient[OF active_sc_valid_refills_tcb_at])
  by (auto simp: obj_at_kh_kheap_simps valid_sched_valid_sched_except_blocked vs_all_heap_simps
                 in_cur_domain_def etcb_at_def valid_sched_def not_cur_thread_def ct_in_cur_domain_def)

crunches awaken
  for etcb_at[wp]: "etcb_at P t"
  and valid_idle_etcb[wp]: valid_idle_etcb
  and valid_idle[wp]: valid_idle
  and in_cur_domain[wp]: "in_cur_domain t"
  (wp: crunch_wps)

lemma possible_switch_to_valid_ready_qs:
  "\<lbrace>valid_ready_qs
    and (\<lambda>s. bound_sc_tcb_at ((=) None) target s \<or>
     (\<forall>tcb. ko_at (TCB tcb) target s \<and>
      (tcb_domain tcb \<noteq> cur_domain s \<or> scheduler_action s \<noteq> resume_cur_thread)
       \<longrightarrow> (runnable (tcb_state tcb) \<and> released_sc_tcb_at target s)))\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding possible_switch_to_def gets_the_def
  apply (rule hoare_seq_ext[OF _ gsc_sp], simp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac sc_opt; case_tac inq; clarsimp)
    apply (wpsimp+)[3]
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (wpsimp wp: hoare_vcg_if_lift2)
  apply (clarsimp simp: obj_at_def pred_tcb_at_def dest!: sym[of _ "tcb_sched_context _"])
  done

\<comment> \<open>set_simple_ko functions\<close>

lemma set_endpoint_idle_valid_sched_pred[wp]:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) ((ep_send_qs_of s)(ep_ptr := None))
          ((ep_recv_qs_of s)(ep_ptr := None)) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s) \<rbrace>
   set_endpoint ep_ptr IdleEP
   \<lbrace>\<lambda>_. valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp wp: set_simple_ko_wp)
  by (clarsimp simp: fun_upd_def ep_at_pred_def obj_at_def vs_all_heap_simps)

lemma set_endpoint_send_valid_sched_pred[wp]:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) ((ep_send_qs_of s)(ep_ptr := Some queue))
          ((ep_recv_qs_of s)(ep_ptr := None)) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s) \<rbrace>
   set_endpoint ep_ptr (SendEP queue)
   \<lbrace>\<lambda>_. valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp wp: set_simple_ko_wp)
  by (clarsimp simp: fun_upd_def ep_at_pred_def obj_at_def vs_all_heap_simps)

lemma set_endpoint_recv_valid_sched_pred[wp]:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) ((ep_send_qs_of s)(ep_ptr := None))
          ((ep_recv_qs_of s)(ep_ptr := Some queue)) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s) \<rbrace>
   set_endpoint ep_ptr (RecvEP queue)
   \<lbrace>\<lambda>_. valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp wp: set_simple_ko_wp)
  by (clarsimp simp: fun_upd_def ep_at_pred_def obj_at_def vs_all_heap_simps)

lemma set_notification_valid_sched_pred[wp]:
  "set_notification ntfn_ptr ntfn \<lbrace>valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp simp: set_simple_ko_def wp: set_object_wp get_object_wp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps a_type_def
          split: option.splits kernel_object.splits if_splits)

lemma set_replies_valid_sched_pred[wp]:
  "set_reply reply_ptr reply \<lbrace>valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp simp: set_simple_ko_def wp: set_object_wp get_object_wp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps a_type_def
          split: option.splits kernel_object.splits if_splits)

lemma set_reply_obj_ref_valid_sched_pred[wp]:
  "set_reply_obj_ref update ref new \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: update_sk_obj_ref_def wp: set_object_wp get_object_wp)

lemma set_notification_obj_ref_valid_sched_pred[wp]:
  "set_ntfn_obj_ref update ref new \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: update_sk_obj_ref_def wp: set_object_wp get_object_wp)

lemma set_simple_ko_valid_sched_pred[wp]:
  "set_simple_ko f ptr ep
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>"
  apply (wpsimp simp: set_simple_ko_def wp: set_object_wp_strong get_object_wp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps a_type_def
          split: option.splits kernel_object.splits if_splits)

lemma possible_switch_to_weak_valid_sched_action[wp]:
  "\<lbrace>\<lambda>s. weak_valid_sched_action s
        \<and> (pred_map bound (tcb_scps_of s) target \<and> not_in_release_q target s
            \<longrightarrow> pred_map runnable (tcb_sts_of s) target \<and> released_sc_tcb_at target s)\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  apply (wpsimp wp: possible_switch_to_wp)
  by (clarsimp simp: weak_valid_sched_action_def vs_all_heap_simps in_release_q_def)

lemma possible_switch_to_activatable[wp]:
  "\<lbrace>is_activatable t\<rbrace> possible_switch_to target \<lbrace>\<lambda>_. is_activatable t\<rbrace>"
  by (wpsimp simp: possible_switch_to_def
               wp: set_scheduler_action_wp thread_get_wp' get_tcb_obj_ref_wp)

lemma possible_switch_to_activatable_ct[wp]:
  "\<lbrace>\<lambda>s. is_activatable (cur_thread s) s\<rbrace> possible_switch_to target \<lbrace>\<lambda>_ s. is_activatable (cur_thread s) s\<rbrace>"
  by (rule hoare_lift_Pf[where f=cur_thread]; wpsimp)

lemma reschedule_required_switch_in_cur_domain[wp]:
  "\<lbrace>switch_in_cur_domain\<rbrace> reschedule_required \<lbrace>\<lambda>_. switch_in_cur_domain\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma possible_switch_to_switch_in_cur_domain[wp]:
  "\<lbrace>switch_in_cur_domain\<rbrace> possible_switch_to target \<lbrace>\<lambda>_. switch_in_cur_domain\<rbrace>"
  apply (wpsimp simp: possible_switch_to_def
                  wp: set_scheduler_action_wp thread_get_wp' get_tcb_obj_ref_wp)
  by (clarsimp simp: switch_in_cur_domain_def obj_at_kh_kheap_simps vs_all_heap_simps
                     in_cur_domain_def etcb_at_def)

lemma possible_switch_to_valid_sched_action[wp]:
  "\<lbrace>\<lambda>s. valid_sched_action s
        \<and> (pred_map bound (tcb_scps_of s) target \<and> not_in_release_q target s
            \<longrightarrow> pred_map runnable (tcb_sts_of s) target \<and> released_sc_tcb_at target s)\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  by (wpsimp simp: valid_sched_action_def)

lemma reply_unlink_sc_valid_sched_misc[wp]:
  "reply_unlink_sc sc_ptr reply_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp simp: reply_unlink_sc_def wp: get_simple_ko_wp)

lemma reply_unlink_tcb_valid_sched_pred_lift:
  assumes "\<lbrace>\<lambda>s::'z::state_ext state. valid_sched_pred_strong P' s\<rbrace>
           set_thread_state t Inactive
           \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  shows "\<lbrace>\<lambda>s::'z::state_ext state.
               pred_map (\<lambda>st. reply_object st = Some r) (tcb_sts_of s) t
               \<longrightarrow> valid_sched_pred_strong P' s\<rbrace>
         reply_unlink_tcb t r
         \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: assms gts_wp' get_simple_ko_wp
           simp: reply_unlink_tcb_def obj_at_kh_kheap_simps vs_all_heap_simps)

lemma reply_unlink_tcb_valid_sched_pred[valid_sched_wp]:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>st. reply_object st = Some r ) (tcb_sts_of s) t \<longrightarrow>
        P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
          (if t = cur_thread s \<and> scheduler_action s = resume_cur_thread then choose_new_thread else scheduler_action s)
          (etcbs_of s) (tcb_sts_of s(t \<mapsto> Inactive)) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   reply_unlink_tcb t r
   \<lbrace>\<lambda>_. valid_sched_pred_strong P\<rbrace>"
  apply (rule reply_unlink_tcb_valid_sched_pred_lift)
  by (wpsimp wp: set_thread_state_valid_sched_pred_strong)

lemma reply_unlink_tcb_valid_sched_misc[wp]:
  "reply_unlink_tcb t r
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (sc_replies_of s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (etcbs_of s) (tcb_scps_of s)
          (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: reply_unlink_tcb_valid_sched_pred)

lemma valid_sched_scheduler_act_not:
  "valid_sched s \<Longrightarrow> st_tcb_at ((=) k) y s \<Longrightarrow> \<not> runnable k \<Longrightarrow> scheduler_act_not y s"
  by (clarsimp simp: valid_sched_def valid_sched_action_def weak_valid_sched_action_def
                     scheduler_act_not_def obj_at_kh_kheap_simps vs_all_heap_simps)

lemma valid_sched_scheduler_act_not_better:
  "valid_sched s \<Longrightarrow> st_tcb_at (Not \<circ> runnable) y s \<Longrightarrow> scheduler_act_not y s"
  by (clarsimp simp: valid_sched_def valid_sched_action_def weak_valid_sched_action_def
                     scheduler_act_not_def obj_at_kh_kheap_simps vs_all_heap_simps)

lemma reply_unlink_tcb_valid_sched:
  "reply_unlink_tcb t rptr \<lbrace>valid_sched\<rbrace>"
  apply (wpsimp wp: reply_unlink_tcb_valid_sched_pred_lift[OF set_thread_state_Inactive_not_runnable_valid_sched])
  by (auto simp: vs_all_heap_simps valid_sched_valid_sched_except_blocked runnable_eq)

lemma reply_unlink_tcb_valid_release_q:
  "reply_unlink_tcb t rptr \<lbrace>valid_release_q\<rbrace>"
  apply (wpsimp wp: reply_unlink_tcb_valid_sched_pred_lift set_thread_state_not_runnable_valid_release_q)
  by (auto simp: vs_all_heap_simps runnable_eq)

lemma reply_unlink_tcb_valid_ready_qs:
  "reply_unlink_tcb t rptr \<lbrace>valid_ready_qs\<rbrace>"
  apply (clarsimp simp: reply_unlink_tcb_def)
  apply (wpsimp wp: set_thread_state_not_runnable_valid_ready_qs gts_wp get_simple_ko_wp
                    update_sk_obj_ref_lift)
  apply (intro conjI impI; clarsimp simp: reply_tcb_reply_at_def obj_at_def pred_tcb_at_eq_commute elim!: st_tcb_weakenE)
  done

lemma reply_unlink_tcb_valid_sched_action:
  "reply_unlink_tcb t rptr \<lbrace>valid_sched_action\<rbrace>"
  apply (wpsimp wp: reply_unlink_tcb_valid_sched_pred_lift[OF set_thread_state_valid_sched_action[simplified pred_conj_def]])
  by (auto simp: valid_sched_action_def weak_valid_sched_action_def scheduler_act_not_def vs_all_heap_simps runnable_eq)

lemma reply_unlink_tcb_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action \<rbrace>
   reply_unlink_tcb t rptr
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  apply (wpsimp wp: reply_unlink_tcb_valid_sched_pred_lift[OF set_thread_state_weak_valid_sched_action[simplified pred_conj_def]])
  by (auto simp: valid_sched_action_def weak_valid_sched_action_def scheduler_act_not_def vs_all_heap_simps runnable_eq)

lemma reply_unlink_tcb_ct_in_cur_domain:
  "\<lbrace>ct_in_cur_domain \<rbrace>
   reply_unlink_tcb t rptr
   \<lbrace>\<lambda>_. ct_in_cur_domain\<rbrace>"
  apply (clarsimp simp: reply_unlink_tcb_def)
  apply (wpsimp wp: gts_wp get_simple_ko_wp update_sk_obj_ref_lift)
  done

lemma reply_unlink_tcb_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked \<rbrace>
   reply_unlink_tcb t rptr
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: reply_unlink_tcb_valid_sched_pred_lift[OF set_thread_state_Inactive_not_runnable_valid_sched_except_blocked])
  by (auto simp: vs_all_heap_simps runnable_eq)

lemma reply_unlink_tcb_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set S \<rbrace>
   reply_unlink_tcb t rptr
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  apply (clarsimp simp: reply_unlink_tcb_def)
  apply (wpsimp wp: set_thread_state_valid_blocked_const gts_wp get_simple_ko_wp update_sk_obj_ref_lift)
  done

lemma get_tcb_NoneD: "get_tcb t s = None \<Longrightarrow> \<not> (\<exists>v. kheap s t = Some (TCB v))"
  apply (case_tac "kheap s t", simp_all add: get_tcb_def)
  apply (case_tac a, simp_all)
  done

lemma update_sk_obj_ref_valid_sched_misc[wp]:
  "update_sk_obj_ref C f ref new
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s)
           (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
           (ready_queues s) (release_queue s) (scheduler_action s)
           (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
           (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>"
  by (wpsimp simp: update_sk_obj_ref_def)

lemma set_scheduler_action_swt_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except_set (insert t X) and st_tcb_at runnable t
     and budget_ready t and budget_sufficient t
     and active_sc_tcb_at t and in_cur_domain t and simple_sched_action and (\<lambda>s. \<not> in_release_q t s)\<rbrace>
   set_scheduler_action (switch_thread t)
   \<lbrace>\<lambda>_ s. valid_sched_except_blocked s \<and> valid_blocked_except_set X s \<rbrace>"
  apply (wpsimp wp: set_scheduler_action_wp)
  by (auto simp: valid_sched_def ct_not_in_q_def valid_sched_action_def
                 weak_valid_sched_action_def in_cur_domain_def ct_in_cur_domain_def
                 not_in_release_q_def switch_in_cur_domain_def valid_blocked_defs
                 simple_sched_action_def vs_all_heap_simps obj_at_kh_kheap_simps
          split: scheduler_action.splits)

\<comment> \<open>This is actually entirely equivalent to possible_switch_to_valid_sched_strong\<close>
lemma possible_switch_to_valid_sched_weak:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> valid_blocked_except target s
         \<and> (pred_map bound (tcb_scps_of s) target \<and> not_in_release_q target s
             \<longrightarrow> pred_map runnable (tcb_sts_of s) target \<and> released_sc_tcb_at target s
                 \<and> target \<noteq> idle_thread s)\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  apply (wpsimp wp: possible_switch_to_valid_sched_strong simp: valid_sched_def valid_blocked_defs)
  apply (case_tac "t=target", clarsimp simp: vs_all_heap_simps)
  by fastforce

lemma possible_switch_to_valid_blocked:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert target S) s\<rbrace>
   possible_switch_to target
   \<lbrace>\<lambda>rv s. valid_blocked_except_set S s\<rbrace>"
  unfolding possible_switch_to_def
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply clarsimp
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac "sc_opt = None \<or> inq"; clarsimp)
   apply (wpsimp, fastforce simp: valid_blocked_defs obj_at_kh_kheap_simps vs_all_heap_simps)
  apply (wpsimp wp: tcb_sched_enqueue_valid_blocked_except_set reschedule_required_valid_blocked
                    set_scheduler_action_valid_blocked_remove thread_get_wp')
  by (auto elim!: valid_blockedE')

lemma reply_unlink_tcb_scheduler_act_not[wp]:
  "\<lbrace>scheduler_act_not t'\<rbrace> reply_unlink_tcb t r \<lbrace>\<lambda>_. scheduler_act_not t'\<rbrace>"
  apply (clarsimp simp: reply_unlink_tcb_def)
  by (wpsimp wp: gts_wp get_simple_ko_wp)

lemma set_thread_state_pred_map_tcb_sts_of:
  "\<lbrace>\<lambda>s. (t' = t \<longrightarrow> N (P st)) \<and> (t' \<noteq> t \<longrightarrow> N (pred_map P (tcb_sts_of s) t'))\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>rv s. N (pred_map P (tcb_sts_of s) t')\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: vs_all_heap_simps)

lemma set_thread_state_valid_sched:
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except t
    and (\<lambda>s. \<not> runnable st \<longrightarrow> not_queued t s \<and> not_in_release_q t s \<and> scheduler_act_not t s)
    and (\<lambda>s. runnable st \<longrightarrow> active_sc_tcb_at t s
           \<longrightarrow> (in_ready_q t s \<or> in_release_q t s \<or> t = cur_thread s
               \<or> scheduler_action s = switch_thread t))
    and (\<lambda>s. (is_blocked_on_recv_ntfn st \<longrightarrow> released_if_bound_sc_tcb_at t s)
             \<and> (is_blocked_on_send st \<longrightarrow> valid_sender_sc_tcb_at t s)
             \<and> (is_blocked_on_reply st \<longrightarrow> active_if_bound_sc_tcb_at t s))\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def
               wp: hoare_drop_imp set_thread_state_valid_ready_qs set_thread_state_valid_release_q
                   set_thread_state_valid_sched_action set_thread_state_valid_blocked
                   set_thread_state_released_ipc_queues)

(* refill_unblock_check lemmas *)

lemma refill_unblock_check_valid_sched_misc[wp]:
  "refill_unblock_check scptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)\<rbrace>"
  unfolding refill_unblock_check_defs
  apply (wpsimp wp: hoare_drop_imp whileLoop_wp')
  done

lemma refill_unblock_check_valid_blocked_except_set[wp]:
  "\<lbrace>valid_blocked_except_set S\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding refill_unblock_check_defs update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_wp get_refills_wp is_round_robin_wp whileLoop_wp'
         | fastforce simp: vs_all_heap_simps valid_blocked_except_set_2_def valid_blocked_thread_def
                           obj_at_def)+
  done

lemmas refill_unblock_check_valid_blocked[wp] =
       refill_unblock_check_valid_blocked_except_set[where S="{}"]

lemmas update_sc_refills_active_sc_tcb_at2[wp]
  = bound_sc_obj_tcb_at_update_sched_context_no_change[where P=active_scrc and f="sc_refills_update f" for f, simplified]

crunches refill_unblock_check
  for active_sc_tcb_at[wp]: "\<lambda>s. P (active_sc_tcb_at tcb_ptr s)"
  (wp: crunch_wps simp: update_refill_hd_rewrite ignore: update_sched_context)

lemma is_round_robin_sp:
  "\<lbrace>Q\<rbrace>
   is_round_robin scp
   \<lbrace>\<lambda>rv s. Q s \<and> (rv = round_robin scp s)\<rbrace>"
  apply (wpsimp simp: is_round_robin_def round_robin_def vs_all_heap_simps)
  apply (clarsimp simp: obj_at_def)
  done

lemma is_refill_sufficient_alt:
  "unat MIN_BUDGET + unat usage \<le> unat max_time
   \<Longrightarrow> is_refill_sufficient usage sc_ptr s
       = pred_map (\<lambda>cfg. MIN_BUDGET + usage \<le> r_amount (hd (scrc_refills cfg)))
                  (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps refill_sufficient_def refill_capacity_def)
  apply (intro iffI)
   apply (fastforce simp: MIN_BUDGET_pos MIN_BUDGET_nonzero word_l_diffs(3) word_not_le)
  apply (prop_tac "unat (MIN_BUDGET + usage) = unat MIN_BUDGET + unat usage")
   apply (fastforce simp: unat_plus_simple unat_sum_bound_equiv)
  apply (fastforce simp: unat_sub word_le_nat_alt word_less_nat_alt)
  done

method merge_refills_simple
  = (clarsimp simp: merge_refills_def refill_pop_head_def merge_refill_def
                    update_sched_context_set_refills_rewrite update_refill_hd_rewrite
     , wpsimp wp: set_refills_wp get_refills_wp
     , (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps refills_sum_def)?)

method refill_head_overlapping_loop_simple
  = ((clarsimp simp: refill_head_overlapping_loop_def)?
     , wpsimp wp: whileLoop_wp' set_refills_wp get_refills_wp
            simp: merge_refills_def round_robin_def refill_pop_head_def sc_valid_refills_def
                  update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                  vs_all_heap_simps obj_at_def)


lemma merge_refills_refills_unat_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow>  pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg))
                                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; simp?)
  apply (rename_tac a list)
  apply (subst unat_add_lem')
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list)
   apply (clarsimp simp: unat_minus_one_word)
  apply (case_tac list; simp)
  done

lemma merge_refills_hd_r_amount:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. a \<le> r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
            \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. Suc 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. a \<le> r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def pred_map_simps)
  apply (rename_tac sc n)
  apply (clarsimp simp: word_le_nat_alt)
  apply (subst unat_add_lem')
   apply (case_tac "sc_refills sc"; clarsimp?)
   apply (rename_tac list)
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list)
   apply (clarsimp simp: unat_minus_one_word)
  apply fastforce
  done

lemma no_ofail_refill_head_overlapping:
  "no_ofail (\<lambda>s. \<exists>sc n. kheap s sc_ptr = Some (SchedContext sc n)) (refill_head_overlapping sc_ptr)"
  unfolding refill_head_overlapping_def no_ofail_def
  apply (clarsimp simp: obind_def obj_at_def read_sched_context_def)
  done

lemma refill_head_overlapping_true_imp_length_at_least_two:
  "\<lbrakk>the (refill_head_overlapping sc_ptr s); pred_map \<top> (scs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. Suc 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (insert no_ofailD[OF no_ofail_refill_head_overlapping])
  apply (fastforce simp: refill_head_overlapping_def vs_all_heap_simps read_sched_context_def)
  done

lemma refill_head_overlapping_loop_hd_r_amount:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. a \<le> r_amount (hd (scrc_refills cfg))) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. a \<le> r_amount (hd (scrc_refills cfg))) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply refill_head_overlapping_loop_simple
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
   apply (wpsimp wp: merge_refills_hd_r_amount)
  apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                     simp: vs_all_heap_simps)
  apply (wpsimp wp: merge_refills_refills_unat_sum)
  apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                     simp: vs_all_heap_simps)
  done

lemma refill_unblock_check_is_refill_sufficient[wp]:
  "unat MIN_BUDGET + unat usage \<le> unat max_time
   \<Longrightarrow> \<lbrace>is_refill_sufficient usage sc_ptr' and (\<lambda>s. sc_ptr' = sc_ptr \<longrightarrow> valid_refills sc_ptr' s)\<rbrace>
       refill_unblock_check sc_ptr
       \<lbrace>\<lambda>_. is_refill_sufficient usage sc_ptr'\<rbrace>"
  supply round_robin_def[simp add]
  apply (subst is_refill_sufficient_alt, simp)+
  apply (clarsimp simp: refill_unblock_check_def bind_assoc update_refill_hd_rewrite)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_when_cases, simp)
  apply (repeat_unless \<open>rule hoare_seq_ext[OF _ get_refills_sp]\<close>
                       \<open>rule hoare_seq_ext_skip, solves wpsimp, clarsimp?\<close>)

  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply (wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
               simp: merge_refills_def refill_pop_head_def head_insufficient_loop_def
                     refill_head_overlapping_loop_def non_overlapping_merge_refills_def
                     vs_all_heap_simps update_refill_hd_rewrite update_sched_context_set_refills_rewrite)

  apply (rename_tac refills)
  apply (rule_tac Q="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                                  (sc_refill_cfgs_of s) sc_ptr
                         \<and> pred_map (\<lambda>cfg. scrc_refills cfg = refills) (sc_refill_cfgs_of s) sc_ptr
                         \<and> pred_map (\<lambda>cfg. MIN_BUDGET + usage \<le> r_amount (scrc_refill_hd cfg))
                                     (sc_refill_cfgs_of s) sc_ptr"
               in hoare_weaken_pre[rotated])
   apply (fastforce dest: unat_sum_list_equals_budget
                    simp: sc_valid_refills_def vs_all_heap_simps obj_at_def)
  apply (rule_tac B="\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                                    (sc_refill_cfgs_of s) sc_ptr
                           \<and> pred_map (\<lambda>cfg. MIN_BUDGET + usage \<le> r_amount (scrc_refill_hd cfg))
                                       (sc_refill_cfgs_of s) sc_ptr"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: set_refills_wp get_refills_wp)
    apply (clarsimp simp: vs_all_heap_simps refills_unat_sum_def obj_at_def)
    apply (rename_tac sc n)
    apply (case_tac "sc_refills sc"; clarsimp)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps refills_unat_sum_def)
  apply (wpsimp wp: refill_head_overlapping_loop_hd_r_amount)
  done

lemma refill_unblock_check_budget_sufficient[wp]:
  "\<lbrace>budget_sufficient tcb_ptr and active_sc_valid_refills
    and (\<lambda>s. \<forall>scp. bound_sc_tcb_at ((=) (Some scp)) tcb_ptr s \<longrightarrow> valid_refills scp s)\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>xc s. budget_sufficient tcb_ptr s\<rbrace>"
  apply (clarsimp simp: budget_sufficient_def2)
  apply (wpsimp wp: refill_unblock_check_is_refill_sufficient hoare_vcg_ex_lift)
  apply (fastforce simp: active_sc_valid_refills_def vs_all_heap_simps obj_at_kh_kheap_simps)
  done

lemma merge_refills_is_refill_ready:
  "merge_refills sc_ptr' \<lbrace>is_refill_ready sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: refill_ready_def)
  done

lemma refill_head_overlapping_is_refill_ready:
  "refill_head_overlapping_loop sc_ptr' \<lbrace>is_refill_ready sc_ptr\<rbrace>"
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: whileLoop_wp'; fastforce?)
  apply (wpsimp wp: merge_refills_is_refill_ready)
  done

lemma refill_unblock_check_is_refill_ready[wp]:
  "refill_unblock_check sc_ptr' \<lbrace>is_refill_ready sc_ptr\<rbrace>"
  (is "valid _ _ ?post")
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule_tac B="?post" in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (fastforce simp: pred_tcb_at_def obj_at_def vs_all_heap_simps refill_ready_def)
  apply (wpsimp wp: refill_head_overlapping_is_refill_ready)
  done

lemma refill_unblock_check_budget_ready[wp]:
  "refill_unblock_check sc_ptr \<lbrace>budget_ready tcb_ptr\<rbrace>"
  apply (clarsimp simp: budget_ready_def2)
  apply (wpsimp wp: hoare_vcg_ex_lift)
  done

crunches refill_unblock_check, if_cond_refill_unblock_check
  for active_sc_tcb_at[wp]: "\<lambda>s. P (active_sc_tcb_at tcb_ptr s)"
  (wp: crunch_wps simp: update_refill_hd_rewrite ignore: update_sched_context)

lemma refill_unblock_check_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at x and active_sc_valid_refills\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>r. released_sc_tcb_at x\<rbrace>"
  unfolding released_sc_tcb_at_def
  by wpsimp

lemma refill_unblock_check_valid_ready_qs[wp]:
  "\<lbrace>valid_ready_qs and active_sc_valid_refills\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (clarsimp simp: valid_ready_qs_def)
  apply (wpsimp simp: Ball_def released_sc_tcb_at_def
                  wp: hoare_vcg_all_lift hoare_vcg_imp_lift'' refill_unblock_check_active_sc_tcb_at)
  done

lemma refill_head_overlapping_loop_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> sc_not_in_release_q sc_ptr s\<rbrace>
   refill_head_overlapping_loop sc_ptr
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
   apply (wpsimp wp: set_refills_valid_release_q get_refills_wp hoare_vcg_all_lift
                      hoare_vcg_imp_lift' set_refills_wp
                simp: merge_refills_def refill_pop_head_def
                      update_refill_hd_def update_sched_context_set_refills_rewrite)
   apply (fastforce simp: vs_all_heap_simps obj_at_def split: if_splits)
  apply (wpsimp wp: set_refills_wp get_refills_wp
              simp: merge_refills_def refill_pop_head_def
                    update_refill_hd_def update_sched_context_set_refills_rewrite)
  apply (fastforce simp: vs_all_heap_simps obj_at_def split: if_splits)
  done

lemma refill_unblock_check_valid_release_q:
  "\<lbrace>valid_release_q and sc_not_in_release_q sc_ptr\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule_tac B="\<lambda>_ s. valid_release_q s \<and> sc_not_in_release_q sc_ptr s"
               in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_valid_release_q)
  apply (wpsimp wp: refill_head_overlapping_loop_valid_release_q)
  done

lemma refill_unblock_check_valid_sched_action[wp]:
  "\<lbrace>valid_sched_action and active_sc_valid_refills\<rbrace>
    refill_unblock_check sc_ptr
   \<lbrace>\<lambda>rv. valid_sched_action\<rbrace>"
  unfolding valid_sched_action_def
  apply (clarsimp simp: is_activatable_def weak_valid_sched_action_def switch_in_cur_domain_def)
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift'')
  done

lemma get_sc_refill_ready_sp:
  "\<lbrace>P\<rbrace>
   get_sc_refill_ready sc_ptr
   \<lbrace>\<lambda>rv s. P s \<and> (\<exists>sc n. ko_at (SchedContext sc n) sc_ptr s \<and> rv = sc_refill_ready (cur_time s) sc)\<rbrace>"
  apply (wpsimp wp: get_sc_refill_ready_wp)
  apply (clarsimp simp: obj_at_def)
  done

lemma refill_unblock_check_bounded_release_time:
  "\<lbrace>bounded_release_time sc_ptr' and current_time_bounded\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. bounded_release_time sc_ptr'\<rbrace>"
  (is "valid ?pre _ ?post")
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule hoare_seq_ext[OF _ get_sc_refill_ready_sp])
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule_tac B="\<lambda>_. ?pre" in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps bounded_release_time_def unat_plus_gt_trans)
   apply (subst unat_add_lem')
    apply (clarsimp simp: word_le_nat_alt obj_at_def current_time_bounded_def unat_minus_one_word)
   apply (clarsimp simp: current_time_bounded_def)
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="?post"]
         ; fastforce?)
  apply merge_refills_simple
  done

lemma refill_unblock_check_is_active_sc_at[wp]:
  "refill_unblock_check sc_ptr \<lbrace>\<lambda>s. Q (is_active_sc scp s)\<rbrace>"
  apply (clarsimp simp: refill_unblock_check_defs)
  apply (wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
              simp: update_sched_context_set_refills_rewrite
         | clarsimp simp: vs_all_heap_simps active_sc_def obj_at_kh_kheap_simps pred_map_simps)+
  done

lemma valid_refills_refills_unat_sum_equals_budget:
  "\<lbrakk>sc_valid_refills sc; sc_period sc \<noteq> 0; MIN_BUDGET \<le> sc_budget sc\<rbrakk>
   \<Longrightarrow> refills_unat_sum (sc_refills sc) = unat (sc_budget sc)"
  supply map_map [simp del]
  apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def split: if_splits)
   apply (rule_tac s="refills_sum (sc_refills sc)" and t="sc_budget sc" in subst; assumption?)
   apply (rule unat_sum_list_equals_budget; fastforce?)
  done

abbreviation sp_valid_refills_unbundled where
  "sp_valid_refills_unbundled sc_ptr s \<equiv>
   pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (hd (scrc_refills cfg))) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
               (sc_refill_cfgs_of s) sc_ptr"


lemma merge_refills_refills_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                                          (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow>  pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg))
                                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                 (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (case_tac list; clarsimp simp: add_ac)
  done

lemma refill_head_overlapping_loop_refills_sum:
  "refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                 (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (cases "sc_ptr'\<noteq>sc_ptr")
   apply refill_head_overlapping_loop_simple
  apply (wpsimp wp: whileLoop_wp'; fastforce?)
  apply (wpsimp wp: merge_refills_refills_sum)
  apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                     simp: vs_all_heap_simps)

  done

lemma refill_head_overlapping_refills_not_overlapping:
  "\<lbrakk>\<not> (the (refill_head_overlapping sc_ptr s));
    pred_map (\<lambda>cfg. Suc 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. \<not>(r_time (hd (tl (scrc_refills cfg)))
                         \<le> r_time (hd (scrc_refills cfg)) + r_amount (hd (scrc_refills cfg))))
                  (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (insert no_ofailD[OF no_ofail_refill_head_overlapping])
  apply (clarsimp simp: refill_head_overlapping_def obind_def read_sched_context_def)
  done

lemma merge_refills_no_overflow_helper:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + refills_unat_sum (scrc_refills cfg)
                          \<le> unat max_time)
                   (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. Suc 0 < length (scrc_refills cfg))
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + refills_unat_sum (scrc_refills cfg)
                          \<le> unat max_time)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def pred_map_simps)
  apply (subst unat_add_lem')
   apply (case_tac "sc_refills sc"; clarsimp simp: unat_minus_one_word)
   apply (case_tac list; clarsimp)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (case_tac list; clarsimp?)
  done

lemma merge_refills_no_overflow:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + refills_unat_sum (scrc_refills cfg)
                                \<le> unat max_time)
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. Suc 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: obj_at_def refills_unat_sum_def pred_map_simps)
  apply (rename_tac sc n)
  apply (rule_tac left="[\<lparr>r_time = r_time (refill_hd sc),
                          r_amount = r_amount (hd (tl (sc_refills sc))) + r_amount (refill_hd sc)\<rparr>]"
              and right="tl (tl (sc_refills sc))"
               in no_overflow_append)
    apply (clarsimp simp: no_overflow_def)
    apply (subst unat_add_lem')
     apply (case_tac "sc_refills sc"; clarsimp)
     apply (rename_tac list)
     apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
      apply (fastforce intro: member_le_sum_list)
     apply (clarsimp simp: unat_minus_one_word)
    apply (case_tac "sc_refills sc"; clarsimp)
    apply (case_tac list; clarsimp?)
   apply (blast intro: no_overflow_sublist)
  apply simp
  done

lemma refill_head_overlapping_loop_ordered_disjoint_strong:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. ordered_disjoint (tl (scrc_refills cfg))) (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + refills_unat_sum (scrc_refills cfg)
                                \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (case_tac "sc_ptr' \<noteq> sc_ptr")
   apply refill_head_overlapping_loop_simple
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre", rotated 3]
         ; fastforce?)
   defer
   apply (case_tac "\<not> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr")
    apply (clarsimp simp: vs_all_heap_simps)
    apply (rename_tac sc n)
    apply (case_tac "length (sc_refills sc) = 0 \<or> length (sc_refills sc) = 1")
     apply (clarsimp simp: ordered_disjoint_def)
    apply linarith
   apply (frule refill_head_overlapping_refills_not_overlapping)
    apply clarsimp
   apply (clarsimp simp: vs_all_heap_simps)
   apply (rename_tac sc n)
   apply (case_tac "sc_refills sc")
    apply (clarsimp simp: ordered_disjoint_def)
   apply clarsimp
   apply (rename_tac a list)
   apply (rule_tac left="[a]" and right=list in ordered_disjoint_append)
      apply (clarsimp simp: ordered_disjoint_def)
     apply simp
    apply (clarsimp simp: word_le_nat_alt)
    apply (subst unat_add_lem'[symmetric])
     apply (clarsimp simp: refills_unat_sum_def unat_minus_one_word)
    apply (subst unat_add_lem')
     apply (clarsimp simp: unat_minus_one_word refills_unat_sum_def)
    apply (subst unat_add_lem'[symmetric])
     apply (clarsimp simp: refills_unat_sum_def unat_minus_one_word)
    apply linarith
   apply simp
  apply (intro hoare_vcg_conj_lift_pre_fix)
     defer
     apply (wpsimp wp: merge_refills_no_overflow)
     apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                        simp: vs_all_heap_simps)
    apply (wpsimp wp: merge_refills_no_overflow_helper)
    apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                       simp: vs_all_heap_simps)
   apply (wpsimp wp: merge_refills_refills_unat_sum)
   apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                      simp: vs_all_heap_simps)
  apply (wpsimp simp: merge_refills_def refill_pop_head_def update_refill_hd_rewrite
                      update_sched_context_set_refills_rewrite
                  wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (blast dest: ordered_disjoint_sublist)
  done

lemma refill_unblock_check_no_overflow_helper:
  "\<lbrakk>no_overflow (sc_refills sc); current_time_bounded s;
    refills_unat_sum (sc_refills sc) = unat (sc_budget sc); sc_refills sc \<noteq> [];
    sc_budget sc \<le> sc_period sc; sc_period sc \<le> MAX_PERIOD\<rbrakk>
   \<Longrightarrow> no_overflow (refill_hd sc \<lparr>r_time := cur_time s + kernelWCET_ticks\<rparr> # tl (sc_refills sc))"
  apply (rule_tac left="[refill_hd sc \<lparr>r_time := cur_time s + kernelWCET_ticks\<rparr>]"
              and right="tl (sc_refills sc)"
               in no_overflow_append)
    apply (clarsimp simp: no_overflow_def current_time_bounded_def refill_ready_def)
    apply (prop_tac "unat (r_amount (refill_hd sc)) \<le> unat MAX_PERIOD")
     apply (clarsimp simp: refills_unat_sum_def)
     apply (rule_tac y="sum_list (map unat (map r_amount (sc_refills sc)))" in order_trans)
      apply (fastforce intro: member_le_sum_list)
     apply (clarsimp simp: word_le_nat_alt)
    apply (subst unat_add_lem')
     apply (clarsimp simp: unat_minus_one_word)
    apply linarith
   using no_overflow_sublist apply blast
  apply simp
  done

lemma refill_unblock_check_no_overflow_helper2:
  "\<lbrakk>current_time_bounded s; refills_unat_sum (sc_refills sc) = unat (sc_budget sc);
    sc_refills sc \<noteq> []; sc_budget sc \<le> sc_period sc; sc_period sc \<le> MAX_PERIOD\<rbrakk>
   \<Longrightarrow> unat (cur_time s + kernelWCET_ticks)
        + refills_unat_sum (refill_hd sc \<lparr>r_time := cur_time s + kernelWCET_ticks\<rparr>
                            # tl (sc_refills sc))
       \<le> unat max_time"
  apply (clarsimp simp: refills_unat_sum_def no_overflow_def current_time_bounded_def)
  apply (subst unat_add_lem', simp add: unat_minus_one_word)
  apply (clarsimp simp: word_le_nat_alt)
  apply (case_tac "sc_refills sc"; clarsimp)
  done

lemma refill_head_overlapping_loop_no_overflow:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg)))
                               + refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                        (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply refill_head_overlapping_loop_simple
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (wpsimp wp: merge_refills_no_overflow_helper merge_refills_no_overflow)
  apply (fastforce intro!: refill_head_overlapping_true_imp_length_at_least_two
                     simp: vs_all_heap_simps)
  done

lemma refill_head_overlapping_loop_length:
  "refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: whileLoop_wp'; fastforce?)
  apply merge_refills_simple
  apply (frule refill_head_overlapping_true_imp_length_at_least_two)
   apply (clarsimp simp: vs_all_heap_simps)
  apply (fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps)
  done

lemma merge_refills_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill\<in>set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat (scrc_budget cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> the (refill_head_overlapping sc_ptr s))\<rbrace>
    merge_refills sc_ptr'
    \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill\<in>set (scrc_refills cfg). 0 < unat (r_amount refill))
                     (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (intro conjI impI)
   apply (frule refill_head_overlapping_true_imp_length_at_least_two)
    apply (clarsimp simp: vs_all_heap_simps)
   apply (subst unat_add_lem'')
    apply (rule_tac y="unat (sc_budget sc)" in order_trans)
     apply (case_tac "sc_refills sc"; clarsimp)
     apply (clarsimp simp: refills_unat_sum_cons)
     apply (rule_tac y="unat (sc_budget sc)" in order_trans)
      apply (prop_tac "unat (r_amount (hd list)) \<le> refills_unat_sum list")
       apply (prop_tac "hd list \<in> set list")
        apply (clarsimp simp: vs_all_heap_simps)
       apply (frule_tac refill="hd list" in refills_unat_sum_member_bound[rotated])
        apply (fastforce dest: refills_unat_sum_member_bound
                         simp: vs_all_heap_simps)
       apply fast
      apply linarith
     apply fastforce
    apply simp
   apply (clarsimp simp: vs_all_heap_simps)
  apply (metis list.sel(2) list.set_sel(2))
  done

lemma merge_refills_refills_unat_sum_equals_unat_budget:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg))
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; simp?)
  apply (rename_tac a list)
  apply (subst unat_add_lem'')
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list)
   apply (rule_tac y="unat (sc_budget sc)" in order_trans)
    apply fastforce
   apply simp
  apply (case_tac list; simp)
  done

lemma refill_head_overlapping_loop_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow>  pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                        (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "\<lbrace>?P\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (rule_tac I="\<lambda>_. ?P" in valid_whileLoop; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves merge_refills_simple)?)
   apply (wpsimp wp: merge_refills_non_zero_refills)
   apply (clarsimp simp: vs_all_heap_simps)
  apply (rule hoare_vcg_imp_lift_pre_add; (solves merge_refills_simple)?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves merge_refills_simple)?)
  apply (wpsimp wp: merge_refills_refills_unat_sum_equals_unat_budget)
  apply (fastforce dest: refill_head_overlapping_true_imp_length_at_least_two
                   simp: vs_all_heap_simps)
  done

lemma refill_head_overlapping_loop_window:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow>  pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg)))
                                 + refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   refill_head_overlapping_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: whileLoop_wp'; fastforce?)
  apply merge_refills_simple
  apply (clarsimp simp: window_def last_tl tl_Nil)
  done

lemma refill_unblock_check_valid_refills[wp]:
   "\<lbrace>valid_refills p and current_time_bounded\<rbrace>
    refill_unblock_check sc_ptr
    \<lbrace>\<lambda>_. valid_refills p\<rbrace>"
  supply map_map[simp del] round_robin_def[simp add]
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp])
  apply (rule hoare_seq_ext[OF _ get_sc_refill_ready_sp])
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])

  apply (case_tac "sc_ptr \<noteq> p")
   apply (wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
               simp: merge_refills_def refill_pop_head_def head_insufficient_loop_def
                     refill_head_overlapping_loop_def non_overlapping_merge_refills_def
                     vs_all_heap_simps update_refill_hd_rewrite update_sched_context_set_refills_rewrite)

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                   (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2])
   apply (clarsimp simp: vs_all_heap_simps)
   apply (frule valid_refills_refills_unat_sum_equals_budget
          ; fastforce?)
   apply (clarsimp simp: sc_valid_refills_def)

  apply (rule_tac Q="\<lambda>_ s. \<not> round_robin sc_ptr s \<and> sp_valid_refills_unbundled sc_ptr s"
               in hoare_strengthen_post[rotated])
   apply (fastforce simp: valid_refills_def vs_all_heap_simps)

  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves refill_head_overlapping_loop_simple)?)
        apply (wpsimp wp: refill_head_overlapping_loop_refills_sum set_refills_wp get_refills_wp)
        apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
        apply (rename_tac sc n)
        apply (case_tac "sc_refills sc"; clarsimp)
       apply (wpsimp wp: refill_head_overlapping_loop_ordered_disjoint_strong
                         set_refills_wp get_refills_wp)
       apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
       apply (intro conjI impI allI)
          apply (blast dest: ordered_disjoint_sublist)
         apply (fastforce intro: refill_unblock_check_no_overflow_helper)
        apply (fastforce intro: refill_unblock_check_no_overflow_helper2)
       apply (clarsimp simp: refills_unat_sum_def)
       apply (rename_tac sc n)
       apply (case_tac "sc_refills sc"; clarsimp)
      apply (wpsimp wp: refill_head_overlapping_loop_no_overflow set_refills_wp get_refills_wp)
      apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
      apply (fastforce intro: refill_unblock_check_no_overflow_helper
                              refill_unblock_check_no_overflow_helper2)
     apply (wpsimp wp: refill_head_overlapping_loop_window set_refills_wp get_refills_wp)
     apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
     apply (intro conjI impI)
      prefer 2
      apply (fastforce intro: refill_unblock_check_no_overflow_helper
                              refill_unblock_check_no_overflow_helper2)
     apply (clarsimp simp: window_def refill_ready_def word_le_nat_alt current_time_bounded_def)
     apply (prop_tac "last (tl (sc_refills sca)) = refill_tl sca")
      using last_tl apply blast
     apply (prop_tac "unat (cur_time s + kernelWCET_ticks)
                      = unat (cur_time s) + unat kernelWCET_ticks")
      apply (subst unat_add_lem', simp add: unat_minus_one_word, simp)
     apply fastforce
    apply (wpsimp wp: refill_head_overlapping_loop_hd_r_amount set_refills_wp get_refills_wp)
    apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def refills_unat_sum_def)
    apply (rename_tac sc n)
    apply (case_tac "sc_refills sc"; clarsimp)
   apply (wpsimp wp: refill_head_overlapping_loop_length set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
  apply (wpsimp wp: refill_head_overlapping_loop_non_zero_refills set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps sc_valid_refills_def obj_at_def)
  apply (rename_tac sc n)
  apply (intro conjI impI)
   apply (simp add: list.set_sel(2))
  apply (clarsimp simp: refills_unat_sum_def)
  apply (case_tac "sc_refills sc"; clarsimp)
  done

crunches if_cond_refill_unblock_check
  for valid_refills[wp]: "valid_refills sc_ptr"
  (simp: crunch_simps)

lemma refill_unblock_check_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and current_time_bounded\<rbrace>
    refill_unblock_check sc_ptr
   \<lbrace>\<lambda>rv. active_sc_valid_refills\<rbrace>"
  unfolding active_sc_valid_refills_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_unblock_check_bounded_release_time
           simp: Ball_def)
  done

lemma refill_unblock_check_released_ipc_queues[wp]:
  "\<lbrace>released_ipc_queues and active_sc_valid_refills\<rbrace>
    refill_unblock_check sc_ptr
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  unfolding released_ipc_queues_defs
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift'' hoare_vcg_disj_lift)

lemma refill_unblock_check_active_reply_scs[wp]:
  "refill_unblock_check scp \<lbrace>active_reply_scs\<rbrace>"
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply refill_head_overlapping_loop_simple
   apply (fastforce simp: active_reply_scs_def active_if_reply_sc_at_def vs_all_heap_simps
                          active_sc_def)
  apply simp
  done

lemma refill_unblock_check_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked and sc_not_in_release_q sc_ptr and current_time_bounded\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  unfolding valid_sched_def
  by (wpsimp wp: refill_unblock_check_valid_ready_qs refill_unblock_check_valid_release_q
                 refill_unblock_check_valid_sched_action
                 refill_unblock_check_active_sc_valid_refills)

lemma refill_unblock_check_valid_sched:
  "\<lbrace>valid_sched and (not is_refill_ready sc_ptr or (sc_not_in_release_q sc_ptr and current_time_bounded))\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (subst pred_conj_disj_distribL)
  apply (rule hoare_pre_disj)
   apply (simp add: refill_unblock_check_def)
   apply (rule hoare_seq_ext[OF _ is_round_robin_sp])
   apply (rule hoare_seq_ext[OF _ get_sc_refill_ready_sp])
   apply simp
   apply (rule hoare_pre)
    apply (rule hoare_when_wp)
    apply (rule hoare_pre_cont)
   apply (clarsimp simp: pred_neg_def obj_at_def opt_map_def vs_all_heap_simps)
  unfolding valid_sched_def
  by (wpsimp wp: refill_unblock_check_valid_ready_qs
                 refill_unblock_check_valid_release_q
                 refill_unblock_check_valid_sched_action
                 refill_unblock_check_active_sc_valid_refills)

(* end : refill_unblock_check lemmas *)

crunches if_cond_refill_unblock_check
  for valid_sched_misc[wp]: "\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
          (sc_tcbs_of s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s)
          (release_queue s) (scheduler_action s) (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
          (tcb_faults_of s) (sc_replies_of s)"
  and valid_blocked_except[wp]: "valid_blocked_except t"
  and released_sc_tcb_at[wp]: "released_sc_tcb_at t"
  (simp: crunch_simps wp: refill_unblock_check_valid_sched_except_blocked)

lemma if_cond_refill_unblock_check_valid_sched_except_blocked[wp]:
  "\<lbrace>valid_sched_except_blocked and (\<lambda>s. \<forall>scp. scp_opt = Some scp \<longrightarrow> sc_not_in_release_q scp s)
    and current_time_bounded\<rbrace>
   if_cond_refill_unblock_check scp_opt act ast
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  unfolding if_cond_refill_unblock_check_def
  by (wpsimp wp: refill_unblock_check_valid_sched_except_blocked)

(* Some lemmas about activeness of scheduling contexts, and in particular, cur_sc_active *)

lemma refill_unblock_check_cur_sc_active[wp]:
  "refill_unblock_check sc_ptr \<lbrace>cur_sc_active\<rbrace>"
  by (rule cur_sc_active_lift; wpsimp)

lemma heap_upd_update_id:
  "(\<And>x. map_option f (proj x) = proj x) \<Longrightarrow> heap_upd f ptr proj = proj"
  by (fastforce simp: heap_upd_def)

(* FIXME RT: generalise to other field updates and other heaps*)
lemma map_option_scrc_refills_update_rewrite:
  "map_option (scrc_refills_update f) (map_option (scrc_refills_update g) (sc_refill_cfgs_of s ptr))
   = map_option (scrc_refills_update (f \<circ> g)) (sc_refill_cfgs_of s ptr)"
  apply (case_tac "sc_refill_cfgs_of s ptr"; fastforce)
  done

lemma refill_budget_check_round_robin_sc_refills_update_unspecified:
  "\<lbrace>\<lambda>s. \<forall>f. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
              (last_machine_time_of s) (time_state_of s)
              (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
              (ready_queues s) (release_queue s) (scheduler_action s)
              (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
              (heap_upd (scrc_refills_update f) (cur_sc s) (sc_refill_cfgs_of s)) (sc_replies_of s)\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_sched_pred_strong P\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
            update_sched_context_set_refills_rewrite
  apply (clarsimp simp: bind_assoc)
  apply (wpsimp wp: set_refills_valid_sched_pred get_refills_wp hoare_vcg_imp_lift' hoare_vcg_all_lift
         | wpsimp wp: set_refills_wp)+
  apply (clarsimp simp: heap_upd_def map_option_scrc_refills_update_rewrite)
  done

lemma refill_budget_check_round_robin_is_active_sc[wp]:
  "refill_budget_check_round_robin consumed \<lbrace>\<lambda>s. P (is_active_sc sc_ptr s)\<rbrace>"
  by (wpsimp wp: refill_budget_check_round_robin_sc_refills_update_unspecified
           simp: active_reply_scs_defs)

crunches refill_budget_check_round_robin, commit_time
  for cur_sc[wp]: "\<lambda>s. P (cur_sc s)"

lemma refill_budget_check_round_robin_cur_sc_active[wp]:
  "refill_budget_check_round_robin consumed \<lbrace>cur_sc_active\<rbrace>"
  by (rule cur_sc_active_lift; wpsimp)

method handle_overrun_loop_body_simple
  = ((clarsimp simp: handle_overrun_loop_body_def)?
     , wpsimp wp: whileLoop_wp' set_refills_wp get_refills_wp
            simp: refill_pop_head_def vs_all_heap_simps obj_at_def refill_single_def refill_size_def
                  update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                  schedule_used_defs)

method handle_overrun_loop_simple
  = ((clarsimp simp: handle_overrun_loop_def)?
     , wpsimp wp: whileLoop_wp' set_refills_wp get_refills_wp
            simp: handle_overrun_loop_body_def merge_refills_def round_robin_def refill_pop_head_def
                  sc_valid_refills_def vs_all_heap_simps obj_at_def refill_budget_check_defs
                  update_sched_context_set_refills_rewrite schedule_used_defs)

method head_insufficient_loop_simple
  = ((clarsimp simp: head_insufficient_loop_def)?
     , wpsimp wp: whileLoop_wp' set_refills_wp get_refills_wp
            simp: non_overlapping_merge_refills_def refill_pop_head_def schedule_used_defs
                  update_sched_context_set_refills_rewrite update_refill_hd_rewrite
     , clarsimp simp: vs_all_heap_simps obj_at_def sc_valid_refills_def round_robin_def
                      unat_MAX_RELEASE_TIME
               split: if_splits
     , fastforce?)

lemma refill_budget_check_is_active_sc[wp]:
  "refill_budget_check usage \<lbrace>\<lambda>s. P (is_active_sc sc_ptr s)\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def update_refill_hd_rewrite schedule_used_defs)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply handle_overrun_loop_simple
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: set_refills_wp get_refills_wp simp: update_sched_context_set_refills_rewrite)
   apply (clarsimp simp: obj_at_def cur_sc_tcb_def sc_at_pred_n_def vs_all_heap_simps)
  apply head_insufficient_loop_simple
  done

lemma refill_budget_check_cur_sc_active[wp]:
  "refill_budget_check usage \<lbrace>cur_sc_active\<rbrace>"
  by (rule cur_sc_active_lift; wpsimp)

lemma refill_budget_check_round_robin_valid_sched_misc[wp]:
  "refill_budget_check_round_robin consumed
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s)
          (release_queue s) (scheduler_action s) (etcbs_of s)
          (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
  by (wpsimp wp: hoare_drop_imp)

lemma refill_budget_check_valid_sched_misc[wp]:
  "refill_budget_check consumed
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s) (cur_time s) (cur_domain s) (cur_thread s)
          (idle_thread s) (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)
          (ep_send_qs_of s) (ep_recv_qs_of s)\<rbrace>"
  unfolding refill_budget_check_defs schedule_used_defs
  apply (wpsimp wp: hoare_drop_imp whileLoop_wp')
  done

lemma commit_time_is_active_sc[wp]:
  "commit_time \<lbrace>\<lambda>s. P (is_active_sc scp s)\<rbrace>"
  unfolding commit_time_def
  by (wpsimp wp: hoare_drop_imp)

lemma commit_time_cur_sc_active[wp]:
  "commit_time \<lbrace>cur_sc_active\<rbrace>"
  by (rule cur_sc_active_lift; wpsimp)

lemma maybe_add_empty_tail_valid_sched_misc[wp]:
  "maybe_add_empty_tail sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def set_refills_def by wpsimp

lemma refill_new_valid_sched_misc[wp]:
  "refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)\<rbrace>"
  unfolding refill_new_def by wpsimp

lemma refill_update_valid_sched_misc[wp]:
  "refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)\<rbrace>"
  unfolding refill_update_def refill_add_tail_def update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: hoare_drop_imps)
  done

lemma maybe_add_empty_tail_is_active_sc[wp]:
  "maybe_add_empty_tail sc_ptr \<lbrace>\<lambda>s. Q (is_active_sc scp s)\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def set_refills_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma refill_update_is_active_sc[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr
        then Q (active_sc mrefills)
        else Q (is_active_sc scp s)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv s. Q (is_active_sc scp s)\<rbrace>"
  unfolding refill_update_def refill_add_tail_def
            update_sched_context_set_refills_rewrite update_refill_hd_rewrite
  apply (wpsimp wp: set_refills_wp hoare_drop_imps get_refills_wp update_sched_context_wp)
  by (clarsimp simp: obj_at_def vs_all_heap_simps)

lemma refill_new_is_active_sc[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr
        then Q (active_sc mrefills)
        else Q (is_active_sc scp s)\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv s. Q (is_active_sc scp s)\<rbrace>"
  unfolding refill_new_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma maybe_add_empty_tail_not_cur_sc_active[wp]:
  "maybe_add_empty_tail sc_ptr \<lbrace>\<lambda>s. \<not> cur_sc_active s\<rbrace>"
  by (rule hoare_lift_Pf[where f=cur_sc]; wpsimp)

lemma refill_update_not_cur_sc_active[wp]:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then new_max_refills = 0
        else \<not> cur_sc_active s\<rbrace>
   refill_update sc_ptr new_period new_budget new_max_refills
   \<lbrace>\<lambda>_ s. \<not> cur_sc_active s\<rbrace>"
  unfolding refill_update_def set_refills_def refill_add_tail_def update_refill_hd_def get_refills_def
            update_refill_tl_def
  apply (wpsimp wp: update_sched_context_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps active_sc_def obj_at_def split: if_splits)
  done

lemma refill_new_cur_sc_active[wp]:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then max_refills = 0
        else \<not> cur_sc_active s\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>rv s. \<not> cur_sc_active s\<rbrace>"
  unfolding refill_new_def
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps active_sc_def obj_at_def split: if_splits)

lemma refill_reset_rr_is_active_sc[wp]:
  "refill_reset_rr csc_ptr \<lbrace>\<lambda>s. P (is_active_sc sc_ptr s)\<rbrace>"
  apply (clarsimp simp: refill_reset_rr_def update_refill_tl_def
                        update_sched_context_set_refills_rewrite update_refill_hd_def)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps active_sc_def obj_at_kh_kheap_simps pred_map_simps)
  done

crunches cancel_all_ipc, cancel_all_signals
  for is_active_sc[wp]: "\<lambda>s. P (is_active_sc sc_ptr s)"
  (wp: crunch_wps)

lemma sc_at_tcb_update[iff]:
  "tcb_at epptr s \<Longrightarrow>
   scs_of_kh (kheap s(epptr \<mapsto> TCB ko)) = scs_of s"
  by (rule map_eqI, auto simp add: vs_heap_simps obj_at_def is_tcb)

lemma thread_set_valid_sched_misc[wp]:
  "thread_set f t \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (sc_refill_cfgs_of s)\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  apply (subst sc_at_tcb_update; clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps is_tcb)
  done

lemma reply_push_valid_sched_misc[wp]:
  "reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (etcbs_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)
          (ep_send_qs_of s) (ep_recv_qs_of s)\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp hoare_vcg_if_lift2 hoare_drop_imps hoare_vcg_all_lift
           simp: reply_push_def bind_sc_reply_def)

crunch valid_refills[wp]: set_cdt,set_original,set_extra_badge "valid_refills scp"
  (wp_del: set_original_wp)

crunch valid_sched_pred_strong[wp]: set_extra_badge "valid_sched_pred_strong P"

lemma transfer_caps_valid_sched_pred_strong[wp]:
  "transfer_caps info caps ep recv recv_buf \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (simp add: transfer_caps_def | wp transfer_caps_loop_pres | wpc)+

lemma transfer_caps_loop_valid_refills[wp]:
  "\<And>ep buffer n caps slots mi.
    \<lbrace>valid_refills scp\<rbrace>
    transfer_caps_loop ep buffer n caps slots mi
    \<lbrace>\<lambda>_. valid_refills scp\<rbrace>"
  by (wp transfer_caps_loop_pres)

context DetSchedSchedule_AI begin

crunches send_ipc, end_timeslice
  for is_active_sc[wp]: "\<lambda>s :: 'state_ext state. P (is_active_sc sc_ptr s)"
  (wp: crunch_wps simp: crunch_simps)

lemma charge_budget_is_active_sc[wp]:
  "charge_budget consumed canTimeout \<lbrace>\<lambda>s :: 'state_ext state. P (is_active_sc sc_ptr s)\<rbrace>"
  apply (clarsimp simp: charge_budget_def refill_reset_rr_def update_refill_tl_def
                        update_sched_context_set_refills_rewrite update_refill_hd_def)
  apply (wpsimp wp: hoare_drop_imps set_refills_wp get_refills_wp is_round_robin_wp)
  apply (clarsimp simp: vs_all_heap_simps active_sc_def obj_at_kh_kheap_simps pred_map_simps)
  done

crunches check_budget
  for is_active_sc[wp]: "\<lambda>s :: 'state_ext state. P (is_active_sc sc_ptr s)"

end

lemma restart_thread_if_no_fault_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s
        \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<and> current_time_bounded s
        \<and> \<not> pred_map runnable (tcb_sts_of s) t \<and> t \<noteq> idle_thread s
        \<and> (fault_tcb_at' bound t s \<or> released_if_bound_sc_tcb_at t s)\<rbrace>
   restart_thread_if_no_fault t
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  supply if_split [split del]
  unfolding restart_thread_if_no_fault_def
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule hoare_if)
   apply clarsimp
   apply (wpsimp wp: possible_switch_to_valid_sched_weak)
      apply (wpsimp wp: hoare_vcg_if_lift2 refill_unblock_check_valid_sched_except_blocked
                        hoare_vcg_imp_lift' refill_unblock_check_valid_sched)
     apply clarsimp
     apply (wpsimp wp: get_tcb_obj_ref_wp)
    apply (rule_tac Q="\<lambda>_ b. (tcb_at t b \<longrightarrow>
                                (pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of b) t
                                     \<longrightarrow> not_in_release_q t b)
                                \<and> current_time_bounded b
                                \<and> (pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of b) t
                                   \<and> not_in_release_q t b
                                       \<longrightarrow> pred_map runnable (tcb_sts_of b) t
                                           \<and> released_sc_tcb_at t b
                                           \<and> active_sc_valid_refills b
                                           \<and> t \<noteq> idle_thread b)
                                \<and> valid_sched_except_blocked b
                                \<and> valid_blocked_except t b)
                             \<and> heap_refs_inv (tcb_scps_of b) (sc_tcbs_of b)"
           in hoare_strengthen_post[rotated])
     apply (clarsimp simp: obj_at_def is_tcb vs_all_heap_simps opt_map_red)
     apply (clarsimp simp: heap_refs_inv_def2)
     apply (frule_tac x=t and y=scp in spec2)
     apply (drule_tac x=ta and y=scp in spec2)
     apply (clarsimp simp: pred_map_eq vs_all_heap_simps opt_map_red)
    apply (wpsimp wp: hoare_vcg_imp_lift' set_thread_state_pred_map_tcb_sts_of
                      set_thread_state_break_valid_sched[simplified pred_conj_def])
   apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of set_thread_state_runnable_valid_sched)
   apply (clarsimp simp: obj_at_def vs_all_heap_simps is_tcb valid_sched_not_runnable_not_in_release_q)
  apply (wpsimp wp: set_thread_state_Inactive_not_queued_valid_sched)
  apply (clarsimp simp: valid_sched_not_runnable_not_in_release_q valid_sched_not_runnable_not_queued
                        valid_sched_def valid_sched_not_runnable_scheduler_act_not)
  done

lemma st_tcb_at_inactive_runnable:
  "st_tcb_at ((=) Inactive) t s \<Longrightarrow> st_tcb_at (not runnable) t s "
  by (clarsimp elim!: st_tcb_weakenE simp: pred_neg_def)

lemma reply_unlink_tcb_not_runnable[wp]:
  "\<lbrace>\<top>\<rbrace>
     reply_unlink_tcb t r
   \<lbrace>\<lambda>rv. st_tcb_at (not runnable) t\<rbrace>"
  by (wpsimp wp: reply_unlink_tcb_inactive
         | strengthen st_tcb_at_inactive_runnable)+

lemma ipc_queued_thread_state_not_runnable:
  "ipc_queued_thread_state st \<Longrightarrow> \<not> runnable st"
  by (cases st; simp add: ipc_queued_thread_state_def)

lemma pred_map_weakenE:
  assumes "pred_map P m x"
  assumes "\<And>y. P y \<Longrightarrow> Q y"
  shows "pred_map Q m x"
  using assms by (auto simp: pred_map_simps)

lemma cancel_all_ipc_loop_body_valid_sched:
  "\<lbrace>(\<lambda>s. blocked_on_send_recv_tcb_at t s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
        \<and> current_time_bounded s \<and> t \<noteq> idle_thread s) and valid_sched\<rbrace>
     do st <- get_thread_state t;
        reply_opt <- case st of BlockedOnReceive x r_opt _ \<Rightarrow> return r_opt | _ \<Rightarrow> return None;
        y <- when (\<exists>y. reply_opt = Some y) (reply_unlink_tcb t (the reply_opt));
        restart_thread_if_no_fault t
     od
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: restart_thread_if_no_fault_valid_sched reply_unlink_tcb_valid_sched
                    reply_unlink_tcb_valid_sched_pred_lift[OF set_thread_state_pred_map_tcb_sts_of]
                    gts_wp')
  apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) t", fastforce simp: vs_all_heap_simps is_blocked_thread_state_defs)
  apply (clarsimp simp: valid_sched_not_runnable_not_queued valid_sched_not_runnable_not_in_release_q
                        valid_sched_not_runnable_scheduler_act_not)
  apply (frule valid_sched_released_ipc_queues, simp add: released_ipc_queues_defs)
  apply (drule_tac x=t in spec)
  by (intro conjI; clarsimp simp: is_timeout_fault_opt_def vs_all_heap_simps pred_map_simps)
      fastforce

(* strong in case of tcb_domain t = tcb_domain target *)
lemma possible_switch_to_sched_act_not[wp]:
  "\<lbrace>K(t \<noteq> target) and scheduler_act_not t\<rbrace>
     possible_switch_to target
   \<lbrace>\<lambda>_. scheduler_act_not t\<rbrace>"
  apply (simp add: possible_switch_to_def reschedule_required_def thread_get_def
                   set_scheduler_action_def tcb_sched_action_def get_tcb_obj_ref_def
              split del: if_split
        | wp | wpc)+
  apply (clarsimp simp: etcb_at_def scheduler_act_not_def split: option.splits)
  done

crunches restart_thread_if_no_fault
  for scheduler_act_not[wp]: "scheduler_act_not t"
  (wp: crunch_wps)

lemma cancel_all_ipc_loop_body_blocked_on_send_recv:
  "\<lbrace>\<lambda>s. blocked_on_send_recv_tcb_at t' s \<and> t' \<noteq> t\<rbrace>
     do st <- get_thread_state t;
        reply_opt <- case st of BlockedOnReceive x r_opt _ \<Rightarrow> return r_opt | _ \<Rightarrow> return None;
        _ <- when (\<exists>y. reply_opt = Some y) (reply_unlink_tcb t (the reply_opt));
        restart_thread_if_no_fault t
     od
  \<lbrace>\<lambda>_. blocked_on_send_recv_tcb_at t'\<rbrace>"
  by (wpsimp wp: restart_thread_if_no_fault_other[unfolded obj_at_kh_kheap_simps]
                 reply_unlink_tcb_st_tcb_at[unfolded obj_at_kh_kheap_simps]
                 gts_wp')

(* fixme move *)
lemma TCBBlockedRecv_in_state_refs_of:
  assumes "(ep, TCBBlockedRecv) \<in> state_refs_of s t"
  shows "\<exists>data pl. st_tcb_at ((=) (BlockedOnReceive ep data pl)) t s"
  using assms
  by (clarsimp simp: state_refs_of_def refs_of_def get_refs_def2 tcb_st_refs_of_def
                     pred_tcb_at_def obj_at_def
              split: option.splits kernel_object.splits thread_state.splits if_splits)

(* fixme move *)
lemma TCBSignal_in_state_refs_of:
  assumes "(ep, TCBSignal) \<in> state_refs_of s t"
  shows "st_tcb_at ((=) (BlockedOnNotification ep)) t s"
  using assms
  by (clarsimp simp: state_refs_of_def refs_of_def get_refs_def2 tcb_st_refs_of_def
                     pred_tcb_at_def obj_at_def
              split: option.splits kernel_object.splits thread_state.splits if_splits)

lemma ipc_queued_thread_in_ep_queueE:
  "sym_refs (state_refs_of s)
   \<Longrightarrow> ep_at_pred (\<lambda>ep. ep_queue_of ep \<noteq> None \<and> t \<in> set (the (ep_queue_of ep))) epptr s
   \<Longrightarrow> ipc_queued_thread t s"
  apply (clarsimp simp: ep_at_pred_def)
  apply (case_tac obj; simp add: ep_queue_of_def)
   apply (subgoal_tac "(epptr, TCBBlockedSend) \<in> (state_refs_of s) t")
    apply (drule TCBBlockedSend_in_state_refs_of)
    apply (clarsimp simp: tcb_at_kh_simps pred_map_simps ipc_queued_thread_state_def)
   apply (erule sym_refsE, clarsimp simp: state_refs_of_def)
  apply (subgoal_tac "(epptr, TCBBlockedRecv) \<in> (state_refs_of s) t")
   apply (drule TCBBlockedRecv_in_state_refs_of)
   apply (clarsimp simp: tcb_at_kh_simps pred_map_simps ipc_queued_thread_state_def)
   apply (erule sym_refsE, clarsimp simp: state_refs_of_def)
  done

crunches restart_thread_if_no_fault
  for misc[wp]: "\<lambda>s. P (tcb_scps_of s) (sc_tcbs_of s) (idle_thread s)"
  and active_sc_valid_refills[wp]: active_sc_valid_refills
  and current_time_bounded[wp]: current_time_bounded
  (simp: crunch_simps wp: crunch_wps)

lemma cancel_all_ipc_loop_valid_sched:
  "\<lbrace>(\<lambda>s. \<forall>t\<in>set queue. blocked_on_send_recv_tcb_at t s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                       \<and> current_time_bounded s \<and> t \<noteq> idle_thread s)
        and valid_sched and K (distinct queue)\<rbrace>
   mapM_x (\<lambda>t. do st <- get_thread_state t;
                  reply_opt <- case st of BlockedOnReceive _ ro _ \<Rightarrow> return ro | _ \<Rightarrow> return None;
                  _ <- when (\<exists>r. reply_opt = Some r) (reply_unlink_tcb t (the reply_opt));
                  restart_thread_if_no_fault t
               od) queue
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (rule hoare_gen_asm)
  apply (rule ball_mapM_x_scheme[OF _ cancel_all_ipc_loop_body_valid_sched])
  by (wpsimp wp: cancel_all_ipc_loop_body_blocked_on_send_recv gts_wp')

lemma cancel_all_ipc_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> valid_objs s \<and> valid_idle s \<and> sym_refs (state_refs_of s)
        \<and> current_time_bounded s\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  unfolding cancel_all_ipc_def endpoint.case_eq_if
  apply (wpsimp wp: reschedule_valid_sched_const cancel_all_ipc_loop_valid_sched
                    get_simple_ko_wp get_ep_queue_wp'
              simp: obj_at_def)
  apply (erule (1) pspace_valid_objsE
         ; clarsimp simp: valid_obj_def valid_ep_distinct_queue pred_map_P_not_idle cong: conj_cong)
  apply (rename_tac ep q t)
  apply (case_tac ep
         ; clarsimp simp: ep_queue_of_def valid_ep_def
         ; drule (1) bspec
         ; clarsimp simp: vs_all_heap_simps obj_at_def is_tcb)
   apply (drule_tac y=t and x=epptr and tp=TCBBlockedSend in sym_refsE
          ; clarsimp simp: in_state_refs_of_iff in_get_refs in_tcb_st_refs_of_iff)
  apply (drule_tac y=t and x=epptr and tp=TCBBlockedRecv in sym_refsE
         ; clarsimp simp: in_state_refs_of_iff in_get_refs in_tcb_st_refs_of_iff)
  done

lemma set_thread_state_possible_switch_to_valid_sched_strong:
  "\<lbrace>valid_ready_qs
    and valid_release_q
    and ready_or_release
    and ct_not_in_q
    and valid_sched_action
    and ct_in_cur_domain
    and valid_blocked_except t
    and valid_idle_etcb
    and (\<lambda>s. released_ipc_queues_2 (cur_time s) (tcb_sts_of s(t \<mapsto> st)) (tcb_scps_of s) (tcb_faults_of s)
                                   (sc_refill_cfgs_of s))
    and active_reply_scs
    and active_sc_valid_refills
    and released_if_bound_sc_tcb_at t
    and (\<lambda>s. t \<noteq> idle_thread s)
    and K (active ts)\<rbrace>
   do y <- set_thread_state t ts;
      possible_switch_to t
   od
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: possible_switch_to_valid_sched_weak
                    set_thread_state_runnable_valid_sched_except_blocked
                    set_thread_state_valid_blocked_const[where S="{t}"]
                    hoare_vcg_imp_lift' set_thread_state_pred_map_tcb_sts_of
              simp: runnable_eq_active)
  by (intro conjI; clarsimp simp: valid_sched_def vs_all_heap_simps fun_upd_def
                           split: if_splits elim!: released_ipc_queuesE)

lemma set_thread_state_possible_switch_to_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> released_if_bound_sc_tcb_at t s \<and> t \<noteq> idle_thread s \<and> active ts\<rbrace>
   do y <- set_thread_state t ts;
      possible_switch_to t
   od
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: set_thread_state_possible_switch_to_valid_sched_strong)
  by (auto simp: valid_sched_def fun_upd_def vs_all_heap_simps split: if_splits elim!: released_ipc_queuesE)

lemma cancel_all_signals_loop_valid_sched:
  "\<lbrace>(\<lambda>s. \<forall>t\<in>set queue. blocked_on_recv_ntfn_tcb_at t s \<and> t \<noteq> idle_thread s
       \<and> current_time_bounded s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
     and valid_sched and K (distinct queue)\<rbrace>
       mapM_x (\<lambda>t.
             do y <- set_thread_state t Restart;
                sc_opt \<leftarrow> get_tcb_obj_ref tcb_sched_context t;
                y \<leftarrow> if_sporadic_cur_sc_assert_refill_unblock_check sc_opt;
                possible_switch_to t
             od) queue
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (rule hoare_gen_asm, rule ball_mapM_x_scheme)
    apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of get_tcb_obj_ref_wp hoare_drop_imp)
   apply (wpsimp wp: get_tcb_obj_ref_wp possible_switch_to_valid_sched_weak hoare_vcg_imp_lift')
    apply (rule_tac Q="\<lambda>_ s. tcb_at t s \<longrightarrow>
                               (bound (tcb_scps_of s t) \<longrightarrow>  not_in_release_q t s)
                               \<and> current_time_bounded s
                               \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                               \<and> (pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t \<and> not_in_release_q t s
                                    \<longrightarrow> pred_map runnable (tcb_sts_of s) t \<and> released_sc_tcb_at t s
                                        \<and> t \<noteq> idle_thread s)
                               \<and> valid_sched_except_blocked s
                               \<and> valid_blocked_except t s"
           in hoare_strengthen_post[rotated])
     apply (clarsimp simp: obj_at_def is_tcb vs_all_heap_simps opt_map_red)
     apply (clarsimp simp: heap_refs_inv_def2 valid_sched_def)
     apply (rename_tac tcb scp t' tcb' sc n)
     apply (frule_tac x=t and y=scp in spec2)
     apply (drule_tac x=t' and y=scp in spec2)
     apply (clarsimp simp: pred_map_eq vs_all_heap_simps opt_map_red)
    apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of possible_switch_to_valid_sched_weak
                      set_thread_state_break_valid_sched[simplified pred_conj_def]
                      hoare_vcg_imp_lift')
   apply clarsimp
   apply (rule conjI; clarsimp?)
    apply (drule_tac tptr=t in valid_sched_not_runnable_not_in_release_q)
     apply (fastforce simp: obj_at_def is_tcb vs_all_heap_simps opt_map_red
                            is_blocked_on_receive_def is_blocked_on_ntfn_def
                     split: thread_state.split_asm)
    apply (clarsimp simp: vs_all_heap_simps)
   apply (drule (1) released_ipc_queues_blocked_on_recv_ntfn_E1[OF valid_sched_released_ipc_queues])
   apply (clarsimp simp: vs_all_heap_simps)
  by simp

lemma cancel_all_signals_valid_sched[wp]:
  "\<lbrace>\<lambda>s. valid_sched s \<and> valid_objs s \<and>  valid_idle s \<and> sym_refs (state_refs_of s)
        \<and> current_time_bounded s\<rbrace>
   cancel_all_signals ntfnptr
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  apply (wpsimp wp: reschedule_valid_sched_const cancel_all_signals_loop_valid_sched get_simple_ko_wp
              simp: cancel_all_signals_def obj_at_def)
  apply (erule (1) pspace_valid_objsE)
  apply (clarsimp simp: valid_obj_def valid_ntfn_distinct_queue pred_map_P_not_idle cong: conj_cong)
  apply (rename_tac q t)
  by (drule_tac x=ntfnptr and y=t and tp=TCBSignal in sym_refsE
      ; clarsimp simp: in_state_refs_of_iff refs_of_rev vs_all_heap_simps)

lemma thread_set_etcbs:
  "\<lbrakk>\<And>x. tcb_priority (f x) = tcb_priority x; \<And>x. tcb_domain (f x) = tcb_domain x\<rbrakk> \<Longrightarrow>
  thread_set f tptr \<lbrace>\<lambda>s. P (etcbs_of s)\<rbrace>"
  by (wpsimp wp: thread_set_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def)

lemmas thread_set_active_sc_tcb_at = bound_sc_obj_tcb_at_thread_set_no_change[where P=active_scrc]

lemma thread_set_valid_ready_qs:
  "\<lbrakk>\<And>x. tcb_state (f x) = tcb_state x; \<And>x. tcb_priority (f x) = tcb_priority x;
    \<And>x. tcb_domain (f x) = tcb_domain x; \<And>x. tcb_sched_context (f x) = tcb_sched_context x\<rbrakk> \<Longrightarrow>
    \<lbrace>valid_ready_qs\<rbrace> thread_set f tptr \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  by (rule valid_ready_qs_lift;
      wpsimp wp: thread_set_no_change_tcb_state[unfolded obj_at_kh_kheap_simps]
                 thread_set_etcbs thread_set_active_sc_tcb_at
                 budget_ready_thread_set_no_change budget_sufficient_thread_set_no_change)

lemma thread_set_valid_release_q:
  "\<lbrakk>\<And>x. tcb_state (f x) = tcb_state x; \<And>x. tcb_sched_context (f x) = tcb_sched_context x\<rbrakk> \<Longrightarrow>
   \<lbrace>valid_release_q\<rbrace> thread_set f tptr \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  by (wpsimp wp: thread_set_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def)

lemma thread_set_weak_valid_sched_action:
  "(\<And>x. tcb_state (f x) = tcb_state x) \<Longrightarrow>
   (\<And>x. tcb_sched_context (f x) = tcb_sched_context x) \<Longrightarrow>
   \<lbrace>weak_valid_sched_action\<rbrace> thread_set f tptr \<lbrace>\<lambda>rv. weak_valid_sched_action\<rbrace>"
  by (wpsimp wp: thread_set_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def)

lemma thread_set_not_state_valid_sched:
  "(\<And>x. tcb_state (f x) = tcb_state x) \<Longrightarrow>
   (\<And>x. tcb_sched_context (f x) = tcb_sched_context x) \<Longrightarrow>
   (\<And>x. tcb_fault (f x) = tcb_fault x) \<Longrightarrow>
   (\<And>x. tcb_priority (f x) = tcb_priority x) \<Longrightarrow>
   (\<And>x. tcb_domain (f x) = tcb_domain x) \<Longrightarrow>
   thread_set f tptr \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: thread_set_wp simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def)

lemma unbind_notification_valid_sched[wp]:
  "unbind_notification ntfnptr \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp simp: unbind_notification_def wp: get_tcb_obj_ref_wp)

lemma sched_context_unbind_tcb_valid_sched_misc[wp]:
  "sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (etcbs_of s)
          (tcb_sts_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp simp: sched_context_unbind_tcb_def
               wp: hoare_drop_imp hoare_vcg_all_lift set_tcb_sched_context_valid_sched_except_tcb_scp_heap)

lemma sched_context_unbind_all_tcbs_valid_sched_misc[wp]:
  "sched_context_unbind_all_tcbs sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (etcbs_of s)
          (tcb_sts_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  unfolding sched_context_unbind_all_tcbs_def
  by (wpsimp wp: get_sched_context_wp update_sched_context_wp update_sk_obj_ref_wp
           simp: obj_at_def vs_all_heap_simps fun_upd_def tcb_heap.all_simps)

lemma unbind_from_sc_valid_sched_misc[wp]:
  "unbind_from_sc tcb_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (etcbs_of s)
          (tcb_sts_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp simp: unbind_from_sc_def wp: hoare_drop_imp hoare_vcg_all_lift)

crunches test_reschedule
  for valid_ready_qs[wp]: "valid_ready_qs"
  and valid_sched: "valid_sched"
  and is_sc_active[wp]: "\<lambda>s. P (is_sc_active p s)"
  (wp: hoare_drop_imps hoare_vcg_if_lift2 reschedule_valid_sched_const)

crunches tcb_release_remove
  for is_sc_active[wp]: "is_sc_active p"
  (wp: hoare_drop_imps hoare_vcg_if_lift2)

lemma test_reschedule_not_queued[wp]:
  "\<lbrace>\<lambda>s. not_queued t s \<and> scheduler_act_not t s\<rbrace>
   test_reschedule thread
   \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  by (wpsimp wp: test_reschedule_wp) (auto simp: in_queues_2_def tcb_sched_enqueue_def scheduler_act_not_def)

global_interpretation set_tcb_queue: non_heap_op "set_tcb_queue d prio queue"
  by unfold_locales (wpsimp wp: set_tcb_queue_wp)

(* sched_context_donate *)

lemma set_tcb_sched_context_set[wp]:
  "\<lbrace>\<lambda>s. t' = t \<or> pred_map_eq v (tcb_scps_of s) t'\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t v
   \<lbrace>\<lambda>rv s. pred_map_eq v (tcb_scps_of s) t'\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: vs_all_heap_simps)

(* weak_valid_sched_action and the 2nd conjunction give the 3rd *)
lemma sched_context_donate_valid_ready_qs[wp]:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> pred_map_eq None (tcb_scps_of s) tptr \<and> scheduler_act_not tptr s\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  unfolding sched_context_donate_def reschedule_required_def
  apply (wpsimp wp: set_tcb_sched_context_valid_ready_qs get_sc_obj_ref_wp
                    tcb_sched_dequeue_valid_ready_qs hoare_vcg_imp_lift'
                    tcb_dequeue_not_queued tcb_dequeue_not_queued[where tptr=tptr])
  by (fastforce simp: in_queues_2_def dest!: valid_ready_qs_no_sc_not_queued)

lemma sched_context_donate_valid_release_q[wp]:
  "\<lbrace>valid_release_q and not_in_release_q tptr\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  by (wpsimp wp: set_tcb_sched_context_valid_release_q_not_queued
                 tcb_release_remove_not_in_release_q[where t=tptr] get_sc_obj_ref_wp
           simp: sched_context_donate_def)

lemma sched_context_donate_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace> sched_context_donate scp tp \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  by (wpsimp wp: tcb_dequeue_not_queued get_sc_obj_ref_wp
           simp: sched_context_donate_def)

lemma test_reschedule_sched_act_not_other:
  "test_reschedule t' \<lbrace>scheduler_act_not t\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma test_reschedule_sched_act_not_same[wp]:
  "\<lbrace>\<top>\<rbrace> test_reschedule t \<lbrace>\<lambda>rv. scheduler_act_not t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: scheduler_act_not_def)

(* FIXME RT: brutal proof *)
lemma sched_context_donate_valid_sched_action:
  "\<lbrace>valid_sched_action and bound_sc_tcb_at ((=) None) tcb_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp update_sched_context_wp test_reschedule_wp
                    tcb_sched_action_wp get_sc_obj_ref_wp
              simp: sched_context_donate_def tcb_release_remove_def)
  apply (frule weak_valid_sched_action_no_sc_sched_act_not[OF valid_sched_action_weak_valid_sched_action])
   apply (fastforce simp: vs_all_heap_simps tcb_at_kh_simps)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def pred_map_simps tcb_sched_dequeue_def scheduler_act_not_def
                 valid_sched_action_def weak_valid_sched_action_def opt_map_simps map_join_simps
           cong: conj_cong)

lemma test_reschedule_ct_in_cur_domain[wp]:
  "test_reschedule tcb_ptr \<lbrace>ct_in_cur_domain\<rbrace>"
  by (wpsimp wp: test_reschedule_wp)

lemma sched_context_donate_ct_in_cur_domain[wp]:
  "sched_context_donate sc_ptr tcb_ptr \<lbrace>ct_in_cur_domain\<rbrace>"
  by (wpsimp simp: sched_context_donate_def)

lemma sched_context_zero_refill_max_valid_sched_misc[wp]:
  "sched_context_zero_refill_max sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (sc_replies_of s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s) (tcbs_of s)\<rbrace>"
  unfolding sched_context_zero_refill_max_def
  by (wpsimp wp: get_sched_context_wp update_sched_context_wp update_sk_obj_ref_wp
           simp: obj_at_def vs_all_heap_simps fun_upd_def tcb_heap.all_simps)

lemma sched_context_zero_refill_max_valid_sched_unbound_sc:
  "\<lbrace>\<lambda>s. valid_sched s \<and> (\<nexists>t. pred_map_eq (Some ref) (tcb_scps_of s) t) \<and> \<not> non_empty_sc_replies_at ref s\<rbrace>
   sched_context_zero_refill_max ref
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (clarsimp simp: sched_context_zero_refill_max_def)
  supply if_split[split del] if_bool_simps[simp]
  apply (wpsimp wp: valid_sched_wp simp: valid_sched_def)
  apply (intro conjI)
        apply (clarsimp simp: valid_ready_queued_thread_2_def vs_all_heap_simps heap_upd_def elim!: valid_ready_qsE)
       apply (fastforce simp: tcb_sc_refill_cfgs_2_def opt_map_simps map_join_simps map_project_simps
                              heap_upd_def pred_map_simps sc_ready_time_eq_iff
                       split: if_splits
                       elim!: valid_release_qE sorted_release_qE)
      apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def heap_upd_def vs_all_heap_simps)
     apply (clarsimp elim!: valid_blockedE' simp: heap_upd_def vs_all_heap_simps active_sc_def split: if_splits)
    apply (fastforce simp: heap_upd_def vs_all_heap_simps is_blocked_thread_state_defs
                    elim!: released_ipc_queuesE cong: conj_cong split: if_splits)
   apply (clarsimp elim!: active_reply_scsE simp: heap_upd_def vs_all_heap_simps)
  by (clarsimp simp: active_sc_valid_refills_def heap_upd_def vs_all_heap_simps active_sc_def split: if_splits)

lemma tcb_release_remove_ready_or_release[wp]:
  "tcb_release_remove tcb_ptr \<lbrace>ready_or_release\<rbrace>"
  apply (rule hoare_pre)
  apply (rule tcb_release_remove_wp)
  apply (clarsimp simp: ready_or_release_def tcb_sched_dequeue_def ready_or_release_2_def
                        in_queue_2_def)
  done

lemma tcb_release_remove_valid_sched_not_runnable:
  "\<lbrace>\<lambda>s. valid_sched s \<and> (\<not> pred_map active (tcb_sts_of s) thread \<or> \<not> active_sc_tcb_at thread s)\<rbrace>
   tcb_release_remove thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: tcb_release_remove_valid_blocked simp: valid_sched_def valid_blocked_thread_def)

lemma tcb_release_remove_valid_sched_except_blocked:
  "\<lbrace>valid_sched_except_blocked\<rbrace> tcb_release_remove thread \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  by (wpsimp simp: valid_sched_def)

(* FIXME: not_used? *)
lemma set_mrs_ko_at_Endpoint[wp]:
  "set_mrs param_a param_b param_c \<lbrace>\<lambda>s. Q (ko_at (Endpoint ep) p s)\<rbrace>"
  apply (wpsimp simp: set_mrs_def wp: zipWithM_x_inv' set_object_wp)
  apply (clarsimp simp: obj_at_def dest!: get_tcb_SomeD)
  done

lemma reply_remove_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace> reply_remove tptr rptr \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  by (wpsimp simp: reply_remove_def wp: hoare_vcg_if_lift2 get_tcb_obj_ref_wp get_simple_ko_wp)

crunches test_reschedule
  for valid_blocked[wp]: "valid_blocked_except_set S"
    (wp: hoare_vcg_if_lift2)

crunches reply_remove_tcb
  for not_queued[wp]: "not_queued t"
  and not_in_release_q[wp]:  "not_in_release_q t"
  (wp: crunch_wps hoare_drop_imps hoare_vcg_if_lift2 tcb_release_remove_not_in_release_q)

lemma set_tcb_queue_get_tcb[wp]:
  "set_tcb_queue d prio queue \<lbrace>\<lambda>s. P (get_tcb t s)\<rbrace> "
  by (wpsimp simp: set_tcb_queue_def get_tcb_def)

crunches test_reschedule,tcb_release_remove
  for get_tcb[wp]: "\<lambda>s. P (get_tcb t s)"
  (wp: hoare_drop_imp simp: get_tcb_def)

lemma sched_context_donate_active_sc_tcb_at_neq:
  "\<lbrace>active_sc_tcb_at t and K (t \<noteq> tcb_ptr) and sc_tcb_sc_at (\<lambda>tp. tp \<noteq> Some t) sc_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. active_sc_tcb_at t\<rbrace>"
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred get_sc_obj_ref_wp
              simp: sched_context_donate_def)
  by (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps sc_tcb_sc_at_def
                     pred_map_simps opt_map_simps map_join_simps
              split: if_splits)

crunches test_reschedule
  for weak_valid_sched_action[wp]: weak_valid_sched_action
  (wp: hoare_vcg_if_lift2)

lemma test_reschedule_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane\<rbrace>
     test_reschedule tptr \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  by (wpsimp simp: test_reschedule_def wp: reschedule_required_not_queued)

crunches tcb_release_remove
  for ct_not_in_release_q[wp]: ct_not_in_release_q
  (simp: not_in_release_q_def tcb_sched_dequeue_def)

lemma sched_context_donate_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane\<rbrace> sched_context_donate sc_ptr tptr \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  apply (wpsimp wp: tcb_sched_action_wp get_sc_obj_ref_wp
              simp: sched_context_donate_def)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps tcb_sched_dequeue_def in_queues_2_def
          split: if_splits)

lemma test_reschedule_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane\<rbrace> test_reschedule tptr \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  apply (clarsimp simp: test_reschedule_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac action; wpsimp)
  done

crunches reply_remove
for scheduler_act_sane[wp]:  "scheduler_act_sane"
  (wp: get_object_wp hoare_drop_imp ignore: test_reschedule)

lemma tcb_release_remove_in_release_q_neq:
  "\<lbrace>in_release_q t and K (t \<noteq> tptr)\<rbrace> tcb_release_remove tptr \<lbrace>\<lambda>_. in_release_q t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: in_queue_2_def tcb_sched_dequeue_def)

lemma tcb_sched_dequeue_in_ready_q_neq:
  "\<lbrace>valid_ready_qs and in_ready_q t and K (t \<noteq> tptr)\<rbrace>
   tcb_sched_action tcb_sched_dequeue tptr
   \<lbrace>\<lambda>_. in_ready_q t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_ready_qs_def in_queues_2_def tcb_sched_dequeue_def) force

lemma tcb_sched_dequeue_in_etcb_ready_q_neq:
  "\<lbrace>in_etcb_ready_q t and K (t \<noteq> tptr)\<rbrace>
   tcb_sched_action tcb_sched_dequeue tptr
   \<lbrace>\<lambda>_. in_etcb_ready_q t\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto elim!: in_etcb_ready_q_2E simp: tcb_sched_dequeue_def)

lemma sched_context_donate_in_release_queue_neq:
  "\<lbrace>in_release_q t and sc_tcb_sc_at (\<lambda>p. p \<noteq> Some t) sc_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. in_release_q t\<rbrace>"
  by (wpsimp wp: tcb_release_remove_in_release_q_neq get_sc_obj_ref_wp
           simp: sched_context_donate_def sc_tcb_sc_at_def obj_at_def)

lemma test_reschedule_in_ready_q[wp]:
  "test_reschedule t \<lbrace>in_ready_q t'\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps)

lemma test_reschedule_in_etcb_ready_q[wp]:
  "test_reschedule t \<lbrace>in_etcb_ready_q t'\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_wpsimps in_etcb_ready_q_2_def)

lemma set_tcb_sched_context_valid_blocked_Some_not_queued:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert t S) s
         \<and> (pred_map runnable (tcb_sts_of s) t \<and> is_active_sc sp s
             \<longrightarrow> t \<in> S \<or> t = cur_thread s)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t (Some sp)
   \<lbrace>\<lambda>_. valid_blocked_except_set S\<rbrace>"
  by (wpsimp wp: set_tcb_sched_context_valid_blocked_Some')

lemma valid_blocked_thread_except:
  "t \<in> except \<Longrightarrow> valid_blocked_thread nq nr except queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs t"
  by (simp add: valid_blocked_thread_def)

\<comment> \<open>When a passive server performs a ReplyRecv, it will first donate its scheduling context back
    to the previous caller during the Reply phase. If there is another caller waiting, it will
    receive another scheduling context via donating, even though it is running.
    Note that sched_context_donate is never called when t_ptr is in the ready or release queues or
    the target of switch_thread, so we don't mention those possibilities in the precondition.\<close>
lemma sched_context_donate_valid_blocked:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert t_ptr S) s
         \<and> (pred_map runnable (tcb_sts_of s) t_ptr \<and> is_active_sc scp s
             \<longrightarrow> t_ptr \<in> S \<or> t_ptr = cur_thread s)\<rbrace>
   sched_context_donate scp t_ptr
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: set_tcb_sched_context_valid_blocked_Some_not_queued
                 set_tcb_sched_context_None_valid_blocked_except_set
                 tcb_release_remove_valid_blocked
                 tcb_sched_dequeue_valid_blocked_except_set_const
                 get_sc_obj_ref_wp
           simp: valid_blocked_thread_except)

lemma released_ipc_queues_except_strengthen:
  "released_ipc_queues_2 ctime sts scps faults refill_cfgs
   \<Longrightarrow> released_ipc_queues_2 ctime (sts(tp \<mapsto> Inactive)) scps faults refill_cfgs"
  apply (erule released_ipc_queuesE)
  by (clarsimp simp: pred_map_simps ipc_queued_thread_state_def)


\<comment> \<open>When sched_context_donate is called from reply_remove, we are not always able to ensure that
    tcb_ptr satisfies released_ipc_queued_thread, but that's ok because the thread will
    subsequently be made Inactive in reply_unlink_tcb.\<close>
lemma reply_remove_sched_context_donate_released_ipc_queues:
  "\<lbrace>released_ipc_queues\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv s. released_ipc_queues_2 (cur_time s) (tcb_sts_of s(t \<mapsto> Inactive))
                                    (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred get_sc_obj_ref_wp)
  apply (intro conjI impI
         ; erule released_ipc_queuesE
         ; clarsimp simp: obj_at_def vs_all_heap_simps is_blocked_thread_state_defs
                          pred_map_simps opt_map_simps map_join_simps
                   elim!: released_ipc_queuesE split: if_splits)
  by auto

abbreviation sched_context_donate_ipc_queues_precond where
  "sched_context_donate_ipc_queues_precond t scp s
   \<equiv> (blocked_on_recv_ntfn_tcb_at t s \<longrightarrow> released_sc_at scp s)
      \<and> (blocked_on_send_tcb_at t s \<longrightarrow> (if timeout_faulted_tcb_at t s then is_active_sc scp s else released_sc_at scp s))
      \<and> (blocked_on_reply_tcb_at t s \<longrightarrow> is_active_sc scp s)"

lemma sched_context_donate_released_sc_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> sched_context_donate_ipc_queues_precond t scp s\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred get_sc_obj_ref_wp
              simp: sched_context_donate_def)
  by (intro conjI impI; erule released_ipc_queuesE
      ; clarsimp simp: pred_map_simps opt_map_simps map_join_simps
                split: if_splits)

lemma in_ready_q_runnable:
  "valid_ready_qs_2 qs ctime etcbs sts scps scs \<Longrightarrow> in_queues_2 qs t \<longrightarrow> pred_map runnable sts t"
  by (auto simp: valid_ready_qs_def in_queues_2_def)

lemma in_release_q_runnable:
  "valid_release_q_2 q sts scps scs \<Longrightarrow> in_queue_2 q t \<longrightarrow> pred_map runnable sts t"
  by (auto simp: valid_release_q_def in_queue_2_def)

lemma switch_to_runnable:
  "valid_sched_action_2 True {} ctime sa ct cdom rlq etcbs sts scps scs \<Longrightarrow> sa = switch_thread t \<longrightarrow> pred_map runnable sts t"
  by (auto simp: valid_sched_action_def weak_valid_sched_action_def)

crunches test_reschedule
  for ready_or_release[wp]: "ready_or_release"

lemma sched_context_donate_ready_or_release[wp]:
  "sched_context_donate sc_ptr tcb_ptr \<lbrace>ready_or_release\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: gbn_wp thread_get_wp tcb_release_remove_ready_or_release)

lemma sched_context_donate_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> pred_map_eq None (tcb_scps_of s) t
        \<and> sched_context_donate_ipc_queues_precond t scp s\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv. valid_sched_except_blocked\<rbrace>"
  by (wpsimp wp: sched_context_donate_valid_sched_action
                 sched_context_donate_valid_blocked
                 sched_context_donate_released_sc_released_ipc_queues
           simp: valid_sched_def tcb_at_kh_simps pred_map_eq_def
                 valid_ready_qs_no_sc_not_queued
                 valid_release_q_no_sc_not_in_release_q
                 valid_sched_action_no_sc_sched_act_not)

lemma sched_context_donate_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> pred_map_eq None (tcb_scps_of s) t
        \<and> (pred_map runnable (tcb_sts_of s) t \<and> is_active_sc scp s \<longrightarrow> t = cur_thread s)
        \<and> sched_context_donate_ipc_queues_precond t scp s\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp wp: sched_context_donate_valid_sched_except_blocked
                 sched_context_donate_valid_blocked
           simp: valid_sched_valid_sched_except_blocked)

lemma valid_sched_blocked_imp:
   "\<lbrakk>valid_sched s; not_queued t s; not_in_release_q t s; scheduler_act_not t s; t \<noteq> cur_thread s\<rbrakk> \<Longrightarrow>
             \<not> (pred_map runnable (tcb_sts_of s) t \<and> active_sc_tcb_at t s)"
  by (auto simp: valid_sched_def valid_blocked_defs scheduler_act_not_def runnable_eq_active)

lemma reschedule_cnt[wp]:
  "\<lbrace>\<top>\<rbrace> reschedule_required \<lbrace>\<lambda>_ s. scheduler_action s = choose_new_thread\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma set_scheduler_action_cnt_act_not[wp]:
  "\<lbrace>\<top>\<rbrace> set_scheduler_action choose_new_thread \<lbrace>\<lambda>_. scheduler_act_not t\<rbrace>"
  by (wpsimp simp: set_scheduler_action_def)

lemma test_reschedule_case:
  "\<lbrace>(\<lambda>s. cur_thread s \<noteq> t) and scheduler_act_not t and Q\<rbrace>
      test_reschedule t \<lbrace>\<lambda>_. Q\<rbrace>"
  apply (clarsimp simp: test_reschedule_def scheduler_act_not_def when_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac action; clarsimp simp: pred_conj_def; intro conjI impI; wpsimp?)
     apply (rule hoare_assume_pre; clarsimp)+
  done

lemma test_reschedule_case_act:
  "\<lbrace>(\<lambda>s. scheduler_action s = switch_thread t)\<rbrace>
      test_reschedule t \<lbrace>\<lambda>_ s. scheduler_action s = choose_new_thread\<rbrace>"
  apply (wpsimp wp: reschedule_cnt simp: test_reschedule_def)
  done

lemma set_tcb_sched_context_wk_valid_sched_action_except_None:
  "\<lbrace>weak_valid_sched_action\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t None
   \<lbrace>\<lambda>_. weak_valid_sched_action_except t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: weak_valid_sched_action_2_def vs_all_heap_simps)

(* FIXME: move, also remove (input) and make sure print translations fire in the right order. *)
abbreviation (input) valid_sched_action_except where
  "valid_sched_action_except S s \<equiv>
    valid_sched_action_2 True S (cur_time s) (scheduler_action s) (cur_thread s) (cur_domain s)
                                (release_queue s) (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
                                (sc_refill_cfgs_of s)"

lemma test_reschedule_valid_sched_action_except:
  "\<lbrace>valid_sched_action_except (insert t S)\<rbrace> test_reschedule t \<lbrace>\<lambda>_. valid_sched_action_except S\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: valid_sched_action_2_def weak_valid_sched_action_def)

lemma test_reschedule_valid_sched_except_wk_sched_action:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked_except_wk_sched_action s
        \<and> valid_blocked s
        \<and> weak_valid_sched_action_except t s
        \<and> pred_map_eq None (tcb_scps_of s) t\<rbrace>
   test_reschedule t
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp simp: valid_sched_def wp: test_reschedule_valid_sched_action_except)
  by (auto simp: valid_sched_action_def weak_valid_sched_action_def )

lemma set_tcb_sc_update_active_sc_tcb_at_None[wp]:
  "\<lbrace>\<top>\<rbrace> set_tcb_obj_ref tcb_sched_context_update t None \<lbrace>\<lambda>rv s. \<not> (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: vs_all_heap_simps)

lemma released_ipc_queues_set_scp_None:
  assumes "released_ipc_queues_2 ctime tcb_sts tcb_scps tcb_faults sc_refill_cfgs"
  shows "released_ipc_queues_2 ctime tcb_sts (tcb_scps(ref \<mapsto> None)) tcb_faults sc_refill_cfgs"
  apply (rule released_ipc_queuesE[OF assms])
  by (auto simp: pred_map_simps opt_map_simps map_join_simps)

lemma sched_context_donate_scheduler_act_not[wp]:
  "sched_context_donate sc_ptr tcb_ptr \<lbrace>scheduler_act_not t\<rbrace>"
  by (wpsimp wp: test_reschedule_sched_act_not_other[where t=t] simp: sched_context_donate_def)

lemma sts_sc_tcb_sc_at_inactive:
  "\<lbrace> \<lambda>s. sc_tcb_sc_at (\<lambda>t. \<forall>a. t = Some a \<longrightarrow> st_tcb_at inactive a s) scp s \<and> inactive ts \<rbrace>
   set_thread_state t ts \<lbrace> \<lambda>rv s. sc_tcb_sc_at (\<lambda>t. \<forall>a. t = Some a \<longrightarrow> st_tcb_at inactive a s) scp s\<rbrace>"
  apply (simp add: set_thread_state_def set_thread_state_act_def set_scheduler_action_def)
  apply (wp dxo_wp_weak set_object_wp | simp add: sc_tcb_sc_at_def)+
  by (clarsimp simp: obj_at_def is_tcb get_tcb_def pred_tcb_at_def)

lemma sc_at_pred_n_state_prop_rewrite:
  "sc_at_pred_n N proj (\<lambda>x. \<forall>y. P x y \<longrightarrow> Q y s) sc s
    \<longleftrightarrow> sc_at_pred_n N (\<lambda>sc. sc) \<top> sc s \<and> (\<forall>y. sc_at_pred_n N proj (\<lambda>x. P x y) sc s \<longrightarrow> Q y s)"
  by (auto simp: sc_at_pred_n_def obj_at_def)

lemma reply_unlink_sc_tcb_tcb_inactive:
  "\<lbrace>\<lambda>s. sc_tcb_sc_at (\<lambda>t. \<forall>a. t = Some a \<longrightarrow> st_tcb_at inactive a s) scp' s\<rbrace>
   reply_unlink_tcb tp rp
   \<lbrace>\<lambda>_ s. sc_tcb_sc_at (\<lambda>t. \<forall>a. t = Some a \<longrightarrow> st_tcb_at inactive a s) scp' s\<rbrace>"
  apply (clarsimp simp: sc_at_pred_n_state_prop_rewrite[where P="\<lambda>to t. to = Some t"]
                        reply_unlink_tcb_def assert_opt_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rule hoare_seq_ext[OF _ assert_sp, OF hoare_gen_asm_conj], clarsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ assert_sp, OF hoare_gen_asm_conj], clarsimp)
  by (erule disjE
      ; wpsimp wp: sts_sc_tcb_sc_at_inactive hoare_vcg_all_lift hoare_vcg_imp_lift'
                   sts_st_tcb_at_cases)

crunches reply_unlink_tcb
for simple_sched_action[wp]: simple_sched_action
  (wp: hoare_drop_imps)

lemma set_simple_ko_is_sc_active[wp]:
  "set_simple_ko f p new \<lbrace>\<lambda>s. P (is_sc_active t s)\<rbrace>"
  apply (clarsimp simp: set_simple_ko_def)
  apply (wpsimp simp: set_object_def wp: get_object_wp split: option.splits)
  by (intro conjI impI; clarsimp elim!: rsubst[where P=P] split: if_splits kernel_object.splits
                                    simp: a_type_def partial_inv_def obj_at_def is_sc_active_def)

crunches set_thread_state_act, update_sk_obj_ref, get_sk_obj_ref
  for is_sc_active[wp]: "\<lambda>s. P (is_sc_active t s)"
  (simp: set_scheduler_action_def)

lemma set_thread_state_is_sc_active[wp]:
  "set_thread_state st tp \<lbrace>\<lambda>s. P (is_sc_active t s)\<rbrace>"
  apply (clarsimp simp: set_thread_state_def)
  apply (wpsimp simp: set_object_def wp: get_object_wp)
  by (clarsimp simp: is_sc_active_def dest!: get_tcb_SomeD)

lemma reply_unlink_sc_is_sc_active[wp]:
  "reply_unlink_sc sp rp \<lbrace>\<lambda>s. P (is_sc_active t s)\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp gts_wp simp: reply_unlink_sc_def)

lemma reply_unlink_tcb_is_sc_active[wp]:
  "reply_unlink_tcb tp rp \<lbrace>\<lambda>s. P (is_sc_active t s)\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp gts_wp simp: reply_unlink_tcb_def)

lemma set_reply_obj_ref_no_tcb_update[wp]:
  "set_reply_obj_ref f rp new \<lbrace>ko_at (TCB tcb) t\<rbrace>"
  apply (clarsimp simp: update_sk_obj_ref_def set_simple_ko_def)
  by (wpsimp simp: set_object_def wp: get_simple_ko_wp get_object_wp simp: obj_at_def)

lemma set_reply_no_tcb_update[wp]:
  "set_reply ptr new \<lbrace>ko_at (TCB tcb) t\<rbrace>"
  apply (clarsimp simp: set_simple_ko_def)
  by (wpsimp simp: set_object_def wp: get_object_wp simp: obj_at_def)

lemma reply_unlink_sc_no_tcb_update[wp]:
  "reply_unlink_sc sp rp \<lbrace>ko_at (TCB tcb) t\<rbrace>"
  apply (simp add: reply_unlink_sc_def)
  by (wpsimp wp: hoare_vcg_imp_lift get_simple_ko_wp)

lemma sts_tcb_ko_at':
  "\<lbrace>\<lambda>s. \<forall>v'. v = (if t = t' then v' \<lparr>tcb_state := ts\<rparr> else v')
              \<and> ko_at (TCB v') t' s \<and> P v\<rbrace>
      set_thread_state t ts
   \<lbrace>\<lambda>rv s. ko_at (TCB v) t' s \<and> P v\<rbrace>"
  apply (simp add: set_thread_state_def)
  apply (wp set_object_wp|simp)+
  apply (clarsimp simp: obj_at_def dest!: get_tcb_SomeD)
  done

lemma set_tcb_obj_ref_reply_at_ppred:
  assumes "\<And>P. set_tcb_obj_ref f t v \<lbrace>\<lambda>s. P (g s)\<rbrace>"
  shows "set_tcb_obj_ref f t v \<lbrace>\<lambda>s. reply_at_ppred proj (P (g s)) rp s\<rbrace>"
  apply (rule hoare_lift_Pf[where f=g, OF _ assms])
  by (wpsimp wp: set_tcb_obj_ref_wp simp: reply_at_ppred_def obj_at_def)

lemmas set_tcb_obj_ref_reply_at_ppred_sched_act[wp]
  = set_tcb_obj_ref_reply_at_ppred[where g=scheduler_action, OF set_tcb_obj_ref_scheduler_action]

lemma update_sched_context_reply_at_ppred:
  assumes "\<And>P. update_sched_context sp f \<lbrace>\<lambda>s. P (g s)\<rbrace>"
  shows "update_sched_context sp f \<lbrace>\<lambda>s. reply_at_ppred proj (P (g s)) rp s\<rbrace>"
  apply (rule hoare_lift_Pf[where f=g, OF _ assms])
  by (wpsimp wp: update_sched_context_wp simp: reply_at_ppred_def obj_at_def)

lemmas update_sched_context_reply_at_ppred_sched_act[wp]
  = update_sched_context_reply_at_ppred[where g=scheduler_action, OF update_sched_context_valid_sched_misc]

crunches tcb_sched_action (* why do we need this? *)
  for reply_tcb_reply_at'[wp]: "reply_tcb_reply_at P s"

lemma reschedule_reply_tcb_reply_at_act_not:
  "reschedule_required \<lbrace>\<lambda>s. reply_tcb_reply_at (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s) rp s\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: reply_tcb_reply_at_def obj_at_def)

lemma test_reschedule_reply_tcb_reply_at_act_not:
  "\<lbrace>\<lambda>s. reply_tcb_reply_at
                (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s)
                rp s\<rbrace> test_reschedule tptr
      \<lbrace>\<lambda>rv s. reply_tcb_reply_at
                (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s)
                rp s\<rbrace>"
  by (wpsimp simp: test_reschedule_def set_object_def
                wp: reschedule_reply_tcb_reply_at_act_not get_object_wp)

lemma tcb_release_remove_reply_tcb_reply_at_act_not:
  "\<lbrace>\<lambda>s. reply_tcb_reply_at
                (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s)
                rp s\<rbrace> tcb_release_remove tptr
      \<lbrace>\<lambda>rv s. reply_tcb_reply_at
                (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s)
                rp s\<rbrace>"
  by (wpsimp simp: tcb_release_remove_def
                wp: reschedule_reply_tcb_reply_at_act_not get_object_wp)

lemma sched_context_donate_reply_tcb_reply_at_act_not:
  "sched_context_donate scp tp \<lbrace>\<lambda>s. reply_tcb_reply_at (\<lambda>p. \<forall>t. p = Some t \<longrightarrow> scheduler_act_not t s) rp s\<rbrace>"
  by (wpsimp wp: set_tcb_queue_wp test_reschedule_reply_tcb_reply_at_act_not
                 tcb_release_remove_reply_tcb_reply_at_act_not
           simp: sched_context_donate_def get_sc_obj_ref_def tcb_sched_action_def)

lemma valid_sched_not_schedulable_sc_not_queued:
  "\<lbrakk>valid_sched s; \<not> schedulable tptr s; tcb_at tptr s\<rbrakk>
     \<Longrightarrow> in_release_queue tptr s \<or> not_queued tptr s"
  by (fastforce simp: schedulable_def obj_at_kh_kheap_simps vs_all_heap_simps is_tcb
                      valid_sched_def valid_ready_qs_def in_ready_q_def
               split: option.splits)

lemma reply_unlink_tcb_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues_2 (cur_time s) (tcb_sts_of s(t \<mapsto> Inactive))
                              (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>
   reply_unlink_tcb t rptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
   unfolding reply_unlink_tcb_def
   by (wpsimp wp: set_thread_state_valid_sched_pred hoare_drop_imps)

lemma reply_unlink_sc_active_reply_scs[wp]:
  "reply_unlink_sc sc_ptr reply_ptr \<lbrace>active_reply_scs\<rbrace>"
  unfolding reply_unlink_sc_def
  apply (rule hoare_seq_ext[OF _ gscrpls_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_if
         ; (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?)+
         ; wpsimp wp: update_sc_replies_valid_sched_pred)
  by (auto simp: obj_at_kh_kheap_simps heap_upd_def vs_all_heap_simps
          split: if_splits elim!: active_reply_scsE)

lemma reply_unlink_sc_valid_sched[wp]:
  "reply_unlink_sc sc_ptr reply_ptr \<lbrace>valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def)

lemma released_ipc_queues_update_state_trivial:
  assumes st: "\<not> ipc_queued_thread_state st"
  assumes sc: "released_ipc_queues_2 ctime sts scps faults scrcs"
  shows "released_ipc_queues_2 ctime (sts(t \<mapsto> st)) scps faults scrcs"
  using assms by (auto elim!: released_ipc_queuesE simp: pred_map_simps is_blocked_thread_state_defs split: if_splits)

lemmas released_ipc_queues_upd_Inactive[simp, elim!]
  = released_ipc_queues_update_state_trivial[where st=Inactive, simplified]

lemma reply_remove_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> ipc_queued_thread tp s\<rbrace>
   reply_remove tp rp
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  supply if_split[split del]
  apply (simp add: reply_remove_def valid_sched_def)
  apply (repeat 3 \<open>rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?\<close>)
  apply (rule_tac hoare_seq_ext
         , wpsimp wp: reply_unlink_tcb_valid_ready_qs reply_unlink_tcb_valid_release_q
                      reply_unlink_tcb_valid_sched_action reply_unlink_tcb_ct_in_cur_domain
                      reply_unlink_tcb_valid_blocked_except_set reply_unlink_tcb_released_ipc_queues)
  apply (case_tac r_sc_opt, wpsimp, clarsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_when_cases; clarsimp)
  apply (wpsimp wp: sched_context_donate_valid_sched_action sched_context_donate_valid_blocked
                    reply_remove_sched_context_donate_released_ipc_queues)
  apply (strengthen valid_sched_not_runnable_not_queued valid_sched_scheduler_act_not_better
                    valid_sched_not_runnable_not_in_release_q released_ipc_queues_except_strengthen)
  by (auto dest: ipc_queued_thread_state_not_runnable simp: valid_sched_def pred_map_simps tcb_at_kh_simps)

\<comment> \<open>The operations that make up cancel_ipc affect valid_sched_pred in similar ways.\<close>
locale set_thread_state_Inactive_valid_sched_pred_equiv =
  fixes f :: "obj_ref \<Rightarrow> ('state_ext::state_ext state, 'a) nondet_monad"
  fixes tptr :: obj_ref
  \<comment> \<open>We can't put sc_replies in here, because we want to use this locale for functions
      that modify that field.\<close>
  assumes valid_sched_pred:
    "\<And>P. \<lbrace>\<lambda>s::'state_ext state.
             P (consumed_time s) (cur_sc s) (sc_tcbs_of s)
               (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
               (if tptr = cur_thread s \<and> scheduler_action s = resume_cur_thread then choose_new_thread else scheduler_action s)
               (etcbs_of s) (tcb_sts_of s(tptr \<mapsto> Inactive)) (tcb_scps_of s)
               (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>
          f tptr
          \<lbrace>\<lambda>rv s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s)
                    (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
                    (scheduler_action s) (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s)
                    (tcb_faults_of s) (sc_refill_cfgs_of s)\<rbrace>"
  assumes non_empty_sc_replies_at[wp]:
    "\<And>scp. f tptr \<lbrace>\<lambda>s::'state_ext state. \<not> non_empty_sc_replies_at scp s\<rbrace>"

context set_thread_state_Inactive_valid_sched_pred_equiv begin

lemmas valid_sched_misc[wp]
  = valid_sched_pred[where P="\<lambda>cons csc tcbs ctime cdom ct it rq rlq _ etcbs _ scps faults scrcs.
                               P cons csc tcbs ctime cdom ct it rq rlq etcbs scps faults scrcs :: bool" for P]

lemma valid_ready_qs:
  "\<lbrace>\<lambda>s::'state_ext state. valid_ready_qs s \<and> \<not> pred_map runnable (tcb_sts_of s) tptr\<rbrace>
   f tptr
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  apply (wpsimp wp: valid_sched_pred)
  by (clarsimp simp: valid_ready_queued_thread_2_def vs_all_heap_simps
              elim!: valid_ready_qsE split: if_splits)

lemma valid_release_q:
  "\<lbrace>\<lambda>s::'state_ext state. valid_release_q s \<and> \<not> pred_map runnable (tcb_sts_of s) tptr\<rbrace>
   f tptr
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  apply (wpsimp wp: valid_sched_pred)
  by (fastforce simp: valid_release_q_def vs_all_heap_simps split: if_splits)

lemma ct_not_in_q[wp]:
  "f tptr \<lbrace>ct_not_in_q::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_pred)

lemma valid_sched_action:
  "\<lbrace>\<lambda>s::'state_ext state. valid_sched_action s \<and> \<not> pred_map runnable (tcb_sts_of s) tptr\<rbrace>
   f tptr
   \<lbrace>\<lambda>rv. valid_sched_action\<rbrace>"
  apply (wpsimp wp: valid_sched_pred)
  by (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                      is_activatable_def
               split: if_splits)

lemma ct_in_cur_domain[wp]:
  "f tptr \<lbrace>ct_in_cur_domain::'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: valid_sched_pred)

lemma valid_blocked_tcb_at[wp]:
  "\<lbrace>\<lambda>s::'state_ext state. t' \<noteq> tptr \<longrightarrow> valid_blocked_tcb_at t' s\<rbrace>
   f tptr
   \<lbrace>\<lambda>_. valid_blocked_tcb_at t'\<rbrace>"
  apply (wpsimp wp: valid_sched_pred)
  by (clarsimp simp: valid_blocked_thread_def vs_all_heap_simps)

lemma valid_blocked[wp]:
  "\<lbrace>valid_blocked_except_set (insert tptr S)::'state_ext state \<Rightarrow> _\<rbrace>
   f tptr
   \<lbrace>\<lambda>_. valid_blocked_except_set S::'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (wpsimp wp: valid_sched_pred)
  by (erule valid_blockedE'; case_tac "t=tptr"; clarsimp simp: vs_all_heap_simps)

lemma active_reply_scs[wp]:
  "f tptr \<lbrace>active_reply_scs::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding active_reply_scs_defs
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')

lemmas valid_sched_lemmas
  = valid_ready_qs valid_release_q valid_sched_action
    valid_sched_pred[where P="\<lambda>cons csc tcbs ctime cdom ct it rq rlq sa etcbs sts scps faults scrcs.
                                released_ipc_queues_2 ctime sts scps faults scrcs"]

lemma valid_sched:
  "\<lbrace>\<lambda>s::'state_ext state.
        valid_ready_qs s
        \<and> valid_release_q s
        \<and> ready_or_release s
        \<and> ct_not_in_q s
        \<and> valid_sched_action s
        \<and> ct_in_cur_domain s
        \<and> valid_blocked_except tptr s
        \<and> valid_idle_etcb s
        \<and> released_ipc_queues_2 (cur_time s) (tcb_sts_of s(tptr \<mapsto> Inactive)) (tcb_scps_of s)
                                   (tcb_faults_of s) (sc_refill_cfgs_of s)
        \<and> active_reply_scs s
        \<and> active_sc_valid_refills s
        \<and> \<not> pred_map runnable (tcb_sts_of s) tptr\<rbrace>
   f tptr
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp wp: valid_sched_lemmas simp: valid_sched_def)

lemma valid_sched_except_blocked:
  "\<lbrace>\<lambda>s::'state_ext state.
        valid_ready_qs s
        \<and> valid_release_q s
        \<and> ready_or_release s
        \<and> ct_not_in_q s
        \<and> valid_sched_action s
        \<and> ct_in_cur_domain s
        \<and> valid_idle_etcb s
        \<and> released_ipc_queues_2 (cur_time s) (tcb_sts_of s(tptr \<mapsto> Inactive)) (tcb_scps_of s)
                                   (tcb_faults_of s) (sc_refill_cfgs_of s)
        \<and> active_reply_scs s
        \<and> active_sc_valid_refills s
        \<and> \<not> pred_map runnable (tcb_sts_of s) tptr\<rbrace>
   f tptr
   \<lbrace>\<lambda>rv. valid_sched_except_blocked\<rbrace>"
  by (wpsimp wp: valid_sched_lemmas simp: valid_sched_def)

end

global_interpretation set_thread_state_Inactive:
  set_thread_state_Inactive_valid_sched_pred_equiv "\<lambda>t. set_thread_state t Inactive"
  by unfold_locales (wpsimp wp: set_thread_state_valid_sched_pred_strong simp: fun_upd_def)+

global_interpretation reply_unlink_tcb: set_thread_state_Inactive_valid_sched_pred_equiv "\<lambda>t. reply_unlink_tcb t r"
  by unfold_locales (wpsimp wp: reply_unlink_tcb_valid_sched valid_sched_wp simp: fun_upd_def)+

lemma reply_remove_tcb_non_empty_sc_replies_at[wp]:
  "reply_remove_tcb t r \<lbrace>\<lambda>s. \<not> non_empty_sc_replies_at scp s\<rbrace>"
  unfolding reply_remove_tcb_def
  apply (wpsimp wp: update_sc_replies_valid_sched_pred get_sk_obj_ref_wp gts_wp)
  by (auto simp: heap_upd_def vs_all_heap_simps)

global_interpretation reply_remove_tcb: set_thread_state_Inactive_valid_sched_pred_equiv "\<lambda>t. reply_remove_tcb t r"
  apply unfold_locales
   prefer 2 subgoal by wp
  unfolding reply_remove_tcb_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ assert_sp], rule hoare_gen_asm_conj)
  apply (clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext_skip
         , solves \<open>wpsimp wp: hoare_drop_imps
                        simp: obj_at_kh_kheap_simps vs_all_heap_simps fun_upd_def\<close>)+
  by (wpsimp wp: reply_unlink_tcb_valid_sched_pred simp: fun_upd_def)

lemma unbind_maybe_notification_valid_sched[wp]:
  "unbind_maybe_notification ptr \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: get_sk_obj_ref_wp simp: unbind_maybe_notification_def)

global_interpretation cancel_signal: set_thread_state_Inactive_valid_sched_pred_equiv "\<lambda>t. cancel_signal t ntfn"
  apply unfold_locales
  unfolding cancel_signal_def
  supply if_split[split del]
  apply (rule hoare_seq_ext_skip, solves wpsimp, simp?)+
  by (wpsimp wp: set_thread_state_Inactive.valid_sched_pred get_simple_ko_wp simp: fun_upd_def)+

crunch st_tcb_at_not_runnable[wp]: reply_remove_tcb "st_tcb_at (\<lambda>st. \<not>runnable st) t"
  (wp: crunch_wps select_wp sts_st_tcb_at_cases thread_set_no_change_tcb_state maybeM_inv
   simp: crunch_simps unless_def wp_del: reply_remove_st_tcb_at)

lemma reply_remove_tcb_not_runnable[wp]:
  "reply_unlink_tcb t r \<lbrace>\<lambda>s. \<not> pred_map runnable (tcb_sts_of s) t\<rbrace>"
  by (wpsimp wp: reply_unlink_tcb_valid_sched_pred simp: vs_all_heap_simps)

global_interpretation blocked_cancel_ipc:
  set_thread_state_Inactive_valid_sched_pred_equiv "\<lambda>t. blocked_cancel_ipc st t r"
  apply unfold_locales
  unfolding blocked_cancel_ipc_def
  subgoal for P
    supply if_split[split del]
    apply (rule hoare_seq_ext_skip, solves wpsimp, simp?)+
    apply (cases r; simp add: bind_assoc; thin_tac _)
     apply (wpsimp wp: set_thread_state_valid_sched_pred_strong simp: fun_upd_def)
    apply (wpsimp wp: set_thread_state_valid_sched_pred_strong
                      reply_unlink_tcb_valid_sched_pred_lift[THEN hoare_drop_assertion])
    apply (clarsimp simp: fun_upd_def split: if_splits)
    done
  apply (wpsimp wp: hoare_drop_imp simp: blocked_cancel_ipc_def)
  done

lemmas cancel_ipc_valid_sched_lemmas
  = reply_remove_tcb.valid_sched
    cancel_signal.valid_sched
    blocked_cancel_ipc.valid_sched

lemma get_tcb_after_put[simp]:
  "get_tcb t (kheap_update (\<lambda>kh. kh(t \<mapsto> TCB tcb)) s) = Some tcb"
  by (simp add: get_tcb_def)

crunches sched_context_unbind_yield_from
  for valid_sched[wp]: "valid_sched_pred_strong P"
  (wp: maybeM_inv mapM_x_wp')

lemma sched_context_unbind_ntfn_valid_sched[wp]:
  "sched_context_unbind_ntfn scptr \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: get_sc_obj_ref_wp simp: sched_context_unbind_ntfn_def)

lemma sched_context_maybe_unbind_ntfn_valid_sched[wp]:
  "sched_context_maybe_unbind_ntfn scptr \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (wpsimp wp: get_sk_obj_ref_wp simp: sched_context_maybe_unbind_ntfn_def)

(* FIXME: Move *)
lemma sym_ref_tcb_reply_Receive:
   "\<lbrakk> sym_refs (state_refs_of s); kheap s tp = Some (TCB tcb);
   tcb_state tcb = BlockedOnReceive ep (Some rp) pl \<rbrakk> \<Longrightarrow>
  \<exists>reply. kheap s rp = Some (Reply reply) \<and> reply_tcb reply = Some tp"
  apply (drule sym_refs_obj_atD[rotated, where p=tp])
   apply (clarsimp simp: obj_at_def, simp)
  apply (clarsimp simp: state_refs_of_def get_refs_def2 elim!: sym_refsE)
  apply (drule_tac x="(rp, TCBReply)" in bspec)
   apply fastforce
  apply (clarsimp simp: obj_at_def)
  apply (case_tac koa; clarsimp simp: get_refs_def2)
  done

lemma thread_set_fault_valid_sched_pred:
  "\<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (last_machine_time_of s) (time_state_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (heap_upd f tptr (tcb_faults_of s))
          (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>
   thread_set (tcb_fault_update f) tptr
   \<lbrace>\<lambda>rv. valid_sched_pred_strong P\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  by (auto simp: heap_upd_def fun_upd_def obj_at_kh_kheap_simps vs_all_heap_simps
          elim!: rsubst[of "\<lambda>t::obj_ref \<rightharpoonup> fault option. P _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ t _ _ :: bool"]
          split: if_splits)

lemmas thread_set_fault_valid_sched_misc[wp]
  = thread_set_fault_valid_sched_pred[where P="\<lambda>cons csc ep_send_qs ep_recv_qs tcbs lmt ts ctime cdom ct it qs rq sa etcbs sts scps _ scrcs reps.
                                                P cons csc ep_send_qs ep_recv_qs tcbs lmt ts ctime cdom ct it qs rq sa etcbs sts scps scrcs reps :: bool" for P]

lemma cancel_ipc_valid_sched[wp]:
  "cancel_ipc tptr \<lbrace>valid_sched\<rbrace>"
  unfolding cancel_ipc_def
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule_tac B="\<lambda>rv s. pred_map_eq state (tcb_sts_of s) tptr
                            \<and> valid_ready_qs s
                            \<and> valid_release_q s
                            \<and> ready_or_release s
                            \<and> ct_not_in_q s
                            \<and> valid_sched_action s
                            \<and> ct_in_cur_domain s
                            \<and> valid_blocked s
                            \<and> valid_idle_etcb s
                            \<and> released_ipc_queues_2 (cur_time s) (tcb_sts_of s(tptr \<mapsto> Inactive)) (tcb_scps_of s)
                                                       (tcb_faults_of s) (sc_refill_cfgs_of s)
                            \<and> active_reply_scs s
                            \<and> active_sc_valid_refills s" in hoare_seq_ext)
   apply (wpsimp wp: cancel_ipc_valid_sched_lemmas)
   apply (prop_tac "\<not> ipc_queued_thread_state state \<Longrightarrow> valid_sched s")
    apply (fastforce simp: valid_sched_def vs_all_heap_simps runnable_eq fun_upd_def
                           is_blocked_thread_state_defs
                    split: if_splits elim!: released_ipc_queuesE)
   apply (prop_tac "ipc_queued_thread_state state \<Longrightarrow> \<not> pred_map runnable (tcb_sts_of s) tptr")
    apply (rule ccontr; fastforce simp: vs_all_heap_simps runnable_eq)
   apply fastforce
  apply (wpsimp wp: thread_set_fault_valid_sched_pred simp: valid_sched_def)
  apply (clarsimp simp: vs_all_heap_simps is_blocked_thread_state_defs heap_upd_def
                 split: if_splits elim!: released_ipc_queuesE)
  done

lemma possible_switch_to_ct_in_cur_domain[wp]:
  "possible_switch_to target \<lbrace>ct_in_cur_domain\<rbrace>"
  unfolding possible_switch_to_def set_scheduler_action_def
  by (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')

lemma possible_switch_to_not_cur_thread[wp]:
  "possible_switch_to tptr \<lbrace>not_cur_thread t\<rbrace>"
  by (wpsimp wp: valid_sched_wp thread_get_wp' get_tcb_obj_ref_wp
           simp: possible_switch_to_def)

crunch simple[wp]: reply_remove simple_sched_action
  (simp: a_type_def wp: hoare_drop_imps)

lemma sched_context_unbind_tcb_simple_sched_action[wp]:
  "sched_context_unbind_tcb sc_ptr \<lbrace>simple_sched_action\<rbrace>"
  "sched_context_unbind_tcb sc_ptr \<lbrace>scheduler_act_sane\<rbrace>"
  by (wpsimp simp: sched_context_unbind_tcb_def wp: get_sched_context_wp)+

crunches unbind_from_sc, sched_context_unbind_all_tcbs
  for simple[wp]: simple_sched_action
  and scheduler_act_sane[wp]: scheduler_act_sane
  (wp: maybeM_wp crunch_wps hoare_vcg_all_lift)

crunch scheduler_act_not[wp]: unbind_from_sc "scheduler_act_not t"
  (wp: crunch_wps hoare_vcg_all_lift simp: crunch_simps)

crunches cancel_ipc
for simple_sched_action[wp]: simple_sched_action
and scheduler_act_sane[wp]: scheduler_act_sane
and scheduler_act_not[wp]: "scheduler_act_not t"
  (wp: maybeM_wp hoare_drop_imps)

lemma cancel_ipc_not_queued[wp]:
  "\<lbrace>not_queued t\<rbrace> cancel_ipc tptr \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (clarsimp simp: cancel_ipc_def)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (case_tac state; wpsimp)
  done

lemma distinct_zip_snd_unique:
  "\<lbrakk>distinct xs; (a, b) \<in> set (zip xs ys); (a, b') \<in> set (zip xs ys)\<rbrakk>
     \<Longrightarrow> b = b'"
  apply (induct xs arbitrary: ys, simp)
  apply (clarsimp simp: zip_Cons1)
  apply (erule disjE, fastforce dest!: in_set_zipE)
  apply (erule disjE, fastforce dest!: in_set_zipE, clarsimp)
  done

lemma set_insort_filter_insert:
  "set (insort_filter P x xs) = insert x (set xs)"
  by (auto simp: insort_filter_def)

lemma set_tcb_release_enqueue_upd_insert:
  "set (tcb_release_enqueue_upd ready_times t queue) = insert t (set queue)"
  by (simp add: tcb_release_enqueue_upd_def set_insort_filter_insert)

lemma distinct_filter_iff:
  "distinct xs \<longleftrightarrow> distinct (filter P xs) \<and> distinct (filter (Not \<circ> P) xs)"
proof (induct xs)
  case (Cons x xs) show ?case
    apply (cases "x \<in> set xs"; simp)
    by (rule Cons[simplified comp_def])
qed auto

lemma distinct_insort_filter:
  "distinct (insort_filter P x xs) \<longleftrightarrow> x \<notin> set xs \<and> distinct xs"
  by (auto simp: insort_filter_def distinct_filter_iff[where xs=xs and P=P, simplified comp_def]
           simp del: distinct_filter)

lemma distinct_tcb_release_enqueue_upd:
  "distinct (tcb_release_enqueue_upd ready_times t queue) \<longleftrightarrow> \<not> in_queue_2 queue t \<and> distinct queue"
  by (simp add: tcb_release_enqueue_upd_def distinct_insort_filter in_queue_2_def)

lemma tcb_release_enqueue_in_release_q[wp]:
  "\<lbrace>\<top>\<rbrace> tcb_release_enqueue tcbptr \<lbrace>\<lambda>ya. in_release_q tcbptr\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: in_queue_2_def set_tcb_release_enqueue_upd_insert)

(* FIXME move *)
lemma valid_release_q_active_sc:
  "valid_release_q s \<Longrightarrow> t \<in> set (release_queue s) \<Longrightarrow> active_sc_tcb_at t s"
  by (clarsimp simp: valid_release_q_def)

lemma insort_filter_cong:
  assumes xs: "x = y" "xs = ys"
  assumes P: "\<And>x. x \<in> set ys \<Longrightarrow> P x \<longleftrightarrow> Q x"
  shows "insort_filter P x xs = insort_filter Q y ys"
  unfolding insort_filter_def
  apply (intro arg_cong2[where f=append] arg_cong2[where f=Cons] filter_cong xs)
  by (auto simp: P)

lemma tcb_release_enqueue_upd_def2:
  assumes "\<forall>x \<in> set (t # queue). \<exists>y. hp x = Some y"
  shows "tcb_release_enqueue_upd hp t queue = insort_filter (\<lambda>t'. img_ord hp opt_ord t' t) t queue"
  using assms by (auto simp: tcb_release_enqueue_upd_def img_ord_def intro!: insort_filter_cong)

lemma sc_ready_times_2_Some:
  "hp t = Some scrc \<Longrightarrow> sc_ready_times_2 hp t = Some (sc_ready_time scrc)"
  by (simp add: sc_ready_times_2_def map_project_simps)

lemma transp_img_ord:
  "transp cmp \<Longrightarrow> transp (img_ord f cmp)"
  unfolding transp_def img_ord_def by blast

lemma transp_opt_ord:
  "transp (opt_ord :: ('a::preorder) option \<Rightarrow> 'a option \<Rightarrow> bool)"
  apply (clarsimp simp: transp_def)
  by (case_tac x; case_tac y; case_tac z; clarsimp elim!: order_trans)

lemma reflp_img_ord:
  "reflp cmp \<Longrightarrow> reflp (img_ord f cmp)"
  unfolding reflp_def img_ord_def by blast

lemma reflp_opt_ord:
  "reflp (opt_ord :: ('a::preorder) option \<Rightarrow> 'a option \<Rightarrow> bool)"
  apply (clarsimp simp: reflp_def)
  by (case_tac x; clarsimp)

lemma total_img_ord:
  "\<lbrakk>total {(x,y). cmp x y}; reflp cmp\<rbrakk> \<Longrightarrow> total {(x,y). img_ord f cmp x y}"
  apply (clarsimp simp: total_on_def reflp_def img_ord_def)
  by (drule_tac x="f x" in spec; drule_tac x="f y" in spec; fastforce)

lemma total_opt_ord:
  "total {(x :: ('a::linorder) option, y). opt_ord x y}"
  apply (clarsimp simp: total_on_def)
  apply (case_tac x; case_tac y)
  by (auto simp: linear)

lemma sorted_tcb_release_enqueue_upd:
  assumes "sorted_release_q_2 hp queue"
  assumes "\<forall>x \<in> set (t # queue). \<exists>y. hp x = Some y"
  shows "sorted_release_q_2 hp (tcb_release_enqueue_upd (sc_ready_times_2 hp) t queue)"
  using assms
  apply (clarsimp simp add: sorted_release_q_2_def)
  apply (subst tcb_release_enqueue_upd_def2, fastforce simp add: sc_ready_times_2_Some)
  by (erule sorted_insort_filter[where cmp="img_ord (sc_ready_times_2 hp) opt_ord" and xs=queue, rotated 3]
      ; intro transp_img_ord reflp_img_ord total_img_ord transp_opt_ord reflp_opt_ord total_opt_ord)

lemma tcb_release_enqueue_valid_release_q[wp]:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> active_sc_tcb_at t s \<and> pred_map runnable (tcb_sts_of s) t \<and> not_in_release_q t s\<rbrace>
   tcb_release_enqueue t
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (wpsimp wp: valid_sched_wp
              simp: valid_release_q_def set_tcb_release_enqueue_upd_insert
                    distinct_tcb_release_enqueue_upd)
  apply (erule sorted_tcb_release_enqueue_upd)
  by (auto simp: tcb_sc_refill_cfgs_2_def opt_map_simps map_join_simps vs_all_heap_simps)

lemma tcb_release_enqueue_weak_valid_sched_action[wp]:
  "\<lbrace>weak_valid_sched_action and scheduler_act_not tptr\<rbrace>
   tcb_release_enqueue tptr
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  unfolding tcb_release_enqueue_def
  apply (rule hoare_seq_ext[OF _ get_sc_time_sp'])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ mapM_get_sc_time_sp'])
  apply wpsimp
  by (fastforce simp: weak_valid_sched_action_def scheduler_act_not_def dest!: in_set_zip1)

lemma tcb_release_enqueue_valid_sched_action[wp]:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> scheduler_act_not thread s\<rbrace>
   tcb_release_enqueue thread
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto simp: valid_sched_action_def weak_valid_sched_action_def scheduler_act_not_def
                 tcb_release_enqueue_upd_def insort_filter_def)

lemma tcb_release_enqueue_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set (insert tcb_ptr S)\<rbrace>
   tcb_release_enqueue tcb_ptr
   \<lbrace>\<lambda>xa. valid_blocked_except_set S\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (auto elim!: valid_blockedE' simp: in_queue_2_def tcb_release_enqueue_upd_def insort_filter_def)

lemma set_map_fst_filter_zip:
  "set (map fst (filter P (zip xs ys))) \<subseteq> set xs"
  apply (induct xs, simp)
  apply (case_tac ys; simp)
  by (metis (mono_tags, lifting) image_Collect_subsetI insertI2 set_zip_helper)

lemma tcb_release_enqueue_not_in_release_q_other[wp]:
  "\<lbrace>K (t \<noteq> t') and not_in_release_q t'\<rbrace>
   tcb_release_enqueue t
   \<lbrace>\<lambda>_. not_in_release_q t'\<rbrace>"
  unfolding tcb_release_enqueue_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: mapM_wp_inv)
  apply wpsimp
  apply (simp add: not_in_release_q_def in_release_q_def in_queue_2_def)
  using set_map_fst_filter_zip by fastforce

lemma tcb_release_enqueue_ready_or_release[wp]:
  "\<lbrace>ready_or_release and not_queued t\<rbrace>
   tcb_release_enqueue t
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  unfolding ready_or_release_2_def pred_conj_def
  apply (rule_tac Q="\<lambda>x. (\<forall>t'. \<not> (in_ready_q t' x \<and> in_release_q t' x) \<and> not_queued t x)"
               in hoare_weaken_pre[rotated], simp)
  apply (rule hoare_vcg_all_lift)
  apply (simp only: de_Morgan_conj)
  apply (case_tac "t = t'")
   apply (rule hoare_weaken_pre)
    apply (rule hoare_post_disjI1[simplified pred_disj_def])
    apply wpsimp
   apply blast
  apply (rule_tac Q="\<lambda>s. not_queued t' s \<or> not_in_release_q t' s" in hoare_weaken_pre)
   apply (rule hoare_vcg_disj_lift)
    apply wpsimp+
  done

lemma tcb_release_enqueue_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
        \<and> not_queued thread s
        \<and> not_in_release_q thread s
        \<and> scheduler_act_not thread s
        \<and> pred_map runnable (tcb_sts_of s) thread
        \<and> active_sc_tcb_at thread s\<rbrace>
   tcb_release_enqueue thread
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  by (wpsimp simp: valid_sched_def)

lemma tcb_release_enqueue_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
        \<and> valid_blocked_except thread s
        \<and> not_queued thread s
        \<and> not_in_release_q thread s
        \<and> scheduler_act_not thread s
        \<and> pred_map runnable (tcb_sts_of s) thread
        \<and> active_sc_tcb_at thread s\<rbrace>
   tcb_release_enqueue thread
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: tcb_release_enqueue_valid_blocked_except_set simp: valid_sched_def)

lemma valid_blocked_thread_lift_except:
  "valid_blocked_thread nq nr S qs rq sa ct sts scps cfgs t
   \<longleftrightarrow> (t \<notin> S \<longrightarrow> valid_blocked_thread nq nr {} qs rq sa ct sts scps cfgs t)"
  by (auto simp: valid_blocked_thread_def)

lemma valid_blocked_divided_except_set:
  "valid_blocked_except_set_2 except queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs
   \<longleftrightarrow> valid_blocked_except_set_2 (S \<union> except) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs
       \<and> valid_blocked_except_set_2 (- S \<union> except) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  by (auto simp add: valid_blocked_defs)

lemma valid_blocked_divided_threadsE:
  assumes "valid_blocked_except_set_2 (I \<union> S) queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  assumes " \<forall>t \<in> I. valid_blocked_thread id id {} queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs t"
  shows "valid_blocked_except_set_2 S queues rlq sa ct tcb_sts tcb_scps sc_refill_cfgs"
  apply (rule valid_blocked_divided_except_set[THEN iffD2], rule conjI, rule assms)
  by (clarsimp simp: valid_blocked_except_set_2_def[where except="-I \<union> S"]
                     valid_blocked_thread_lift_except[where S="-I \<union> S"]
                     assms)

lemmas valid_blocked_divided_threadE
  = valid_blocked_divided_threadsE[where I="{t}", simplified] for t

lemma test_possible_switch_to_valid_sched:
  "\<lbrace>\<lambda>s. if pred_map runnable (tcb_sts_of s) target \<and> active_sc_tcb_at target s \<and> not_in_release_q target s
        then valid_sched_except_blocked s \<and> valid_blocked_except target s
              \<and> target \<noteq> idle_thread s \<and> budget_ready target s \<and> budget_sufficient target s
        else valid_sched s\<rbrace>
   test_possible_switch_to target
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: possible_switch_to_valid_sched_strong is_schedulable_wp'
              simp: test_possible_switch_to_def)
  by (auto simp: vs_all_heap_simps)

(* sc_ptr is linked to a thread that is not in any queue *)
lemma postpone_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
        \<and> (\<forall>tp. pred_map_eq (Some tp) (sc_tcbs_of s) sc_ptr
                \<longrightarrow> valid_blocked_except tp s \<and> pred_map runnable (tcb_sts_of s) tp
                    \<and> scheduler_act_not tp s \<and> not_in_release_q tp s
                    \<and> active_sc_tcb_at tp s)\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: tcb_release_enqueue_valid_sched
                    tcb_dequeue_not_queued
                    tcb_sched_dequeue_valid_sched_except_blocked
                    tcb_sched_dequeue_valid_blocked_except_set
                    get_sc_obj_ref_wp)
  by (clarsimp simp: valid_sched_def obj_at_def pred_map_eq_def vs_all_heap_simps
              dest!: valid_ready_qs_etcb_eq)

lemma postpone_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
        \<and> (\<forall>tp. pred_map_eq (Some tp) (sc_tcbs_of s) sc_ptr
                \<longrightarrow> pred_map runnable (tcb_sts_of s) tp \<and> scheduler_act_not tp s
                    \<and> not_in_release_q tp s \<and> active_sc_tcb_at tp s)\<rbrace>
    postpone sc_ptr
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (unfold postpone_def assert_opt_def)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (wpsimp wp: tcb_release_enqueue_valid_sched_except_blocked
            tcb_sched_dequeue_valid_blocked_except_set
            tcb_dequeue_not_queued
            tcb_sched_dequeue_valid_ready_qs
            tcb_sched_dequeue_valid_sched_except_blocked)
  by (clarsimp simp: valid_sched_def pred_map_eq_def sc_at_kh_simps
              dest!: valid_ready_qs_etcb_eq)

lemma postpone_valid_ready_qs:
  "\<lbrace>valid_ready_qs \<rbrace>
     postpone sc_ptr
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding postpone_def
  by (wpsimp wp: tcb_sched_dequeue_valid_ready_qs get_sc_obj_ref_wp)

lemma postpone_weak_valid_sched_action[wp]:
  "\<lbrace>weak_valid_sched_action and (\<lambda>s. \<forall>tp. sc_tcb_sc_at ((=) (Some tp)) scp s \<longrightarrow> scheduler_act_not tp s)\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  unfolding postpone_def
  by (wpsimp wp: get_sc_obj_ref_wp) (clarsimp simp: obj_at_def sc_tcb_sc_at_def)

lemma postpone_valid_sched_action:
  "\<lbrace>valid_sched_action and (\<lambda>s. \<forall>tp. sc_tcb_sc_at ((=) (Some tp)) scp s \<longrightarrow> scheduler_act_not tp s)\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  unfolding postpone_def
  by (wpsimp wp: get_sc_obj_ref_wp) (clarsimp simp: obj_at_def sc_tcb_sc_at_def)

lemma postpone_valid_release_q:
  "\<lbrace> valid_release_q and
     (\<lambda>s. \<forall> tp. sc_tcb_sc_at ((=) (Some tp)) sc_ptr s \<longrightarrow>
     pred_map runnable (tcb_sts_of s) tp
      \<and> not_in_release_q tp s \<and> active_sc_tcb_at tp s)\<rbrace>
     postpone sc_ptr
   \<lbrace> \<lambda>_. valid_release_q \<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: tcb_release_enqueue_valid_release_q get_sc_obj_ref_wp)
  by (clarsimp simp: sc_tcb_sc_at_def obj_at_def )

crunches sched_context_resume
  for valid_ready_qs[wp]: valid_ready_qs
  and released_ipc_queues[wp]: released_ipc_queues
  (wp: crunch_wps)

lemma sched_context_resume_valid_release_q[wp]:
  "\<lbrace>valid_release_q\<rbrace>
   sched_context_resume sc_ptr_opt
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding sched_context_resume_def
  apply (wpsimp wp: postpone_valid_release_q is_schedulable_wp
              simp: thread_get_def)
  by (clarsimp simp: sc_tcb_sc_at_def schedulable_def obj_at_def
                     is_sc_active_kh_simp vs_all_heap_simps
              dest!: get_tcb_SomeD split: option.splits)

lemma sched_context_resume_weak_valid_sched_action[wp]:
  "\<lbrace>weak_valid_sched_action and (\<lambda>s. \<forall>tp. sc_tcb_sc_at ((=) (Some tp)) scp s \<longrightarrow> scheduler_act_not tp s)\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  unfolding sched_context_resume_def
  by (wpsimp wp: postpone_valid_sched_action is_schedulable_wp
           simp: thread_get_def)

lemma sched_context_resume_valid_sched_action:
  "\<lbrace>valid_sched_action and (\<lambda>s. \<forall>y. sc_tcb_sc_at ((=) (Some y)) sc_ptr s \<longrightarrow> scheduler_act_not y s)\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace> "
  unfolding sched_context_resume_def
  apply (wpsimp wp: postpone_valid_sched_action thread_get_wp is_schedulable_wp)
  by (fastforce simp: obj_at_def schedulable_def is_tcb
               dest!: get_tcb_SomeD split: option.splits)

lemma weak_valid_sched_action_contrap:
  "weak_valid_sched_action s \<Longrightarrow> (simple_sched_action s \<or>
     \<not> pred_map runnable (tcb_sts_of s) ref \<or> \<not> released_sc_tcb_at ref s \<or>
     in_release_queue ref s) \<Longrightarrow> scheduler_act_not ref s"
  by (clarsimp simp: weak_valid_sched_action_def scheduler_act_not_def simple_sched_action_def in_release_queue_def)

lemma valid_ready_qs_contrap:
  "valid_ready_qs s
   \<Longrightarrow> (\<not> pred_map runnable (tcb_sts_of s) ref \<or> \<not> released_sc_tcb_at ref s) \<Longrightarrow> not_queued ref s"
  by (clarsimp simp: valid_ready_qs_def in_ready_q_def)

lemma sched_context_resume_valid_sched_except_blocked:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s \<and> heap_refs_retract_at (sc_tcbs_of s) (tcb_scps_of s) scp\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_. valid_sched_except_blocked\<rbrace>"
  apply (wpsimp wp: postpone_valid_sched_except_blocked is_schedulable_wp' get_tcb_queue_wp thread_get_wp'
              simp: sched_context_resume_def get_refills_def)
  apply (clarsimp simp: obj_at_def)
  apply (rename_tac y tcb tp; prop_tac "heap_ref_eq y scp (sc_tcbs_of s)")
   apply (clarsimp simp: vs_all_heap_simps)
  apply (frule (1) heap_refs_retract_atD, clarsimp simp: vs_all_heap_simps valid_sched_def)
  apply (prop_tac "\<not> released_sc_tcb_at tp s")
   apply (clarsimp simp: released_sc_tcb_at_def)
   apply (drule_tac tp1=tp and scp=scp in valid_refills_refill_sufficient[OF active_sc_tcb_at_valid_refills])
     apply (clarsimp simp: vs_all_heap_simps)
    apply (clarsimp simp: pred_tcb_at_def obj_at_def)
   apply (clarsimp simp: vs_all_heap_simps)
  by (auto elim!: weak_valid_sched_action_contrap[OF valid_sched_action_weak_valid_sched_action])

(* FIXME RT: duplicates proof in sched_context_resume_valid_sched_except_blocked,
             because we're missing proofs about sched_context_resume and valid_blocked. *)
lemma sched_context_resume_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> heap_refs_retract_at (sc_tcbs_of s) (tcb_scps_of s) scp\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (wpsimp wp: postpone_valid_sched is_schedulable_wp' get_tcb_queue_wp thread_get_wp'
              simp: sched_context_resume_def get_refills_def)
  apply (clarsimp simp: valid_sched_def sc_at_pred_n_def get_tcb_ko_at obj_at_def)
  apply (frule (1) heap_refs_retract_atD, clarsimp simp: vs_all_heap_simps)
  apply (prop_tac "\<not> released_sc_tcb_at tp s")
   apply (clarsimp simp: released_sc_tcb_at_def)
   apply (drule_tac tp1=tp and scp=scp in valid_refills_refill_sufficient[OF active_sc_tcb_at_valid_refills])
     apply (clarsimp simp: vs_all_heap_simps)
    apply (clarsimp simp: pred_tcb_at_def obj_at_def)
   apply (clarsimp simp: vs_all_heap_simps)
  by (auto elim!: weak_valid_sched_action_contrap[OF valid_sched_action_weak_valid_sched_action])

lemma postpone_valid_blocked_except_set:
  "postpone sc_ptr \<lbrace>valid_blocked_except_set S\<rbrace>"
  apply (unfold postpone_def assert_opt_def)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (case_tac tcb_opt; clarsimp)
  apply (rename_tac tptr)
  by (wpsimp wp: tcb_release_enqueue_valid_blocked_except_set tcb_sched_dequeue_valid_blocked_except_set)

crunches sched_context_resume
  for not_cur_thread[wp]: "not_cur_thread t"
  and bound_sc_obj_tcb_at[wp]: "\<lambda>s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s)"
  and valid_blocked_except_set[wp]: "valid_blocked_except_set S"
  and not_cur_thread'[wp]: "\<lambda>s. P (not_cur_thread t s)"
    (wp: crunch_wps)

lemmas sched_context_resume_valid_blocked = sched_context_resume_valid_blocked_except_set
             [of "{}", simplified]

crunch simple[wp]: suspend,sched_context_unbind_ntfn simple_sched_action
  (wp: maybeM_wp hoare_drop_imps)

lemma in_set_tcb_sched_dequeue:
  "t \<in> set (tcb_sched_dequeue k (ready_queues s a b)) \<Longrightarrow>
   t \<in> set (ready_queues s a b) \<and> t \<noteq> k"
 by (auto simp: tcb_sched_dequeue_def)

lemma set_thread_state_not_active_helper:
  "\<lbrace>\<lambda>s. \<not> active k\<rbrace> set_thread_state t k \<lbrace>\<lambda>rv s. (st_tcb_at active t s \<longrightarrow> \<not> active_sc_tcb_at t s)\<rbrace>"
  apply (rule hoare_strengthen_post[where Q="\<lambda>rv s. (\<not>st_tcb_at active t s)"])
  apply (wpsimp simp: set_thread_state_def wp: set_object_wp)
  apply (clarsimp simp: st_tcb_at_def obj_at_def)+
  done

(* FIXME maybe move? *)
lemma weak_valid_sched_action_st_prop:
  "\<lbrakk>weak_valid_sched_action s; scheduler_action s = switch_thread t\<rbrakk> \<Longrightarrow>
       pred_map runnable (tcb_sts_of s) t \<and> released_sc_tcb_at t s"
  by (clarsimp simp: weak_valid_sched_action_def)

crunch not_in_release_q[wp]: cancel_ipc "not_in_release_q t"
  (simp: crunch_simps  wp: crunch_wps tcb_release_remove_not_in_release_q)

crunches cancel_ipc
  for ready_or_release[wp]: "ready_or_release"
  (wp: hoare_drop_imps)

lemma suspend_ready_or_release[wp]:
  "suspend t \<lbrace>ready_or_release\<rbrace>"
  unfolding suspend_def
  by (wpsimp wp: hoare_drop_imps simp: update_restart_pc_def sched_context_cancel_yield_to_def)

crunches sched_context_cancel_yield_to
  for ready_or_release[wp]: ready_or_release
  and ct_not_in_q[wp]: ct_not_in_q
  and valid_ready_qs[wp]: valid_ready_qs
  and valid_release_q[wp]: valid_release_q
  and valid_sched_action[wp]: valid_sched_action
  and ct_in_cur_domain[wp]: ct_in_cur_domain
  and valid_blocked[wp]: valid_blocked
  and valid_idle_etcb[wp]: valid_idle_etcb
  and released_ipc_queues[wp]: released_ipc_queues
  and active_reply_scs[wp]: active_reply_scs
  and active_sc_valid_refills[wp]: active_sc_valid_refills
  (wp: get_tcb_obj_ref_wp ignore: set_tcb_obj_ref update_sched_context)

lemma suspend_valid_sched:
  "\<lbrace>valid_sched and scheduler_act_not t\<rbrace>
   suspend t
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding suspend_def update_restart_pc_def
  supply if_split[split del]
  apply (simp flip: bind_assoc)
  apply (rule hoare_seq_ext, wpsimp simp: valid_sched_def)
  apply (simp add: bind_assoc)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?)+
  apply (wpsimp wp: valid_sched_wp)
  apply (clarsimp simp: valid_sched_def)
  apply (intro conjI)
         apply (clarsimp simp: tcb_sched_dequeue_def valid_ready_queued_thread_2_def vs_all_heap_simps
                        split: if_splits elim!: valid_ready_qsE)
        apply (fastforce simp: valid_release_q_def tcb_sched_dequeue_def tcb_sts.pred_map_upds
                               sorted_release_q_2_def)
       apply (clarsimp simp: tcb_sched_dequeue_def ready_or_release_2_def in_queues_2_def
                             in_queue_2_def)
       apply (rename_tac t' d p)
       apply (prop_tac "t' \<in> set (ready_queues s d p)")
        apply (case_tac "dom = d \<and> prio = p"; clarsimp?)
        apply presburger
       apply blast
      apply (clarsimp simp: ct_not_in_q_def tcb_sched_dequeue_def in_queues_2_def split: if_splits)
     apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def tcb_sched_dequeue_def
                           scheduler_act_not_def is_activatable_def tcb_sts.pred_map_upds
                    split: if_splits)
    apply (clarsimp simp: ct_in_cur_domain_def)
   apply (clarsimp simp: tcb_sts.pred_map_upds if_bool_simps
                         tcb_sched_ready_q_update_in_queues_2_simps in_ready_q_def
                         tcb_sched_act_in_queues_2_simps in_release_q_def
                  elim!: valid_blockedE')
  by (simp add: released_ipc_queues_except_strengthen[unfolded fun_upd_def])

lemma tcb_sched_context_update_None_valid_sched:
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except ref and not_queued ref and not_in_release_q ref and scheduler_act_not ref\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update ref None
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def
  by (wpsimp wp: set_tcb_sched_context_valid_ready_qs
                 set_tcb_sched_context_valid_release_q_not_queued
                 set_tcb_sched_context_None_valid_blocked
                 set_tcb_sched_context_None_released_ipc_queues
                 set_tcb_sched_context_valid_sched_action_act_not)

lemma sched_context_unbind_tcb_valid_sched:
  "\<lbrace>valid_sched and
   (\<lambda>s. \<forall>thread. sc_tcb_sc_at ((=) (Some thread)) sc_ptr s \<longrightarrow> (scheduler_act_not thread s))\<rbrace>
   sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  unfolding sched_context_unbind_tcb_def
  apply (wpsimp wp: tcb_sched_context_update_None_valid_sched tcb_release_remove_valid_blocked_except
                    tcb_sched_dequeue_valid_ready_qs tcb_sched_dequeue_valid_blocked_except_set tcb_dequeue_not_queued
                    reschedule_required_valid_blocked hoare_vcg_disj_lift
                    reschedule_required_not_queued tcb_sched_dequeue_ct_not_in_q
              simp: valid_sched_def | strengthen valid_ready_qs_etcb_eq)+
  by (clarsimp simp: sc_at_pred_n_def obj_at_def)

(* This precondition is nasty, but it's better than passing through sym_refs *)
lemma maybe_sched_context_unbind_tcb_valid_sched:
  "\<lbrace>valid_sched and
   (\<lambda>s. \<forall>scp tp. bound_sc_tcb_at (\<lambda>x. x = Some scp) tcb_ptr s \<longrightarrow>
                 sc_tcb_sc_at (\<lambda>x. x = Some tp) scp s \<longrightarrow>
                 scheduler_act_not tp s)\<rbrace>
   maybe_sched_context_unbind_tcb tcb_ptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  unfolding maybe_sched_context_unbind_tcb_def
  apply (wpsimp wp: sched_context_unbind_tcb_valid_sched get_tcb_obj_ref_wp)
  by (clarsimp simp: pred_tcb_at_def obj_at_def sc_at_pred_n_def)

lemma sched_context_unbind_all_tcbs_valid_sched[wp]:
  "\<lbrace>valid_sched and simple_sched_action\<rbrace>
   sched_context_unbind_all_tcbs sc_ptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  unfolding sched_context_unbind_all_tcbs_def
  by (wpsimp wp: sched_context_unbind_tcb_valid_sched)

lemma sched_context_unbind_reply_valid_sched_misc[wp]:
  "sched_context_unbind_reply sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (tcbs_of s) (sc_refill_cfgs_of s)\<rbrace>"
  unfolding sched_context_unbind_reply_def
  by (wpsimp wp: get_sched_context_wp update_sched_context_wp update_sk_obj_ref_wp
           simp: obj_at_def vs_all_heap_simps fun_upd_def tcb_heap.all_simps)

lemma sched_context_unbind_reply_non_empty_sc_replies_at[wp]:
  "\<lbrace>\<lambda>s. scp' \<noteq> scp \<longrightarrow> \<not> non_empty_sc_replies_at scp' s\<rbrace>
   sched_context_unbind_reply scp
   \<lbrace>\<lambda>rv s. \<not> non_empty_sc_replies_at scp' s\<rbrace>"
  unfolding sched_context_unbind_reply_def
  by (wpsimp wp: update_sc_replies_valid_sched_pred simp: heap_upd_def vs_all_heap_simps obj_at_kh_kheap_simps)

lemma active_reply_sc_at_lift_pre_conj:
  assumes "\<lbrace>\<lambda>s. \<not> non_empty_sc_replies_at scp s \<and> R s\<rbrace> f \<lbrace>\<lambda>rv s. \<not> non_empty_sc_replies_at scp s\<rbrace>"
  assumes "\<lbrace>\<lambda>s. pred_map active_scrc (sc_refill_cfgs_of s) scp \<and> R s\<rbrace> f \<lbrace>\<lambda>rv s. pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>"
  shows "\<lbrace>\<lambda>s. active_if_reply_sc_at scp s \<and> R s\<rbrace> f \<lbrace>\<lambda>rv s. active_if_reply_sc_at scp s\<rbrace>"
  unfolding active_if_reply_sc_at_2_def by (intro hoare_vcg_imp_lift_N_pre_conj assms)

lemma sched_context_unbind_reply_active_reply_scs[wp]:
  "sched_context_unbind_reply sc_ptr \<lbrace>active_reply_scs\<rbrace>"
  by (wpsimp wp: active_reply_scs_lift_pre_conj active_reply_sc_at_lift_pre_conj)

lemma sched_context_unbind_reply_valid_sched[wp]:
  "sched_context_unbind_reply scp \<lbrace>valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def)

lemma fast_finalise_valid_sched:
  "\<lbrace>valid_sched and invs and simple_sched_action and (\<lambda>s. \<exists>slot. cte_wp_at ((=) cap) slot s)
    and current_time_bounded\<rbrace>
   fast_finalise cap final
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (cases cap; clarsimp)
     apply wpsimp
    apply (wpsimp wp: cancel_all_ipc_valid_sched, intro conjI; clarsimp)
   apply wpsimp
     apply (strengthen invs_valid_idle invs_sym_refs, simp)
     apply (wpsimp wp: unbind_maybe_notification_invs)
    apply (wpsimp, clarsimp)
  apply (wpsimp wp: cancel_ipc_valid_sched get_simple_ko_wp
                    reply_remove_valid_sched gts_wp)
  apply (simp add: pred_tcb_at_eq_commute tcb_at_kh_simps pred_map_def)
  done

context DetSchedSchedule_AI begin

lemma cap_delete_one_valid_sched:
  "\<lbrace>valid_sched and invs and simple_sched_action and current_time_bounded\<rbrace>
   cap_delete_one slot
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cap_delete_one_def
  by (cases slot; wpsimp wp: fast_finalise_valid_sched get_cap_wp; fastforce)

lemma deleting_irq_handler_valid_sched:
  "\<lbrace>valid_sched and invs and simple_sched_action and current_time_bounded\<rbrace>
   deleting_irq_handler irq
   \<lbrace>\<lambda>y. valid_sched:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding deleting_irq_handler_def
  by (wpsimp wp: cap_delete_one_valid_sched)

lemma unbind_from_sc_valid_sched:
  "\<lbrace>valid_sched and simple_sched_action\<rbrace>
   unbind_from_sc tcb_ptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  unfolding unbind_from_sc_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift maybeM_wp sched_context_unbind_tcb_valid_sched)

(* precondition could be weaker (invs > (sym_refs and valid_objs and (\<lambda>s. cap \<noteq> ThreadCap idle_thread_ptr)) but
   this is much simpler to prove *)
lemma finalise_cap_valid_sched[wp]:
  "\<lbrace>valid_sched and invs and simple_sched_action and (\<lambda>s. \<exists>slot. cte_wp_at ((=) cap) slot s)
    and current_time_bounded\<rbrace>
   finalise_cap cap final
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
       apply (wpsimp wp: cancel_all_ipc_valid_sched cancel_ipc_valid_sched get_simple_ko_wp
                   simp: invs_valid_objs
                  split: if_splits, fastforce)
      apply ((wpsimp wp: cancel_ipc_valid_sched gts_wp get_simple_ko_wp
                         unbind_maybe_notification_invs
                 split: if_splits | strengthen invs_valid_idle invs_sym_refs)+)[1]
     apply ((wpsimp wp: cancel_ipc_valid_sched reply_remove_valid_sched gts_wp get_simple_ko_wp
                split: if_splits| strengthen invs_valid_idle invs_sym_refs)+)[1]
     apply (simp add: pred_tcb_at_eq_commute)
     apply (clarsimp simp: tcb_at_kh_simps pred_map_def)
    apply (wpsimp wp: suspend_valid_sched)
      apply (rule_tac Q="\<lambda>ya. valid_sched and invs and scheduler_act_not x7 and tcb_at x7"
                      in hoare_strengthen_post)
       apply (wpsimp wp: unbind_from_sc_valid_sched)
      apply fastforce
     apply (wpsimp wp: unbind_notification_invs split: if_splits)
    apply (subgoal_tac "valid_cap cap s")
     apply (clarsimp simp: valid_cap_def split: if_splits)
     apply (frule(1) valid_global_refsD[OF invs_valid_global_refs _ idle_global])
     apply (clarsimp dest!: invs_valid_idle simp: valid_idle_def cap_range_def)
    apply (clarsimp elim!: cte_wp_valid_cap)
   apply (rename_tac scptr x)
   apply (wpsimp wp: sched_context_zero_refill_max_valid_sched_unbound_sc hoare_vcg_all_lift)
    apply (rule_tac Q="\<lambda>ya. invs and sc_tcb_sc_at (\<lambda>x. x = None) scptr"
                 in hoare_strengthen_post[rotated])
     apply (clarsimp simp: tcb_at_kh_simps(3)[symmetric] pred_tcb_at_eq_commute)
     apply (subst (asm) sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[OF refl refl])
      apply clarsimp
     apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
    apply (wpsimp wp: sched_context_unbind_yield_from_invs)
   apply (clarsimp split: if_splits)
   apply (fastforce simp: invs_def valid_state_def cap_range_def dest!: valid_global_refsD)
  apply (wpsimp wp: deleting_irq_handler_valid_sched)
  done

lemma cancel_all_ipc_simple_sched_action[wp]:
  "cancel_all_ipc ep \<lbrace>simple_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp simp: cancel_all_ipc_def)

lemma cancel_all_ipc_scheduler_act_sane[wp]:
  "cancel_all_ipc ep \<lbrace>scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp simp: cancel_all_ipc_def)

lemma cancel_all_signals_simple_sched_action[wp]:
  "cancel_all_signals ntfn \<lbrace>simple_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp simp: cancel_all_signals_def)

lemma cancel_all_signals_scheduler_act_sane[wp]:
  "cancel_all_signals ntfn \<lbrace>scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp simp: cancel_all_signals_def)

crunches fast_finalise, cap_delete_one, deleting_irq_handler, cancel_ipc, suspend,
         sched_context_unbind_all_tcbs, finalise_cap
  for simple[wp]: "simple_sched_action :: 'state_ext state \<Rightarrow> _"
  and scheduler_act_sane[wp]: "scheduler_act_sane :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps )

end

lemma update_time_stamp_valid_sched_misc[wp]:
  "update_time_stamp \<lbrace>\<lambda>s. P (cur_sc s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s) (ep_send_qs_of s) (ep_recv_qs_of s)\<rbrace>"
  unfolding update_time_stamp_def
  by wpsimp

context DetSchedSchedule_AI begin

lemma update_time_stamp_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and valid_machine_time\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. active_sc_valid_refills :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: active_sc_valid_refills_def)
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
  done

lemma preemption_point_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and valid_machine_time\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_. active_sc_valid_refills  :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: preemption_point_def
                  wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

lemma invoke_domain_no_exception[wp]:
  "\<lbrace>\<top>\<rbrace> invoke_domain thread domain -, \<lbrace>\<lambda>rv. P\<rbrace>"
  by (wpsimp simp: invoke_domain_def)

lemma update_time_stamp_budget_ready[wp]:
 "\<lbrace>budget_ready t and valid_machine_time :: 'state_ext state \<Rightarrow> _\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_. budget_ready t\<rbrace>"
   apply (rule_tac Q="\<lambda>_ s. \<exists>scp. bound_sc_tcb_at (\<lambda>ko. ko = Some scp) t s \<and>
                                 is_refill_ready scp s"
                in hoare_strengthen_post)
   apply (wpsimp wp: hoare_vcg_ex_lift hoare_vcg_imp_lift hoare_vcg_conj_lift)
   apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
  apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
  done

lemma update_time_stamp_valid_sched[wp]:
  "\<lbrace>valid_sched and valid_machine_time\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: valid_sched_lift_pre_conj[where R=valid_machine_time] simp: valid_sched_def)
  done

lemma preemption_point_valid_sched[wp]:
  "\<lbrace>valid_sched and valid_machine_time\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_vcg_all_lift | wp (once) hoare_drop_imps)+
  done

lemma preemption_point_simple_sched_action[wp]:
  "preemption_point \<lbrace>simple_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: preemption_point_def
                  wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

crunches finalise_cap
  for vmt[wp]: "(\<lambda>s. P (last_machine_time_of s) (cur_time s)) :: 'state_ext state \<Rightarrow> _"
  and pnt[wp]: "(\<lambda>s. P (last_machine_time_of s) (time_state_of s)) :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps hoare_vcg_all_lift)

end

lemma preemption_point_current_time_bounded[wp]:
  "preemption_point \<lbrace>current_time_bounded\<rbrace>"
  unfolding preemption_point_def
  apply (wpsimp simp: preemption_point_def do_extended_op_def
                  wp: OR_choiceE_weak_wp hoare_drop_imps
                      update_time_stamp_current_time_bounded)
  done

context DetSchedSchedule_AI_det_ext begin

lemma rec_del_valid_sched:
 "\<lbrace>valid_sched and valid_machine_time and simple_sched_action and invs and valid_rec_del_call args
        and current_time_bounded
        and (\<lambda>s. \<not> exposed_rdcall args
               \<longrightarrow> ex_cte_cap_wp_to (\<lambda>cp. cap_irqs cp = {}) (slot_rdcall args) s)
        and (\<lambda>s. case args of ReduceZombieCall cap sl ex \<Rightarrow>
                       \<not> cap_removeable cap sl
                       \<and> (\<forall>t\<in>obj_refs cap. halted_if_tcb t s)
                  | _ \<Rightarrow> True)\<rbrace>
  rec_del args
  \<lbrace>\<lambda>rv. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule validE_valid)
  apply (rule hoare_post_impErr)
  apply (rule hoare_pre)
    apply (rule use_spec)
    apply (rule rec_del_invs''[where Q="valid_sched and valid_machine_time and simple_sched_action
                                        and current_time_bounded"])
         apply wpsimp+
  done

end

lemma possible_switch_to_scheduler_act_sane:
  "\<lbrace>scheduler_act_sane and (\<lambda>s. scheduler_action s = resume_cur_thread \<longrightarrow> not_in_release_q t s \<longrightarrow> t \<noteq> cur_thread s)\<rbrace>
   possible_switch_to t
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  unfolding possible_switch_to_def
  apply (wpsimp wp: set_scheduler_action_wp get_tcb_obj_ref_wp thread_get_wp)
  by (clarsimp simp: scheduler_act_sane_def obj_at_def is_tcb)

(* FIXME: add this to elim set much higher up *)
declare pred_tcb_at_tcb_at[elim!]

lemma possible_switch_to_scheduler_act_sane':
  "\<lbrace>scheduler_act_sane and (\<lambda>s. t \<noteq> cur_thread s)\<rbrace>
   possible_switch_to t
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  unfolding possible_switch_to_def
  apply (wpsimp wp: set_scheduler_action_wp get_tcb_obj_ref_wp thread_get_wp)
  by (clarsimp simp: scheduler_act_sane_def obj_at_def is_tcb)

lemma restart_thread_if_no_fault_scheduler_act_sane[wp]:
 "\<lbrace>scheduler_act_sane and (\<lambda>s. xa \<noteq> cur_thread s) \<rbrace>
  restart_thread_if_no_fault xa
  \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp simp: set_thread_state_def set_thread_state_act_def thread_get_def
               wp: possible_switch_to_scheduler_act_sane set_scheduler_action_wp is_schedulable_wp
                   set_object_wp
                   hoare_vcg_imp_lift' )

lemma tcb_sched_enqueue_ct_not_queued:
  "\<lbrace> ct_not_queued and (\<lambda>s. cur \<noteq> cur_thread s)\<rbrace>
   tcb_sched_action tcb_sched_enqueue cur
   \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  apply (wpsimp simp: tcb_sched_action_def thread_get_def wp: set_tcb_queue_wp)
  by (clarsimp simp: in_queues_2_def tcb_sched_ready_q_update_set_simps)

lemma possible_switch_to_ct_not_queued:
  "\<lbrace>ct_not_queued and (\<lambda>s. t \<noteq> cur_thread s) and scheduler_act_sane\<rbrace> possible_switch_to t \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  apply (simp add: possible_switch_to_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (wpsimp wp: tcb_sched_enqueue_ct_not_queued thread_get_wp)
  done

lemma restart_thread_if_no_fault_ct_not_queued[wp]:
 "\<lbrace>ct_not_queued and scheduler_act_sane and (\<lambda>s. xa \<noteq> cur_thread s)\<rbrace>
  restart_thread_if_no_fault xa
  \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp simp: set_thread_state_def set_thread_state_act_def thread_get_def
               wp: possible_switch_to_ct_not_queued set_scheduler_action_wp is_schedulable_wp
                   set_object_wp
                   hoare_vcg_imp_lift' )

crunches cancel_all_ipc
  for ct_not_in_release_q[wp]: "ct_not_in_release_q"
  (wp: crunch_wps)

crunches update_time_stamp
  for typ_at[wp]: "\<lambda>s. P (typ_at T t  s)"

crunches update_time_stamp
  for obj_at[wp]: "\<lambda>(s). Q (obj_at P t s)"

context DetSchedSchedule_AI begin

lemma tcb_sched_dequeue_ct_not_queued:
  "tcb_sched_action tcb_sched_dequeue x \<lbrace>ct_not_queued\<rbrace>"
  by (rule hoare_weaken_pre, wps, wp tcb_dequeue_not_queued, simp)

lemma sym_refs_SendEP_ipc_queued_thread:
  "\<lbrakk> kheap s ptr = Some (Endpoint (SendEP q)); sym_refs (state_refs_of s); t \<in> set q \<rbrakk>
   \<Longrightarrow> ipc_queued_thread t s"
  apply (clarsimp simp: sym_refs_def)
  apply (erule_tac x = ptr in allE)
  apply (drule_tac x = "(t, EPSend)" in bspec)
   apply (clarsimp simp: state_refs_of_def)
  apply (clarsimp simp: state_refs_of_def refs_of_def split: option.splits)
  apply (case_tac x2;
         clarsimp simp: get_refs_def tcb_st_refs_of_def vs_all_heap_simps
                 split: option.splits thread_state.splits)
  done

lemma sym_refs_RecvEP_ipc_queued_thread:
  "\<lbrakk> kheap s ptr = Some (Endpoint (RecvEP q)); sym_refs (state_refs_of s); t \<in> set q \<rbrakk>
   \<Longrightarrow> ipc_queued_thread t s"
  apply (clarsimp simp: sym_refs_def)
  apply (erule_tac x = ptr in allE)
  apply (drule_tac x = "(t, EPRecv)" in bspec)
   apply (clarsimp simp: state_refs_of_def)
  apply (clarsimp simp: state_refs_of_def refs_of_def split: option.splits)
  apply (case_tac x2;
         clarsimp simp: get_refs_def tcb_st_refs_of_def vs_all_heap_simps
                 split: option.splits thread_state.splits)
  done

lemma sym_refs_WaitingNtfn_ipc_queued_thread:
  "\<lbrakk> kheap s ptr = Some (Notification (ntfn)); ntfn_obj ntfn = WaitingNtfn q;  sym_refs (state_refs_of s); t \<in> set q \<rbrakk>
   \<Longrightarrow> ipc_queued_thread t s"
  apply (clarsimp simp: sym_refs_def)
  apply (erule_tac x = ptr in allE)
  apply (drule_tac x = "(t, NTFNSignal)" in bspec)
   apply (clarsimp simp: state_refs_of_def ntfn_q_refs_of_def)
  apply (clarsimp simp: state_refs_of_def refs_of_def split: option.splits)
  apply (case_tac x2;
         clarsimp simp: get_refs_def tcb_st_refs_of_def vs_all_heap_simps
                 split: option.splits thread_state.splits)
  done

lemma cancel_all_ipc_ct_not_queued:
  "\<lbrace>ct_not_queued and scheduler_act_sane and invs and ct_not_blocked\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. ct_not_queued:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cancel_all_ipc_def
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (case_tac "ep=IdleEP"; simp?)
   apply wpsimp
  apply wpc
     apply wpsimp
    apply (rule_tac Q="\<lambda>s. (ko_at (Endpoint ep) epptr and ct_not_queued and scheduler_act_sane and invs and ct_not_blocked) s" in hoare_weaken_pre)
     apply (rule hoare_seq_ext[OF _ get_epq_sp])
     apply wpsimp
       apply (rule_tac Q="\<lambda>_. ct_not_queued and scheduler_act_sane and (\<lambda>x. \<forall>t. t \<in> set (queue) \<longrightarrow> t \<noteq> cur_thread x)" in hoare_strengthen_post)
        apply (wpsimp wp: mapM_x_wp hoare_vcg_all_lift hoare_vcg_imp_lift' gts_wp)
         prefer 2
         apply (rule subset_refl, clarsimp, clarsimp)
      apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
     apply (clarsimp simp: obj_at_def)
     apply (subgoal_tac "ipc_queued_thread (cur_thread s) s")
      apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps pred_map_simps)
     apply (erule sym_refs_SendEP_ipc_queued_thread; clarsimp)
    apply assumption
   apply (rule_tac Q="\<lambda>s. (ko_at (Endpoint ep) epptr and ct_not_queued and scheduler_act_sane and invs and ct_not_blocked) s" in hoare_weaken_pre)
    apply (rule hoare_seq_ext[OF _ get_epq_sp])
    apply wpsimp
      apply (rule_tac Q="\<lambda>_. ct_not_queued and scheduler_act_sane and (\<lambda>x. \<forall>t. t \<in> set (queue) \<longrightarrow> t \<noteq> cur_thread x)" in hoare_strengthen_post)
       apply (wpsimp wp: mapM_x_wp hoare_vcg_all_lift hoare_vcg_imp_lift' gts_wp)
        prefer 2
        apply (rule subset_refl, clarsimp, clarsimp)
     apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
    apply (clarsimp simp: obj_at_def)
    apply (subgoal_tac "ipc_queued_thread (cur_thread s) s")
     apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps pred_map_simps)
    apply (erule sym_refs_RecvEP_ipc_queued_thread; clarsimp)
   apply assumption
  apply fastforce
  done

lemma cancel_all_signals_ct_not_queued:
 "\<lbrace>ct_not_queued and scheduler_act_sane and invs and ct_not_blocked:: 'state_ext state \<Rightarrow> _\<rbrace>
  cancel_all_signals f
  \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  unfolding cancel_all_signals_def
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply wpc
     apply wpsimp
    apply (rule_tac Q="\<lambda>s. (ko_at (Notification ntfn) f and ct_not_queued and scheduler_act_sane and invs and ct_not_blocked) s" in hoare_weaken_pre[rotated])
     apply assumption
    apply wpsimp
      apply (rule_tac Q="\<lambda>_. ct_not_queued and scheduler_act_sane and (\<lambda>s. \<forall>x \<in> set x2. x \<noteq> (cur_thread s))" in hoare_strengthen_post)
       apply (wpsimp wp: mapM_x_wp[where xs = t and S = "set t" for t, simplified])
        apply (wpsimp wp: possible_switch_to_scheduler_act_sane' possible_switch_to_ct_not_queued)+
       apply fastforce
      apply fastforce
     apply wpsimp+
    apply (clarsimp simp: obj_at_def)
    apply (subgoal_tac "ipc_queued_thread (cur_thread s) s")
     apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps pred_map_simps)
    apply (erule (1) sym_refs_WaitingNtfn_ipc_queued_thread; clarsimp)
   apply wpsimp
  apply clarsimp
  done

crunches unbind_maybe_notification, sched_context_maybe_unbind_ntfn, cancel_ipc
  for ct_not_queued[wp]: "ct_not_queued :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

crunches reply_remove, suspend, complete_yield_to, sched_context_unbind_tcb, unbind_notification,
         sched_context_unbind_yield_from, sched_context_unbind_reply, sched_context_unbind_ntfn,
         sched_context_unbind_all_tcbs
  for ct_not_queued[wp]: "ct_not_queued :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps maybeM_wp tcb_sched_dequeue_ct_not_queued simp: crunch_simps ignore: tcb_sched_action)

crunches deleting_irq_handler
  for ct_not_in_release_q[wp]: "ct_not_in_release_q :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma unbind_from_sc_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane\<rbrace>
   unbind_from_sc x7
   \<lbrace>\<lambda>_. ct_not_queued:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding unbind_from_sc_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps)

lemma set_tcb_obj_ref_cur_sc_chargeable_const:
  "(\<And>t. tcb_sched_context (f (\<lambda>y. val) t) = tcb_sched_context t \<and>
         tcb_state (f (\<lambda>y. val) t) = tcb_state t) \<Longrightarrow>
   set_tcb_obj_ref f tptr val \<lbrace>cur_sc_chargeable\<rbrace>"
  apply (wpsimp simp: set_tcb_obj_ref_def wp: set_object_wp)
  by (clarsimp simp: cur_sc_chargeable_def vs_all_heap_simps obj_at_kh_kheap_simps)

lemma thread_set_cur_sc_chargeable_const:
  "(\<And>x. tcb_sched_context (f x) = tcb_sched_context x \<and>
         tcb_state (f x) = tcb_state x) \<Longrightarrow>
   thread_set f x2 \<lbrace>cur_sc_chargeable\<rbrace>"
  apply (simp add: cur_sc_chargeable_def2)
  apply (wpsimp wp: thread_set_wp)
  apply (clarsimp dest!: get_tcb_SomeD
                   simp: obj_at_def pred_tcb_at_def sc_at_pred_def)
  apply (case_tac "cur_thread s = x2"; simp, fastforce)
  done

lemmas misc_cur_sc_chargeable_const =  set_tcb_obj_ref_cur_sc_chargeable_const
                                       thread_set_cur_sc_chargeable_const

lemma sched_context_unbind_tcb_cur_sc_chargeable[wp]:
  "sched_context_unbind_tcb xb \<lbrace>cur_sc_chargeable\<rbrace>"
  unfolding sched_context_unbind_tcb_def
  apply (wp)
  apply (simp add: cur_sc_chargeable_def2)
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (rule_tac Q="\<lambda>_. cur_sc_chargeable" in hoare_strengthen_post[rotated])
  apply (clarsimp simp: cur_sc_chargeable_def2 obj_at_def pred_tcb_at_def sc_at_pred_def, fastforce)
  apply wpsimp+
  done

crunches sched_context_unbind_yield_from, sched_context_unbind_all_tcbs, unbind_from_sc
  for cur_sc_chargeable[wp]: cur_sc_chargeable
  (wp: misc_cur_sc_chargeable_const crunch_wps maybeM_inv)

lemma reply_remove_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and cur_tcb and (\<lambda>s. t \<noteq> cur_thread s)\<rbrace>
   reply_remove t r
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding reply_remove_def sched_context_donate_def reply_unlink_tcb_def
  supply if_split [split del]
  apply (wpsimp wp: assert_inv)
            apply (wpsimp simp: set_thread_state_def set_thread_state_act_def
                            wp: set_object_wp)
           apply (wpsimp wp: update_sk_obj_ref_wp)
          apply (wpsimp wp: assert_inv )
         apply (wpsimp wp: gts_wp)
        apply (wpsimp wp: assert_inv )
       apply (wpsimp wp: get_simple_ko_wp)
      apply wpsimp
            apply (wpsimp wp: set_tcb_obj_ref_wp)
           apply (wpsimp wp: update_sched_context_wp)
          apply (rule_tac Q="\<lambda>_. cur_sc_chargeable and cur_tcb and (\<lambda>s. t \<noteq> cur_thread s)"
                 in hoare_strengthen_post[rotated])
           apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def pred_map_simps split: if_split, fastforce)
          apply (wpsimp simp: test_reschedule_def)
             apply (wpsimp wp: set_tcb_obj_ref_wp)
            apply (rule_tac Q="\<lambda>_. cur_sc_chargeable and cur_tcb and (\<lambda>s. t \<noteq> cur_thread s)"
                   in hoare_strengthen_post[rotated])
             apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def pred_map_simps cur_tcb_def is_tcb split: if_split, fastforce)
            apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)
           apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp assert_opt_inv)
          apply (wpsimp wp: assert_opt_inv)
         apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)
        apply (rule_tac Q="\<lambda>_. cur_sc_chargeable and cur_tcb and (\<lambda>s. t \<noteq> cur_thread s)"
               in hoare_strengthen_post[rotated])
         apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def pred_map_simps split: if_split)
        apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)+
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def pred_map_simps split: if_split)
  done

lemma set_thread_state_csctb:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. (\<forall>x. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) x s \<longrightarrow> (x \<noteq> xa \<or> d = Inactive)))\<rbrace>
   set_thread_state xa d
   \<lbrace>\<lambda>xa. cur_sc_chargeable\<rbrace>"
  unfolding set_thread_state_def set_thread_state_act_def
  apply (wpsimp wp: set_object_wp)
  by (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)

lemma set_thread_state_Inactive_csctb[wp]:
  "set_thread_state d Inactive \<lbrace>cur_sc_chargeable\<rbrace>"
  by (wpsimp wp: set_thread_state_csctb)

lemma restart_thread_if_no_fault_csctb:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. (\<forall>x. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) x s \<longrightarrow> (x \<noteq> xa)))\<rbrace>
   restart_thread_if_no_fault xa
   \<lbrace>\<lambda>xa. cur_sc_chargeable\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp simp: possible_switch_to_def wp: hoare_drop_imp set_thread_state_csctb, fastforce)

lemma reply_unlink_tcb_csctb:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. (\<forall>x. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) x s \<longrightarrow> (x \<noteq> xa)))\<rbrace>
   reply_unlink_tcb xa r
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding reply_unlink_tcb_def
  apply (wpsimp wp: set_thread_state_csctb update_sk_obj_ref_wp gts_wp get_simple_ko_wp)
  by (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)

lemma restart_thread_if_no_fault_not_bound_sc_tcb_at[wp]:
  "restart_thread_if_no_fault x \<lbrace>\<lambda>s. \<not> bound_sc_tcb_at P xs s\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by wpsimp

lemma cancel_all_ipc_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and ct_not_blocked and invs\<rbrace>
   cancel_all_ipc x
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding cancel_all_ipc_def
  apply wpsimp
       apply (rule_tac R="\<lambda>_ s. \<forall>x \<in> set queue. \<not> bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) x s \<and> x \<noteq> cur_thread s" in hoare_post_add)
       apply (rule mapM_x_wp[where S="set xs" and xs=xs for xs])
        apply wpsimp
            apply ((wpsimp wp: restart_thread_if_no_fault_csctb hoare_vcg_ball_lift restart_thread_if_no_fault_other reply_unlink_tcb_csctb
                               hoare_vcg_all_lift hoare_vcg_imp_lift'
                    | rule hoare_lift_Pf[where f = cur_sc])+)[3]
         apply (wp gts_wp)
        apply (clarsimp)
        apply (drule_tac x=x in bspec, simp)
        apply (intro conjI; clarsimp)
       apply clarsimp
      apply (wpsimp wp: set_simple_ko_wp get_ep_queue_wp)+
      apply (rule_tac R="\<lambda>_ s. \<forall>x \<in> set queue. \<not> bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) x s \<and> x \<noteq> cur_thread s" in hoare_post_add)
      apply (rule mapM_x_wp[where S="set xs" and xs=xs for xs])
       apply wpsimp
           apply ((wpsimp wp: restart_thread_if_no_fault_csctb hoare_vcg_ball_lift restart_thread_if_no_fault_other reply_unlink_tcb_csctb
                              hoare_vcg_all_lift hoare_vcg_imp_lift'
                   | rule hoare_lift_Pf[where f = cur_sc])+)[3]
        apply (wp gts_wp)
       apply (clarsimp)
       apply (drule_tac x=x in bspec, simp)
       apply (intro conjI; clarsimp)
      apply clarsimp
     apply (wpsimp wp: set_simple_ko_wp get_ep_queue_wp get_simple_ko_wp)+
  apply (intro conjI; intro allI impI; intro conjI)
     apply (clarsimp simp: obj_at_def)
     apply (subgoal_tac "ipc_queued_thread xaa s")
      apply (subgoal_tac "(xaa \<noteq> cur_thread s)")
       apply (clarsimp simp: obj_at_kh_kheap_simps cur_sc_chargeable_def pred_map_simps, fastforce)
      apply (clarsimp simp: obj_at_kh_kheap_simps ct_in_state_kh_simp pred_map_simps)
     apply (erule sym_refs_SendEP_ipc_queued_thread; clarsimp)
    apply (clarsimp simp:  cur_sc_chargeable_def vs_all_heap_simps)
   apply (clarsimp simp: obj_at_def)
   apply (subgoal_tac "ipc_queued_thread xaa s")
    apply (subgoal_tac "(xaa \<noteq> cur_thread s)")
     apply (clarsimp simp: obj_at_kh_kheap_simps cur_sc_chargeable_def pred_map_simps, fastforce)
    apply (clarsimp simp: obj_at_kh_kheap_simps ct_in_state_kh_simp pred_map_simps)
   apply (erule sym_refs_RecvEP_ipc_queued_thread; clarsimp)
  apply (clarsimp simp:  cur_sc_chargeable_def vs_all_heap_simps)
  done

lemma cancel_all_signals_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   cancel_all_signals x
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cancel_all_signals_def
  apply wpsimp
      apply (rule_tac R="\<lambda>_ s. \<forall>x \<in> set x2. \<not> bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) (x) s \<and> x \<noteq> cur_thread s" in hoare_post_add)
      apply (rule mapM_x_wp[where S="set xs" and xs=xs for xs])
       apply (wpsimp wp: hoare_vcg_ball_lift hoare_vcg_all_lift hoare_vcg_imp_lift' set_thread_state_csctb sts_st_tcb_at_other)
          apply ((wps, wpsimp)+)[4]
        apply (wpsimp wp: hoare_vcg_ball_lift hoare_vcg_all_lift hoare_vcg_imp_lift' set_thread_state_csctb sts_st_tcb_at_other
                          possible_switch_to_ct_not_queued possible_switch_to_scheduler_act_sane')
       apply (intro conjI; clarsimp)
      apply simp
     apply (wpsimp wp: set_simple_ko_wp get_simple_ko_wp)+
  apply (intro conjI)
   apply (clarsimp simp: obj_at_def)
   apply (subgoal_tac "ipc_queued_thread xaa s")
    apply (subgoal_tac "(xaa \<noteq> cur_thread s)")
     apply (clarsimp simp: obj_at_kh_kheap_simps cur_sc_chargeable_def pred_map_simps, fastforce)
    apply (clarsimp simp: obj_at_kh_kheap_simps ct_in_state_kh_simp pred_map_simps)
   apply (erule sym_refs_WaitingNtfn_ipc_queued_thread, assumption, clarsimp, clarsimp)
  apply (clarsimp simp:  cur_sc_chargeable_def vs_all_heap_simps)
  done

lemma blocked_cancel_ipc_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. x\<noteq>cur_thread s) and st_tcb_at (Not \<circ> inactive) x\<rbrace>
   blocked_cancel_ipc a x c
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding blocked_cancel_ipc_def
  apply (wpsimp wp: reply_unlink_tcb_csctb get_simple_ko_wp set_simple_ko_wp get_ep_queue_wp get_blocking_object_wp)
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)
  by fastforce

lemma reply_remove_tcb_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. x\<noteq>cur_thread s)\<rbrace>
   reply_remove_tcb x b
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding reply_remove_tcb_def
  apply (wpsimp wp: reply_unlink_tcb_csctb update_sk_obj_ref_wp update_sched_context_wp get_sk_obj_ref_wp gts_wp)
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)
  by fastforce

lemma cancel_signal_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and (\<lambda>s. x\<noteq>cur_thread s)\<rbrace>
   cancel_signal x b
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding cancel_signal_def
  apply (wpsimp wp: reply_unlink_tcb_csctb set_simple_ko_wp get_simple_ko_wp)
  by (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)

lemma thread_set_cur_sc_chargeable_indep:
  "\<forall>tcb. tcb_sched_context (a tcb) = tcb_sched_context (tcb) \<Longrightarrow>
   \<forall>tcb. tcb_state (a tcb) = tcb_state tcb \<Longrightarrow>
   thread_set a b \<lbrace>cur_sc_chargeable\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def)
  by fastforce

lemma cancel_ipc_cur_sc_chargeable2:
  "\<lbrace>cur_sc_chargeable and ct_not_blocked\<rbrace>
   cancel_ipc x
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding cancel_ipc_def
  apply (wpsimp wp: blocked_cancel_ipc_cur_sc_chargeable reply_remove_tcb_cur_sc_chargeable
                    cancel_signal_cur_sc_chargeable)
    apply (wpsimp wp: thread_set_cur_sc_chargeable_indep hoare_vcg_imp_lift' gts_wp thread_set_no_change_tcb_state)+
  apply (case_tac "x = cur_thread s")
   apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps cur_sc_chargeable_def ct_in_state_def
          , fastforce)
  apply (fastforce simp: tcb_at_kh_simps vs_all_heap_simps)
  done

lemma cancel_ipc_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and cur_tcb and (\<lambda>s. x\<noteq>cur_thread s)\<rbrace>
   cancel_ipc x
   \<lbrace>\<lambda>_. cur_sc_chargeable\<rbrace>"
  unfolding cancel_ipc_def
  apply (wpsimp wp: blocked_cancel_ipc_cur_sc_chargeable
                    reply_remove_tcb_cur_sc_chargeable
                    cancel_signal_cur_sc_chargeable thread_set_wp gts_wp)
  by (fastforce simp: cur_sc_chargeable_def obj_at_kh_kheap_simps vs_all_heap_simps)

crunches cancel_ipc, reply_remove, sched_context_unbind_all_tcbs, suspend, unbind_from_sc
  for ct_not_in_release_q[wp]: "ct_not_in_release_q :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps hoare_vcg_all_lift)

lemma fast_finalise_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   fast_finalise d e
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac d; simp)
     apply wpsimp
    apply (wpsimp wp: cancel_all_ipc_cur_sc_chargeable)
   apply (wpsimp wp: cancel_all_signals_cur_sc_chargeable unbind_maybe_notification_invs simp:)
  subgoal for rcap
    apply (wpsimp wp: cancel_ipc_cur_sc_chargeable reply_remove_cur_sc_chargeable)
      apply (wpsimp wp: gts_wp get_simple_ko_wp)+
    apply (subgoal_tac "st_tcb_at (ipc_queued_thread_state) x s")
     apply (clarsimp simp: obj_at_kh_kheap_simps ct_in_state_kh_simp)
     apply (intro conjI; intro allI impI; clarsimp simp: invs_def pred_map_simps)
    apply (subgoal_tac "(rcap, TCBReply) \<in> state_refs_of s x")
     apply (clarsimp simp: pred_tcb_at_def obj_at_def state_refs_of_def get_refs_def2 tcb_st_refs_of_def
                           pred_neg_def
                    split: thread_state.splits if_splits)
    apply (erule reply_tcb_not_idle_thread_helper, simp add: obj_at_def, clarsimp)
    done
  done

lemma cap_delete_one_cur_sc_chargeable[wp]:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   cap_delete_one d
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cap_delete_one_def
  by (wpsimp wp: get_cap_wp fast_finalise_cur_sc_chargeable)

lemma suspend_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and ct_not_blocked\<rbrace>
   suspend x
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding suspend_def update_restart_pc_def sched_context_cancel_yield_to_def
  by (wpsimp wp: set_tcb_obj_ref_cur_sc_chargeable_const hoare_drop_imp
                 cancel_ipc_cur_sc_chargeable2)

(* FIXME: set_tcb_obj_ref does more than set tcb object references *)

lemma set_tcb_obj_ref_ct_in_state:
  "\<forall>tcb. tcb_state (f (\<lambda>_. C) tcb) = tcb_state tcb \<Longrightarrow>
   set_tcb_obj_ref f ptr C \<lbrace>ct_in_state P\<rbrace>"
  unfolding set_tcb_obj_ref_def
  apply (wpsimp wp: set_object_wp)
  by (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def
              dest!: get_tcb_SomeD)

crunches unbind_from_sc, unbind_notification
  for ct_in_state[wp]: "ct_in_state P"
  (wp: crunch_wps hoare_drop_imp hoare_vcg_all_lift)

lemma deleting_irq_handler_cur_sc_chargeable[wp]:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   deleting_irq_handler x12
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding deleting_irq_handler_def
  by wpsimp

crunches finalise_cap
  for ct_not_in_release_q[wp]: "ct_not_in_release_q :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma finalise_cap_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   finalise_cap d f
   \<lbrace>\<lambda>_. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (case_tac d; simp)
               apply wpsimp
              apply wpsimp
             apply (wpsimp wp: cancel_all_ipc_cur_sc_chargeable split: if_split)
             apply (wpsimp wp: cancel_all_signals_cur_sc_chargeable unbind_maybe_notification_invs split: if_split)
           apply (wpsimp wp: reply_remove_cur_sc_chargeable cancel_ipc_cur_sc_chargeable
                             gts_wp get_simple_ko_wp split: if_split)
   apply (rename_tac r R s ntfn x st)
   apply (subgoal_tac "st_tcb_at (ipc_queued_thread_state) x s")
    apply (clarsimp simp: obj_at_kh_kheap_simps ct_in_state_kh_simp)
   apply (intro conjI; intro allI impI; clarsimp simp: invs_def pred_map_simps)
           apply (subgoal_tac "(r, TCBReply) \<in> state_refs_of s x")
            apply (clarsimp simp: pred_tcb_at_def obj_at_def state_refs_of_def get_refs_def2 tcb_st_refs_of_def
                                  pred_neg_def
                           split: thread_state.splits if_splits)
           apply (erule reply_tcb_not_idle_thread_helper, simp add: obj_at_def, clarsimp)
          apply wpsimp
         apply (wpsimp simp: wp: suspend_cur_sc_chargeable split: if_split)
        apply wpsimp
       apply (wpsimp split: if_split simp:)
      apply (wpsimp)+
  done

lemma set_tcb_pred_tcb_const:
  "(\<And>tcb. P (proj (tcb_to_itcb (f (\<lambda>y. v) tcb))) = P (proj (tcb_to_itcb tcb))) \<Longrightarrow>
   set_tcb_obj_ref f x v \<lbrace>\<lambda>s. Q (pred_tcb_at proj P p s)\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (erule back_subst[where P=Q])
  by (clarsimp simp: pred_tcb_at_def obj_at_def)

lemmas set_tcb_obj_ref_budget_ready_indep = set_tcb_pred_tcb_const
                                            set_tcb_budget_sufficient_const
                                            set_tcb_active_sc_tcb_at_const
                                            set_tcb_obj_ref_budget_ready_const

lemma rec_del_scheduler_act_sane[wp]:
  "rec_del call \<lbrace>scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: rec_del_preservation preemption_point_inv)

crunches cap_delete
  for simple_sched_action[wp]: "simple_sched_action :: 'state_ext state \<Rightarrow> _"
  (wp: preemption_point_inv)

lemma ct_in_state_kh_lift:
  "f \<lbrace>\<lambda>s. pred_map P (tcb_sts_of s) (cur_thread s)\<rbrace>
   \<Longrightarrow> f \<lbrace>\<lambda>s. ct_in_state P s\<rbrace>"
  by (clarsimp simp: ct_in_state_kh_simp)

lemma rec_del_ct_not_in_release_q[wp]:
  "rec_del call \<lbrace>ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: rec_del_preservation preemption_point_inv)

lemma restart_thread_if_no_fault_ct_not_queued[wp]:
 "\<lbrace>ct_not_queued and scheduler_act_sane and (\<lambda>s. tptr \<noteq> cur_thread s) and tcb_at tptr\<rbrace>
  restart_thread_if_no_fault tptr
  \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp simp: set_thread_state_def set_thread_state_act_def
               wp: possible_switch_to_ct_not_queued set_scheduler_action_wp is_schedulable_wp
                   set_object_wp thread_get_wp
                   hoare_vcg_imp_lift' )

lemma fast_finalise_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane and invs and ct_not_blocked\<rbrace>
   fast_finalise cap final
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac cap)
               apply (wpsimp wp: gts_wp get_simple_ko_wp cancel_all_ipc_ct_not_queued
                                 cancel_all_signals_ct_not_queued unbind_maybe_notification_invs)+
  done

lemma deleting_irq_handler_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane and invs and ct_not_blocked\<rbrace>
   deleting_irq_handler irq
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding deleting_irq_handler_def
  by (wpsimp simp: cap_delete_one_def wp: hoare_drop_imp hoare_vcg_if_lift2)

lemma finalise_cap_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and scheduler_act_sane and invs and ct_not_blocked\<rbrace>
   finalise_cap cap param_b
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (case_tac cap)
               apply (wpsimp wp: gts_wp get_simple_ko_wp cancel_all_ipc_ct_not_queued
                                 cancel_all_signals_ct_not_queued unbind_maybe_notification_invs
                      | clarsimp simp: split: if_split)+
  done

crunches cap_swap_for_delete, empty_slot
  for ct_not_blocked[wp]: "ct_not_blocked :: 'state_ext state \<Rightarrow> _"
  (simp: cap_swap_ext_def wp: dxo_wp_weak)

end

lemma ct_in_state_def2: "ct_in_state test s = st_tcb_at test (cur_thread s) s"
   by (simp add: ct_in_state_def)

crunches reorder_ntfn, reorder_ep
  for valid_sched[wp]:"valid_sched"
  and simple_sched_action[wp]: simple_sched_action
  (wp: mapM_wp' get_simple_ko_wp)

lemma thread_set_priority_valid_sched_misc[wp]:
  "thread_set_priority p t
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (sc_tcbs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
          (scheduler_action s) (tcb_sts_of s) (tcb_scps_of s)
          (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>"
  apply (wpsimp simp: thread_set_priority_def  wp: thread_set_wp)
  by (clarsimp simp: obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps)

lemma thread_set_domain_valid_sched_misc[wp]:
  "thread_set_domain t d
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (ready_queues s) (release_queue s)
          (scheduler_action s) (tcb_sts_of s) (tcb_scps_of s)
          (tcb_faults_of s) (sc_refill_cfgs_of s) (sc_replies_of s)\<rbrace>"
  apply (wpsimp simp: thread_set_domain_def  wp: thread_set_wp)
  by (clarsimp simp: obj_at_kh_kheap_simps fun_upd_def vs_all_heap_simps)

lemma thread_set_domain_st_tcb[wp]:
  "thread_set_domain t d \<lbrace>\<lambda>s. P (st_tcb_at Q p s)\<rbrace>"
  by (clarsimp simp: tcb_at_kh_simps, wpsimp)

lemma thread_set_priority_valid_ready_qs_not_q:
  "\<lbrace>valid_ready_qs and not_queued t\<rbrace> thread_set_priority t p \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding thread_set_priority_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: valid_ready_qs_def vs_all_heap_simps not_queued_def dest!: get_tcb_SomeD)
  apply (rule conjI; clarsimp)
  apply (drule_tac x=d and y=p in spec2, clarsimp)
  apply (drule_tac x=ta in bspec, simp, clarsimp)
  apply (rename_tac scp sc n)
  apply (rule_tac x=scp in exI; fastforce)
  done

lemma thread_set_priority_switch_in_cur_domain[wp]:
  "thread_set_priority t p \<lbrace>switch_in_cur_domain\<rbrace>"
  unfolding thread_set_priority_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: switch_in_cur_domain_def in_cur_domain_def etcb_at'_def vs_all_heap_simps
                 dest!: get_tcb_SomeD)
  done

lemma thread_set_priority_ct_in_cur_domain[wp]:
  "thread_set_priority p t \<lbrace>ct_in_cur_domain\<rbrace>"
  unfolding thread_set_priority_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: ct_in_cur_domain_def in_cur_domain_def etcb_at'_def vs_all_heap_simps
                 dest!: get_tcb_SomeD)
  done

lemma thread_set_priority_valid_idle_etcb[wp]:
  "thread_set_priority t p \<lbrace>valid_idle_etcb\<rbrace>"
  unfolding thread_set_priority_def thread_set_def
  apply (wpsimp wp: set_object_wp wp_del: valid_idle_etcb_lift)
  apply (clarsimp simp: valid_idle_etcb_def vs_all_heap_simps etcb_at'_def dest!: get_tcb_SomeD)
  done

lemma thread_set_priority_valid_sched:
  "\<lbrace>valid_sched and not_queued t\<rbrace> thread_set_priority t p \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def valid_sched_action_def
  by (wpsimp wp: thread_set_priority_valid_ready_qs_not_q)

lemma is_schedulable_opt_ready_queues_update[simp]:
  "is_schedulable_opt t (ready_queues_update f s) = is_schedulable_opt t s"
  by (clarsimp simp: is_schedulable_opt_def get_tcb_def is_sc_active_def
                  split: option.splits)

lemma ct_not_in_q_not_cur_threadE:
  "tptr \<in> set (ready_queues s d p)
   \<Longrightarrow> ct_not_in_q s
   \<Longrightarrow> not_cur_thread tptr s"
  by (clarsimp simp: ct_not_in_q_def not_cur_thread_def not_queued_def)

lemma set_priority_valid_sched:
  "\<lbrace>valid_sched and ct_released and ct_active and ct_not_in_release_q\<rbrace>
   set_priority tptr prio
   \<lbrace>\<lambda>_. valid_sched \<rbrace>"
  apply (clarsimp simp: set_priority_def)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (wpsimp wp: hoare_vcg_if_lift2 reschedule_required_valid_sched'
                    tcb_sched_enqueue_valid_blocked_except_set)
          apply (wpsimp wp: thread_set_priority_valid_ready_qs_not_q)
         apply (wpsimp wp: tcb_sched_dequeue_valid_ready_qs tcb_dequeue_not_queued
                           tcb_sched_dequeue_valid_blocked_except_set_const)
        apply (wpsimp wp: thread_set_priority_valid_sched)
       apply (wpsimp wp: thread_get_wp)+
    apply (rule_tac Q="\<lambda>r. valid_sched" in hoare_strengthen_post; wpsimp wp: thread_set_priority_valid_sched)
   apply (rule_tac Q="\<lambda>r. valid_sched" in hoare_strengthen_post; wpsimp wp: thread_set_priority_valid_sched)
  apply (clarsimp simp: valid_sched_def valid_sched_action_def obj_at_def)
  apply (intro conjI; intro impI)
   apply (frule pred_tcb_at_tcb_at, clarsimp simp: obj_at_def is_tcb)
   apply (intro conjI; intro impI)
     apply (clarsimp simp: valid_ready_qs_def valid_blocked_thread_def tcb_at_kh_simps
                           released_sc_tcb_at_def)
     apply (fastforce simp: not_queued_def ready_or_release_2_def)
    apply (intro conjI)
     apply (clarsimp simp: valid_blocked_thread_def ct_in_state_def runnable_eq_active)
    apply (clarsimp simp: valid_ready_qs_def valid_blocked_thread_def tcb_at_kh_simps
                          released_sc_tcb_at_def)
   apply (clarsimp simp: vs_all_heap_simps valid_ready_qs_def in_ready_q_def tcb_at_kh_simps
          , fastforce)
  apply (clarsimp simp: vs_all_heap_simps valid_ready_qs_def in_ready_q_def tcb_at_kh_simps
         , fastforce)
  done

lemma set_mcpriority_valid_sched_pred_strong[wp]:
  "set_mcpriority tptr prio \<lbrace>valid_sched_pred_strong P\<rbrace>"
  by (simp add: set_mcpriority_def thread_set_not_state_valid_sched)

lemma set_priority_simple_sched_action[wp]:
  "set_priority param_a param_b \<lbrace>simple_sched_action\<rbrace>"
  unfolding set_priority_def
  by (wpsimp simp: get_thread_state_def thread_get_def wp: maybeM_inv)

lemma postpone_in_release_q:
  "\<lbrace>sc_tcb_sc_at ((=) (Some tcbptr)) sc_ptr\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>r. in_release_q tcbptr\<rbrace>"
  apply (clarsimp simp: postpone_def assert_opt_def)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (clarsimp split: option.splits)
  apply (case_tac "x2 = tcbptr")
   apply (wpsimp wp: tcb_release_enqueue_in_release_q)
  apply (rule_tac Q="\<lambda>s. False" in hoare_weaken_pre, simp)
  apply (clarsimp simp: pred_conj_def sc_tcb_sc_at_def obj_at_def)
  apply (drule_tac s="Some tcbptr" in sym, simp)
  done

lemma sched_context_resume_schedulable_imp_ready:
  "\<lbrace>bound_sc_tcb_at ((=) (Some scp)) t
    and sc_tcb_sc_at ((=) (Some t)) scp
    and active_sc_valid_refills\<rbrace>
    sched_context_resume scp
   \<lbrace>\<lambda>_ s. schedulable t s \<longrightarrow> budget_ready t s\<rbrace>"
  unfolding sched_context_resume_def assert_opt_def when_def get_sc_refill_sufficient_def bind_assoc
  apply (wpsimp wp: postpone_in_release_q hoare_vcg_all_lift hoare_vcg_imp_lift'
                    hoare_vcg_disj_lift thread_get_wp' is_schedulable_wp
              simp: schedulable_def2)
  apply (intro conjI impI; clarsimp simp: obj_at_def schedulable_def2)
   apply (clarsimp simp: obj_at_def vs_all_heap_simps tcb_at_kh_simps sc_at_kh_simps)+
  done

lemma sc_tcb_update_sc_tcb_sc_at:
  "\<lbrace>K (P t)\<rbrace> set_sc_obj_ref sc_tcb_update sc t \<lbrace>\<lambda>rv. sc_tcb_sc_at P sc\<rbrace>"
  apply (wpsimp simp: wp: update_sched_context_wp)
  by (clarsimp simp: obj_at_def sc_at_pred_n_def)

lemma set_tcb_sched_context_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s
        \<and> (\<forall>scp. sco = Some scp \<longrightarrow> sched_context_donate_ipc_queues_precond t scp s)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t sco
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (cases sco; clarsimp simp: is_blocked_thread_state_defs vs_all_heap_simps elim!: released_ipc_queuesE split: if_splits)

crunches if_cond_refill_unblock_check
  for sc_tcb_sc_at[wp]: "\<lambda>s. P' (sc_tcb_sc_at P scp s)"
  (wp: crunch_wps)

lemma sched_context_bind_tcb_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> simple_sched_action s \<and> current_time_bounded s
        \<and> pred_map_eq None (tcb_scps_of s) tcbptr
        \<and> not_cur_thread tcbptr s \<and> sc_not_in_release_q scptr s
        \<and> sched_context_donate_ipc_queues_precond tcbptr scptr s\<rbrace>
   sched_context_bind_tcb scptr tcbptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  supply if_split[split del]
  apply (clarsimp simp: sched_context_bind_tcb_def)
  apply (wpsimp wp: is_schedulable_wp' reschedule_valid_sched_const)
     apply (rule_tac Q="\<lambda>r s. valid_sched_except_blocked s
                               \<and> valid_blocked_except tcbptr s
                               \<and> not_cur_thread tcbptr s
                               \<and> (schedulable tcbptr s
                                       \<longrightarrow> budget_ready tcbptr s)"
                      in hoare_strengthen_post[rotated])
      apply (clarsimp simp: valid_sched_valid_sched_except_blocked obj_at_kh_kheap_simps schedulable_def2
                     split: if_splits)
      apply (fastforce simp: valid_sched_def runnable_eq_active
                      elim!: valid_blockedE'
                             valid_refills_budget_sufficient[OF active_sc_valid_refills_tcb_at])
     apply (wpsimp wp: sched_context_resume_valid_sched_except_blocked
                       sched_context_resume_schedulable_imp_ready)
    apply (rule_tac Q="\<lambda>r. valid_sched_except_blocked and sc_not_in_release_q scptr and
                           valid_blocked_except_set {tcbptr} and
                           not_cur_thread tcbptr and current_time_bounded and
                           sc_tcb_sc_at ((=) (Some tcbptr)) scptr and
                           bound_sc_tcb_at (\<lambda>a. a = Some scptr) tcbptr"
                    in hoare_strengthen_post[rotated])
     apply (clarsimp simp: tcb_at_kh_simps sc_at_kh_simps valid_sched_def
                                heap_refs_retract_at_def vs_all_heap_simps
                    dest!: sym[of "Some _"])
     apply wpsimp
    apply (wpsimp wp: sc_tcb_update_sc_tcb_sc_at)
   apply (wpsimp wp: set_tcb_sched_context_valid_ready_qs
                     set_tcb_sched_context_valid_release_q_not_queued
                     set_tcb_sched_context_simple_valid_sched_action
                     set_tcb_sched_context_Some_valid_blocked_except
                     set_tcb_sched_context_released_ipc_queues
                     ssc_bound_sc_tcb_at
               simp: valid_sched_def)
   apply (subst op_equal[symmetric])
   apply (wpsimp wp: ssc_bound_sc_tcb_at)
  apply (clarsimp simp: valid_sched_def cong: conj_cong)
  apply (fastforce simp: in_queues_2_def valid_release_q_def vs_all_heap_simps in_queue_2_def
                  dest!: valid_ready_qs_no_sc_not_queued)
  done

lemma maybe_sched_context_bind_tcb_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> simple_sched_action s \<and> bound_sc_tcb_at ((=) None) tcbptr s \<and> not_cur_thread tcbptr s
        \<and> sched_context_donate_ipc_queues_precond tcbptr scptr s \<and> current_time_bounded s
        \<and> sc_not_in_release_q scptr s\<rbrace>
   maybe_sched_context_bind_tcb scptr tcbptr
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  unfolding maybe_sched_context_bind_tcb_def
  apply (wpsimp wp: sched_context_bind_tcb_valid_sched get_tcb_obj_ref_wp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps split: if_splits)

context DetSchedSchedule_AI_det_ext begin

crunches install_tcb_cap
for valid_sched[wp]: "valid_sched :: det_ext state \<Rightarrow> _"
and simple_sched_action[wp]: "simple_sched_action :: det_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv simp: crunch_simps)

lemma install_tcb_frame_cap_valid_sched:
  "\<lbrace>valid_sched and valid_machine_time and simple_sched_action and invs and current_time_bounded\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_frame_cap_def
  by (wpsimp wp: reschedule_valid_sched_const check_cap_inv hoare_drop_imp
                 thread_set_not_state_valid_sched)

end

crunch scheduler_act_not[wp]: set_priority "scheduler_act_not y"
  (wp: crunch_wps simp: crunch_simps)

crunches reorder_ntfn
  for valid_sched_pred[wp]: "valid_sched_pred_strong P"
  (wp: crunch_wps simp: crunch_simps ignore: set_simple_ko)

crunches reorder_ep
  for valid_sched_pred[wp]:
   "\<lambda>s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s)
          (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s)
          (sc_refill_cfgs_of s) (sc_replies_of s)"
  (wp: crunch_wps simp: crunch_simps)

crunches set_priority, set_mcpriority
  for interrupt_irq_node[wp]: "\<lambda>s. P (interrupt_irq_node s)"
  (wp: crunch_wps)

lemma set_priority_valid_sched_misc[wp]:
  "set_priority tptr prio
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (sc_tcbs_of s) (cur_time s) (cur_domain s) (cur_thread s)
          (idle_thread s) (release_queue s)
          (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_refill_cfgs_of s)
          (sc_replies_of s)\<rbrace>"
  by (wpsimp wp: thread_get_wp gts_wp
           simp: get_tcb_queue_def obj_at_def st_tcb_at_def is_tcb_def set_priority_def)

lemma set_priority_bound_sc_tcb_at_cur_thread[wp]:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s\<rbrace>
   set_priority param_a param_b
   \<lbrace>\<lambda>_ s. bound_sc_tcb_at bound (cur_thread s) s\<rbrace>"
  by (rule_tac f="cur_thread" in hoare_lift_Pf;
      wpsimp simp: set_priority_def get_thread_state_def thread_get_def thread_set_priority_def
               wp: maybeM_inv reschedule_required_lift)

crunch simple_sched_action[wp]: sched_context_bind_tcb simple_sched_action
  (wp: crunch_wps simp: crunch_simps)

lemma set_mcpriority_bound_sc_tcb_at_cur_thread[wp]:
  "set_mcpriority target a \<lbrace>(\<lambda>s. bound_sc_tcb_at P (cur_thread s) s)\<rbrace>"
  unfolding set_mcpriority_def
  apply (wpsimp simp: thread_set_def wp: set_object_wp)
  by (clarsimp simp: pred_tcb_at_def obj_at_def dest!: get_tcb_SomeD)

lemma reorder_ntfn_bound_sc_tcb_at_cur_thread[wp]:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>
   reorder_ntfn ntfn_ptr tptr
   \<lbrace>\<lambda>_. \<lambda>s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>"
  by (rule_tac f="cur_thread" in hoare_lift_Pf; wpsimp)

lemma reorder_ep_bound_sc_tcb_at_cur_thread[wp]:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>
   reorder_ep ep_ptr tptr
   \<lbrace>\<lambda>_. \<lambda>s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>"
  by (rule_tac f="cur_thread" in hoare_lift_Pf; wpsimp)

lemma set_scheduler_action_bound_sc_tcb_at_cur_thread[wp]:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>
   set_scheduler_action sched_act
   \<lbrace>\<lambda>x s. bound_sc_tcb_at P (cur_thread s) s\<rbrace>"
  by (rule_tac f="cur_thread" in hoare_lift_Pf; wpsimp)

crunches cancel_all_ipc, cancel_all_signals
  for is_active_sc[wp]: "(\<lambda>s. P (is_active_sc sc s))"
  and active_sc_tcb_at[wp]: "\<lambda>s. P (active_sc_tcb_at t s)"
  and budget_ready[wp]: "budget_ready t"
  and not_in_release_q[wp]: "(\<lambda>s. not_in_release_q t s)"
  and timeout_faulted_tcb_at[wp]: "(\<lambda>s. P (timeout_faulted_tcb_at sc s))"
  and etcbs_of[wp]: "\<lambda>s. P (etcbs_of s ptr)"
  (wp: crunch_wps)

(*FIXME RT: move (to Tcb_AI?) so that it can be used in tcc_invs*)
method invoke_tcb_install_tcb_cap_helper uses wp =
  (find_goal \<open>succeeds
                \<open>subst validE_is_triple validE_R_is_triple,
                 match conclusion in "triple_judgement _ (install_tcb_cap _ _ _ _) _" \<Rightarrow> \<open>-\<close>\<close>\<close>,
   (clarsimp cong: conj_cong)?,
   (rule hoare_vcg_E_elim, wp)?,
   ((wpsimp wp: hoare_vcg_const_imp_lift_R hoare_vcg_all_lift_R hoare_vcg_all_lift
                install_tcb_cap_invs static_imp_wp static_imp_conj_wp wp
     | strengthen tcb_cap_always_valid_strg
     | wp install_tcb_cap_cte_wp_at_ep)+)[1])

crunches restart_thread_if_no_fault
  for budget_sufficient[wp]: "budget_sufficient tp"
  and released_ipc_queues[wp]: "released_ipc_queues"
  and valid_refills[wp]: "valid_refills scp"
  (simp: crunch_simps wp: crunch_wps)

lemma cancel_all_ipc_budget_sufficient[wp]:
  "\<lbrace>budget_sufficient t and current_time_bounded
    and active_sc_tcb_at t and released_ipc_queues and active_sc_valid_refills\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. budget_sufficient t\<rbrace>"
  unfolding cancel_all_ipc_def
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep; case_tac "ep = IdleEP"; (solves wpsimp)?)
  apply (clarsimp simp: endpoint.case_eq_if)
  apply (rule hoare_seq_ext[OF _ get_epq_sp])
  apply (rule hoare_seq_ext, wpsimp)
   apply (rule hoare_strengthen_post[where Q="\<lambda>_. budget_sufficient t and current_time_bounded
                        and released_ipc_queues and active_sc_valid_refills and active_sc_tcb_at t", rotated])
    apply simp
   apply (rule mapM_x_wp')
   apply (rename_tac tp)
   apply (rule hoare_seq_ext[OF _ gts_sp])
   apply (rename_tac st; case_tac "is_blocked_on_receive st"; clarsimp simp: is_blocked_on_receive_def)
    apply (rename_tac ropt data; case_tac ropt; simp)
     apply wpsimp
     apply (fastforce elim!: active_sc_tcb_at_valid_refills)
    apply (wpsimp wp: reply_unlink_tcb_released_ipc_queues hoare_vcg_all_lift hoare_vcg_imp_lift')
    apply (fastforce elim!: active_sc_tcb_at_valid_refills)
   apply (rule hoare_seq_ext[rotated])
    apply (rename_tac st; case_tac st; simp; rule hoare_return_sp)
   apply (rule hoare_gen_asm, simp)
   apply wpsimp
   apply (fastforce elim!: active_sc_tcb_at_valid_refills)
  apply wpsimp
  done

lemma refill_unblock_check_released_sc_at[wp]:
  "\<lbrace>released_sc_at sc_ptr and valid_refills sc_ptr\<rbrace>
   refill_unblock_check sc_ptr'
   \<lbrace>\<lambda>_. released_sc_at sc_ptr\<rbrace>"
  by (wpsimp simp: released_sc_at_def wp: hoare_vcg_conj_lift)

lemma restart_thread_if_no_fault_released_sc_at[wp]:
  "\<lbrace>released_sc_at sc_ptr and valid_refills sc_ptr\<rbrace>
   restart_thread_if_no_fault t
   \<lbrace>\<lambda>_. released_sc_at sc_ptr\<rbrace>"
  unfolding restart_thread_if_no_fault_def if_cond_refill_unblock_check_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift simp: get_tcb_obj_ref_def)

lemma cancel_all_ipc_released_sc_at[wp]:
  "\<lbrace>released_sc_at scp and current_time_bounded and valid_refills scp\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. released_sc_at scp\<rbrace>"
  apply (clarsimp simp: cancel_all_ipc_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep; case_tac "ep = IdleEP"; (solves wpsimp)?)
  apply (clarsimp simp: endpoint.case_eq_if)
  apply (rule hoare_seq_ext[OF _ get_epq_sp])
  apply (rule hoare_seq_ext, wpsimp)
   apply (rule hoare_strengthen_post[where Q="\<lambda>_. released_sc_at scp and current_time_bounded
                                                  and valid_refills scp"])
    apply (wpsimp wp: mapM_x_wp' gts_wp)
   apply wpsimp+
  done

lemma restart_thread_if_no_fault_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at tp and active_sc_valid_refills\<rbrace>
   restart_thread_if_no_fault t
   \<lbrace>\<lambda>_. released_sc_tcb_at tp\<rbrace>"
  unfolding restart_thread_if_no_fault_def if_cond_refill_unblock_check_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift simp: get_tcb_obj_ref_def)

lemma cancel_all_ipc_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at tp and active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. released_sc_tcb_at tp\<rbrace>"
  apply (clarsimp simp: cancel_all_ipc_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep; case_tac "ep = IdleEP"; (solves wpsimp)?)
  apply (clarsimp simp: endpoint.case_eq_if)
  apply (rule hoare_seq_ext[OF _ get_epq_sp])
  apply (rule hoare_seq_ext, wpsimp)
   apply (rule hoare_strengthen_post[where Q="\<lambda>_. released_sc_tcb_at tp and current_time_bounded
                        and active_sc_valid_refills"])
    apply (wpsimp wp: mapM_x_wp' gts_wp)
   apply wpsimp+
  done

crunches cancel_all_ipc
  for misc[wp]: "\<lambda>s. P (tcb_scps_of s) (sc_tcbs_of s) (idle_thread s)"
  (simp: crunch_simps wp: crunch_wps)

context DetSchedSchedule_AI begin

crunches restart, install_tcb_frame_cap, install_tcb_cap, maybe_sched_context_unbind_tcb,
         maybe_sched_context_bind_tcb, bind_notification, invoke_sched_context,
         invoke_sched_control_configure_flags
  for current_time_bounded[wp]: "current_time_bounded :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv simp: crunch_simps)

end

context DetSchedSchedule_AI_det_ext begin

lemma install_tcb_cap_budget_sufficient[wp]:
  "\<lbrace>invs and tcb_at target and budget_sufficient t and active_sc_valid_refills
    and current_time_bounded and released_ipc_queues and active_sc_tcb_at t\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_. budget_sufficient t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_vcg_imp_lift'
                 cap_delete_fh_lift[where L="budget_sufficient t and current_time_bounded
                   and active_sc_tcb_at t and released_ipc_queues and active_sc_valid_refills"])

crunches cap_delete
  for valid_machine_time[wp]: "valid_machine_time :: det_state \<Rightarrow> _"

lemma install_tcb_cap_valid_machine_time[wp]:
  "install_tcb_cap target slot n slot_opt \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: install_tcb_cap_def
                  wp: check_cap_inv)
  done

lemma tcc_valid_sched:
  "\<lbrace>valid_sched and valid_machine_time and invs and simple_sched_action
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s) and current_time_bounded
    and tcb_inv_wf (ThreadControlCaps target slot fault_handler timeout_handler
                                      croot vroot buffer)
    and ct_active and ct_released\<rbrace>
   invoke_tcb (ThreadControlCaps target slot fault_handler timeout_handler croot vroot buffer)
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: split_def cong: option.case_cong)
  apply wp
       \<comment> \<open>install_tcb_frame_cap\<close>
       apply (wpsimp wp: install_tcb_frame_cap_valid_sched)
      \<comment> \<open>install_tcb_cap slots\<close>
      apply invoke_tcb_install_tcb_cap_helper+
  \<comment> \<open>resolve using precondition\<close>
  apply simp
  apply (strengthen tcb_cap_valid_ep_strgs)
  apply (clarsimp cong: conj_cong)
  apply (intro conjI impI;
         clarsimp simp: is_cnode_or_valid_arch_is_cap_simps tcb_ep_slot_cte_wp_ats real_cte_at_cte
                 dest!: is_valid_vtable_root_is_arch_cap)
     apply (all \<open>clarsimp simp: is_cap_simps cte_wp_at_caps_of_state valid_fault_handler_def\<close>)
    apply (all \<open>clarsimp simp: obj_at_def is_tcb typ_at_eq_kheap_obj cap_table_at_typ\<close>)
    by auto

lemma restart_thread_if_no_fault_ct_in_state_neq:
  "\<lbrace>ct_in_state P and (\<lambda>s. t \<noteq> cur_thread s \<or> (P Inactive \<and> P Restart))\<rbrace>
   restart_thread_if_no_fault t
  \<lbrace>\<lambda>_. ct_in_state P :: det_state \<Rightarrow> _\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp wp: sts_ctis_neq simp: thread_get_def)

lemma reply_unlink_tcb_ct_in_state_neq:
  "\<lbrace>ct_in_state P and (\<lambda>s. t \<noteq> cur_thread s)\<rbrace>
   reply_unlink_tcb t r
  \<lbrace>\<lambda>_. ct_in_state P :: det_state \<Rightarrow> _\<rbrace>"
  unfolding reply_unlink_tcb_def
  by (wpsimp wp: sts_ctis_neq gts_wp get_simple_ko_wp)

lemma install_tcb_cap_active_sc_tcb_at[wp]:
  "\<lbrace>invs and tcb_at target  and active_sc_tcb_at t \<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. active_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift)

lemma install_tcb_cap_budget_ready[wp]:
  "\<lbrace>invs and tcb_at target and budget_ready t \<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. budget_ready t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift hoare_vcg_imp_lift')

lemma install_tcb_cap_released_sc_at[wp]:
  "\<lbrace>invs and tcb_at target and released_sc_at scp and current_time_bounded and valid_refills scp\<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. released_sc_at scp :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_vcg_imp_lift'
                 cap_delete_fh_lift[where L="released_sc_at scp and current_time_bounded
                                             and valid_refills scp"])

lemma install_tcb_cap_is_active_sc[wp]:
  "\<lbrace>invs and tcb_at target and is_active_sc sc \<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. is_active_sc sc :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift)

lemma install_tcb_cap_released_sc_tcb_at[wp]:
  "\<lbrace>invs and tcb_at target and released_sc_tcb_at t and current_time_bounded
    and active_sc_valid_refills\<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. released_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_vcg_imp_lift'
                 cap_delete_fh_lift[where L="released_sc_tcb_at t and current_time_bounded
                                             and active_sc_valid_refills"])

lemma install_tcb_cap_ct_active:
  "\<lbrace>invs and tcb_at target and ct_active\<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. ct_active :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  apply wpsimp
  apply (wpsimp wp: check_cap_inv )
  apply (simp)
  apply (rule valid_validE, rule cap_delete_fh_lift)
  by wpsimp+

lemma install_tcb_cap_not_ipc_queued_thread[wp]:
  "\<lbrace>tcb_at target and not_ipc_queued_thread target and invs\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_. not_ipc_queued_thread target\<rbrace>"
  apply (simp add: tcb_at_kh_simps[symmetric])
  apply wp_pre
   apply (rule hoare_strengthen_post, rule install_tcb_cap_not_ipc_queued_thread[where t=target])
   apply (simp add: not_pred_tcb_at_strengthen)
  apply (simp add: not_pred_tcb pred_neg_def)
  done

lemma install_tcb_cap_not_in_release_q[wp]:
  "\<lbrace>invs and tcb_at target and not_in_release_q t\<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_. not_in_release_q t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift hoare_vcg_const_imp_lift)

lemma install_tcb_cap_timeout_faulted_tcb_at:
  "\<lbrace>invs and tcb_at target and (\<lambda>s. P (timeout_faulted_tcb_at t s)) \<rbrace>
   install_tcb_cap target slot 3 slot_opt
  \<lbrace>\<lambda>_ s:: det_state. P (timeout_faulted_tcb_at t s)\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift)

(* FIXME RT: move? *)
lemma install_tcb_cap_not_is_blocked_thread_states[wp]:
  "\<not> (P Restart) \<Longrightarrow> \<not> (P Inactive) \<Longrightarrow>
   \<lbrace>st_tcb_at (not P) target and invs\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_. st_tcb_at (not P) target\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_fh_lift cancel_all_ipc_st_tcb_at hoare_vcg_const_imp_lift
           simp: pred_neg_def)+

lemma install_tcb_cap_blocked_on_recv_ntfn_tcb_at[wp]:
  "\<lbrace>tcb_at target and (\<lambda>s. \<not> blocked_on_recv_ntfn_tcb_at target s) and invs\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_ s. \<not> blocked_on_recv_ntfn_tcb_at target s\<rbrace>"
  apply (simp add: tcb_at_kh_simps[symmetric])
  apply wp_pre
   apply (rule hoare_strengthen_post)
    apply (rule install_tcb_cap_not_is_blocked_thread_states[where P="is_blocked_on_recv_ntfn", simplified])
   apply (simp add: not_pred_tcb_at_strengthen)
  apply (simp add: not_pred_tcb pred_neg_def)
  done

lemma install_tcb_cap_blocked_on_send_tcb_at[wp]:
  "\<lbrace>tcb_at target and (\<lambda>s. \<not> blocked_on_send_tcb_at target s) and invs\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_ s. \<not> blocked_on_send_tcb_at target s\<rbrace>"
  apply (simp add: tcb_at_kh_simps[symmetric])
  apply wp_pre
   apply (rule hoare_strengthen_post)
    apply (rule install_tcb_cap_not_is_blocked_thread_states[where P="is_blocked_on_send", simplified])
   apply (simp add: not_pred_tcb_at_strengthen)
  apply (simp add: not_pred_tcb pred_neg_def)
  done

lemma install_tcb_cap_blocked_on_reply_tcb_at[wp]:
  "\<lbrace>tcb_at target and (\<lambda>s. \<not> blocked_on_reply_tcb_at target s) and invs\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_ s. \<not> blocked_on_reply_tcb_at target s\<rbrace>"
  apply (simp add: tcb_at_kh_simps[symmetric])
  apply wp_pre
   apply (rule hoare_strengthen_post)
    apply (rule install_tcb_cap_not_is_blocked_thread_states[where P="is_blocked_on_reply", simplified])
   apply (simp add: not_pred_tcb_at_strengthen)
  apply (simp add: not_pred_tcb pred_neg_def)
  done

lemma install_tcb_cap_heap_refs_eq_tcb_scps_of[wp]:
  "\<lbrace>invs and tcb_at target and (\<lambda>s. \<not> heap_ref_eq sc_ptr tcb_ptr (tcb_scps_of s))\<rbrace>
   install_tcb_cap target slot 3 slot_opt
   \<lbrace>\<lambda>_ s :: det_state. \<not> heap_ref_eq sc_ptr tcb_ptr (tcb_scps_of s)\<rbrace>"
  unfolding install_tcb_cap_def
  apply (wpsimp wp: check_cap_inv cap_delete_fh_lift hoare_vcg_imp_lift')
  done

lemma tcs_valid_sched:
  "\<lbrace>valid_sched and valid_machine_time and invs and simple_sched_action
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s) and current_time_bounded
    and tcb_inv_wf (ThreadControlSched target slot fault_handler mcp priority sc)
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and ct_active and ct_released and ct_not_in_release_q\<rbrace>
     invoke_tcb (ThreadControlSched target slot fault_handler mcp priority sc)
   \<lbrace>\<lambda>rv. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (simp add: split_def cong: option.case_cong)
  apply (wp maybeM_wp_drop_None)
      \<comment> \<open>bind/unbind sched context\<close>
      apply (clarsimp cong: conj_cong)
      apply (wpsimp wp: maybe_sched_context_bind_tcb_valid_sched
                        maybe_sched_context_unbind_tcb_valid_sched, assumption)
     apply (strengthen not_cur_thread_2_simps)
     \<comment> \<open>set priority\<close>
     apply (clarsimp cong: conj_cong)
     apply (rule hoare_post_add[where R="\<lambda>_.valid_sched and simple_sched_action"])
     apply (clarsimp cong: conj_cong)
     apply (wp maybeM_wp_drop_None)
     apply (wpsimp wp: set_priority_valid_sched hoare_vcg_all_lift hoare_vcg_imp_lift)
     apply assumption
    \<comment> \<open>set mcpriority\<close>
    apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift )
   \<comment> \<open>install_tcb_cap\<close>
   apply (clarsimp cong: conj_cong)
   apply (rule hoare_vcg_E_elim, wpsimp)
   apply (rule valid_validE_R)
   apply ((wpsimp wp: hoare_vcg_all_lift install_tcb_cap_ct_active
                      hoare_vcg_imp_lift install_tcb_cap_timeout_faulted_tcb_at
                  split: if_split
         | rule valid_validE, wps)+)[1]
  \<comment> \<open>resolve using preconditions\<close>
  apply (clarsimp, frule tcb_at_invs, frule valid_sched_active_sc_valid_refills)
  apply (prop_tac "active_sc_valid_refills s \<and> released_ipc_queues s", fastforce)
  apply (clarsimp simp: obj_at_def is_tcb)
  apply (clarsimp simp: tcb_at_kh_simps[symmetric]
                        pred_tcb_at_def obj_at_def sc_at_released_kh_simps released_sc_at_def
                 split: option.splits cong: conj_cong;
        intro conjI; (erule disjE)?;
        clarsimp dest!: active_sc_valid_refillsE
                  simp: ipc_queued_thread_state_def2 sc_tcb_sc_at_def obj_at_def
                 dest!: sym[of _ "tcb_sched_context _"])
  by (drule_tac tp=x in sym_ref_tcb_sc[OF invs_sym_refs], fastforce+)+

end

crunch not_cur_thread[wp]: reply_remove "not_cur_thread thread"
  (wp: crunch_wps hoare_vcg_if_lift2)

lemma possible_switch_to_ready_or_release[wp]:
  "possible_switch_to thread \<lbrace>ready_or_release\<rbrace>"
  apply (clarsimp simp: possible_switch_to_def when_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip, wpsimp)+
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  done

lemma valid_refills_refills_sum:
  "valid_refills scp s \<Longrightarrow>
    obj_at (\<lambda>ko. \<exists>sc n. ko= SchedContext sc n
       \<and> refills_sum (sc_refills sc) = sc_budget sc) scp s"
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps sc_valid_refills_def rr_valid_refills_def)
  by (case_tac "sc_period y = 0"; simp)

lemma valid_refills_sc_refill_max:
  "valid_refills scp s \<Longrightarrow>
    obj_at (\<lambda>ko. \<exists>sc n. ko = SchedContext sc n
                        \<and> length (sc_refills sc) \<le> sc_refill_max sc) scp s"
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps sc_valid_refills_def)
  by (case_tac "sc_period y = 0"; fastforce simp: MIN_REFILLS_def rr_valid_refills_def)

lemma sc_valid_refills_refills_sum:
  "sc_valid_refills sc \<Longrightarrow> refills_sum (sc_refills sc) = sc_budget sc"
  apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def)
  by (case_tac "sc_period sc = 0"; simp)

lemma valid_refills_consumed_time_update[iff]:
  "valid_refills p (consumed_time_update f s) = valid_refills p s"
  by simp

lemma sc_valid_refills_unat_sum_list_at_most_unat_max_word:
  "\<lbrakk>sc_valid_refills sc; sc_period sc \<noteq> 0; MIN_BUDGET \<le> sc_budget sc\<rbrakk>
   \<Longrightarrow> refills_unat_sum (sc_refills sc) \<le> unat max_time"
  apply (rule unat_sum_list_at_most_unat_max_word)
      apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def split: if_splits)+
  done

lemma valid_refills_scheduler_action_update[iff]:
  "valid_refills p (scheduler_action_update f s) = valid_refills p s"
  by simp

lemma valid_refills_ready_queues_update[iff]:
  "valid_refills p (ready_queues_update f s) = valid_refills p s"
  by simp

lemma valid_refills_release_queue_update[iff]:
  "valid_refills p (release_queue_update f s) = valid_refills p s"
  by simp

lemma valid_refills_kheap_tcb_update[iff]:
  "tcb_at t s \<Longrightarrow> valid_refills p (s\<lparr>kheap := kheap s(t \<mapsto> TCB tcb)\<rparr>) = valid_refills p s"
  by (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps is_tcb)

lemma valid_refills_exst [iff]:
  "valid_refills p (trans_state f s) = valid_refills p s"
  by (simp add: valid_state_def)

lemma valid_refills_reprogram_timer_update [iff]:
  "valid_refills p (reprogram_timer_update f s) = valid_refills p s"
  by (simp add: valid_state_def)

lemma postpone_valid_sched_misc[wp]:
  "postpone t \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                     (idle_thread s) (scheduler_action s)
                     (kheap s)\<rbrace>"
  unfolding postpone_def
  by (wpsimp wp: hoare_drop_imp)

lemma sched_context_resume_valid_sched_misc[wp]:
  "sched_context_resume sc_ptr
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (scheduler_action s) (kheap s)\<rbrace>"
  by (wpsimp wp: hoare_drop_imp simp: sched_context_resume_def)

lemma update_sched_context_valid_refills_no_budget_update_const:
  "\<lbrace>valid_refills scptr
    and K (scptr=p \<longrightarrow> sc_valid_refills newsc)\<rbrace>
   update_sched_context p (\<lambda>_. newsc)
   \<lbrace>\<lambda>_. valid_refills scptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps)

lemma update_sched_context_valid_refills:
  "\<lbrace>valid_refills scptr
    and K (sc_valid_refills newsc)\<rbrace>
   update_sched_context p (\<lambda>_. newsc)
   \<lbrace>\<lambda>_. valid_refills scptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps)

lemma update_sched_context_valid_refills':
  "\<lbrace>K (sc_valid_refills newsc)\<rbrace>
   update_sched_context p (\<lambda>_. newsc)
   \<lbrace>\<lambda>_. valid_refills p\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps)

lemma update_sched_context_valid_refills_no_budget_update:
  "\<lbrace>valid_refills scptr
    and K (\<forall>sc. sc_valid_refills sc \<longrightarrow> sc_valid_refills (f sc))\<rbrace>
   update_sched_context p f
   \<lbrace>\<lambda>_. valid_refills scptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps obj_at_def)

lemma maybe_add_empty_tail_refill_ready[wp]:
  "maybe_add_empty_tail sc_ptr \<lbrace>\<lambda>s. Q (pred_map (refill_ready_sc x) (sc_refill_cfgs_of s) scp)\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def set_refills_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refill_ready_sc_def)
  by (case_tac "sc_refills sc"; simp)

lemma maybe_add_empty_tail_is_refill_ready[wp]:
  "maybe_add_empty_tail sc_ptr \<lbrace>\<lambda>s. Q (is_refill_ready scp s)\<rbrace>"
  by (rule hoare_lift_Pf[where f = cur_time]; wpsimp)

lemma maybe_add_empty_tail_is_refill_sufficient[wp]:
  "\<lbrace>is_refill_sufficient usage scp
    and (\<lambda>s. scp = sc_ptr \<longrightarrow>
             pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) scp)\<rbrace>
   maybe_add_empty_tail sc_ptr
   \<lbrace>\<lambda>_. is_refill_sufficient usage scp\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def set_refills_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp)
  by (auto simp: vs_all_heap_simps obj_at_def refill_sufficient_def refill_capacity_def
          split: if_splits)

crunches set_refills, refill_update, refill_new
  for pred_tcb_at[wp]: "\<lambda>s. P (pred_tcb_at p Q t s)"
  (wp: crunch_wps)

lemma set_sc_obj_ref_refill_cfgs_no_change:
  "\<lbrace>\<lambda>s. Q (pred_map R (sc_refill_cfgs_of s) scp)
        \<and> (scp = sc_ptr \<longrightarrow> (\<forall>sc. Q (R (sc_refill_cfg_of sc)) \<longrightarrow> Q (R (sc_refill_cfg_of (f (\<lambda>_. x) sc)))))\<rbrace>
   set_sc_obj_ref f sc_ptr x
   \<lbrace>\<lambda>rv s.  Q (pred_map R (sc_refill_cfgs_of s) scp)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: pred_map_simps vs_all_heap_simps obj_at_def)

lemmas set_sc_obj_ref_refill_cfgs_no_change_set[wp] =
  set_sc_obj_ref_refill_cfgs_no_change[where f = sc_period_update
   and R="\<lambda>x. P (scrc_refills x) (scrc_budget x) (scrc_refill_max x)" for P, simplified]
  set_sc_obj_ref_refill_cfgs_no_change[where f = sc_refills_update
   and R="\<lambda>x. P (scrc_period x) (scrc_budget x) (scrc_refill_max x)" for P, simplified]
  set_sc_obj_ref_refill_cfgs_no_change[where f = sc_budget_update
   and R="\<lambda>x. P (scrc_refills x) (scrc_period x) (scrc_refill_max x)" for P, simplified]
  set_sc_obj_ref_refill_cfgs_no_change[where f = sc_refill_max_update
   and R="\<lambda>x. P (scrc_refills x) (scrc_budget x) (scrc_period x)" for P, simplified]

lemma sc_refill_max_update_active_scrc[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr then Q (active_sc x) else Q (pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>
   set_sc_obj_ref sc_refill_max_update sc_ptr x
   \<lbrace>\<lambda>rv s.  Q (pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: pred_map_simps vs_all_heap_simps obj_at_def)

lemma sc_refills_update_refill_sufficient_sc[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr then Q (refill_sufficient usage (hd x)) else Q (pred_map (refill_sufficient_sc usage) (sc_refill_cfgs_of s) scp)\<rbrace>
   set_sc_obj_ref sc_refills_update sc_ptr x
   \<lbrace>\<lambda>rv s.  Q (pred_map (refill_sufficient_sc usage) (sc_refill_cfgs_of s) scp)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: pred_map_simps vs_all_heap_simps obj_at_def)

lemma sc_refills_update_is_refill_ready[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr then Q (refill_ready (cur_time s) (hd x)) else Q (is_refill_ready scp s)\<rbrace>
   set_sc_obj_ref sc_refills_update sc_ptr x
   \<lbrace>\<lambda>rv s.  Q (is_refill_ready scp s)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: pred_map_simps vs_all_heap_simps obj_at_def)

lemma sc_refills_update_refill_ready_sc[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr then Q (refill_ready t (hd x)) else Q (pred_map (refill_ready_sc t) (sc_refill_cfgs_of s) scp)\<rbrace>
   set_sc_obj_ref sc_refills_update sc_ptr x
   \<lbrace>\<lambda>rv s.  Q (pred_map (refill_ready_sc t) (sc_refill_cfgs_of s) scp)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: pred_map_simps vs_all_heap_simps obj_at_def)

lemma refill_new_is_refill_ready[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr
        then Q (cur_time s \<le> cur_time s + kernelWCET_ticks)
        else Q (is_refill_ready scp s)\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv s. Q (is_refill_ready scp s)\<rbrace>"
  apply (rule hoare_weaken_pre)
  apply (rule hoare_lift_Pf3[where f=cur_time, rotated], wpsimp)
  unfolding refill_new_def
  apply (wpsimp wp: is_round_robin_wp update_sched_context_wp)
  by (auto simp: refill_ready_def obj_at_def pred_map_def vs_all_heap_simps split: if_splits)

lemma refill_new_is_refill_sufficient[wp]:
  "\<lbrace>\<lambda>s. if scp = sc_ptr
        then Q (MIN_BUDGET \<le> budget)
        else Q (is_refill_sufficient 0 scp s)\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv s. Q (is_refill_sufficient 0 scp s)\<rbrace>"
  apply (rule hoare_weaken_pre)
  apply (rule hoare_lift_Pf3[where f=cur_time, rotated], wpsimp)
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def set_refills_def get_refills_def
  apply (wpsimp wp: is_round_robin_wp update_sched_context_wp)
  apply (clarsimp simp: refill_sufficient_def refill_capacity_def obj_at_def pred_map_def
                        vs_all_heap_simps
                 split: if_splits)
  done

lemma refill_head_overlapping_refills_overlapping:
  "\<lbrakk>the (refill_head_overlapping sc_ptr s); pred_map \<top> (scs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. r_time (hd (tl (scrc_refills cfg)))
                       \<le> r_time (hd (scrc_refills cfg)) + r_amount (hd (scrc_refills cfg)))
                 (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (insert no_ofailD[OF no_ofail_refill_head_overlapping])
  apply (clarsimp simp: refill_head_overlapping_def obind_def read_sched_context_def)
  done

lemma merge_refills_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply merge_refills_simple
  apply (rename_tac sc n)
  apply (rule_tac left="[\<lparr>r_time = r_time (refill_hd sc),
                          r_amount = r_amount (hd (tl (sc_refills sc))) + r_amount (refill_hd sc)\<rparr>]"
              and right="tl (tl (sc_refills sc))"
               in ordered_disjoint_append
         ; fastforce?)
   apply (blast intro: ordered_disjoint_sublist)
  apply clarsimp
  apply (subst unat_add_lem')
   apply (clarsimp simp: unat_minus_one_word refills_unat_sum_def)
   apply (case_tac "sc_refills sc"; clarsimp)
   apply (rename_tac list)
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list
                      simp: tl_Nil)
   apply fastforce
  apply (rule_tac j="unat (r_time (hd (tl (sc_refills sc))))
                     + unat (r_amount (hd (tl (sc_refills sc))))"
               in le_trans)
   apply (clarsimp simp: ordered_disjoint_def)
   apply (drule_tac x=0 in spec)
   apply clarsimp
   apply (metis hd_conv_nth length_greater_0_conv length_ineq_not_Nil(2) non_empty_tail_length
                nth_tl tail_nonempty_length)
  apply (clarsimp simp: ordered_disjoint_def)
  apply (metis (no_types, lifting) hd_conv_nth length_greater_0_conv length_ineq_not_Nil(1)
               length_tl nth_tl numeral_nat(7) tail_nonempty_length)
  done

lemma refill_update_is_refill_sufficient[wp]:
  "\<lbrace>is_refill_sufficient 0 scp and K (scp = sc_ptr \<longrightarrow> MIN_BUDGET \<le> budget)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. is_refill_sufficient 0 scp\<rbrace>"
  unfolding refill_update_def maybe_add_empty_tail_def set_refills_def refill_add_tail_def
            update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: is_round_robin_wp update_sched_context_wp hoare_drop_imps get_refills_wp)
  apply (clarsimp simp: refill_sufficient_def refill_capacity_def obj_at_def
                        vs_all_heap_simps)
  done

lemma no_ofail_head_insufficient:
  "no_ofail (\<lambda>s. \<exists>sc n. kheap s sc_ptr = Some (SchedContext sc n)) (head_insufficient sc_ptr)"
  unfolding head_insufficient_def no_ofail_def
  apply (clarsimp simp: obind_def obj_at_def read_sched_context_def)
  done

lemma bound_head_insufficient:
  "kheap s sc_ptr = Some (SchedContext sc n) \<Longrightarrow> bound (head_insufficient sc_ptr s)"
  apply (clarsimp simp: head_insufficient_def obind_def read_sched_context_def)
  done

lemma head_insufficient_true_imp_insufficient:
  "\<lbrakk>the (head_insufficient sc_ptr s); pred_map \<top> (scs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. r_amount (scrc_refill_hd cfg) < MIN_BUDGET) (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (frule bound_head_insufficient)
  apply (fastforce simp: head_insufficient_def obind_def vs_all_heap_simps read_sched_context_def)
  done

lemma head_insufficient_false_imp_sufficient:
  "\<lbrakk>\<not> (the (head_insufficient sc_ptr s)); pred_map \<top> (scs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (frule bound_head_insufficient)
  apply (fastforce simp: head_insufficient_def obind_def vs_all_heap_simps read_sched_context_def)
  done

method non_overlapping_merge_refills_simple
  = (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def merge_refill_def
                    update_refill_hd_rewrite update_sched_context_set_refills_rewrite
     , wpsimp wp: set_refills_wp get_refills_wp
     , (clarsimp simp: vs_all_heap_simps obj_at_def)?)

lemma non_overlapping_merge_refills_nonempty_refills:
  "non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  done

lemma head_insufficient_loop_nonempty_refills:
  "head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]; fastforce?)
  apply (wpsimp wp: non_overlapping_merge_refills_nonempty_refills)
  done

lemma head_insufficient_length_at_least_two:
  "\<lbrakk>pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
             (sc_refill_cfgs_of s) sc_ptr;
    the ((head_insufficient sc_ptr) s)\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
  apply (prop_tac "\<not> pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (scrc_refill_hd cfg))
                              (sc_refill_cfgs_of s) sc_ptr")
   apply (fastforce dest: head_insufficient_true_imp_insufficient
                    simp: vs_all_heap_simps refills_unat_sum_def)
  apply (clarsimp simp: vs_all_heap_simps refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp simp: word_le_nat_alt)
  done

lemma non_overlapping_merge_refills_refills_unat_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg))
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; simp?)
  apply (rename_tac list)
  apply (subst unat_add_lem')
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list)
   apply (clarsimp simp: unat_minus_one_word)
  apply (case_tac list; simp)
  done

lemma non_overlapping_merge_refills_refills_unat_sum_lower_bound:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (subst unat_add_lem')
   apply (case_tac "sc_refills sc"; clarsimp)
   apply (clarsimp simp: unat_minus_one_word)
   apply (case_tac list; clarsimp)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (clarsimp simp: unat_minus_one_word)
  apply (case_tac list; clarsimp)
  done

lemma head_insufficient_loop_refills_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    defer
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def merge_refill_def
                        update_refill_hd_rewrite update_sched_context_set_refills_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (frule head_insufficient_length_at_least_two, clarsimp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (rename_tac list)
  apply (case_tac list; clarsimp)
  apply (clarsimp simp: add_ac)
  done

lemma non_overlapping_merge_refills_refills_unat_sum_equals_budget:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; simp?)
  apply (rename_tac list)
  apply (prop_tac "unat (sc_budget sc) \<le> unat max_time", fastforce)
  apply (subst unat_add_lem')
   apply (prop_tac "unat (r_amount (hd list)) \<le> sum_list (map unat (map r_amount list))")
    apply (fastforce intro: member_le_sum_list)
   apply (clarsimp simp: unat_minus_one_word)
  apply (case_tac list; simp)
  done

lemma head_insufficient_loop_refills_unat_sum_equals_budget:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_equals_budget)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def merge_refill_def
                        update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (frule head_insufficient_length_at_least_two, clarsimp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (rename_tac list)
  apply (case_tac list; clarsimp)
  apply (clarsimp simp: add_ac refills_unat_sum_def)
  apply (subst unat_add_lem')
   apply (prop_tac "unat (sc_budget sc) \<le> unat max_time", fastforce)
   apply (clarsimp simp: unat_minus_one_word)
  apply presburger
  done

lemma non_overlapping_merge_refills_ordered_disjoint_helper:
  "\<lbrakk>ordered_disjoint (a # r1 # rs); sum_list (map unat (map r_amount (a # r1 # rs))) \<le> unat max_time\<rbrakk>
   \<Longrightarrow> ordered_disjoint (\<lparr>r_time = r_time r1 - r_amount a, r_amount = r_amount a + r_amount r1\<rparr> # rs)"
  apply (rule_tac left="[\<lparr>r_time = r_time r1 - r_amount a, r_amount = r_amount a + r_amount r1\<rparr>]"
              and right="rs"
               in ordered_disjoint_append)
     apply (clarsimp simp: ordered_disjoint_def)
    apply (meson ordered_disjoint_tail)
   apply clarsimp
   apply (subst unat_sub, clarsimp simp: word_le_nat_alt)
    apply (clarsimp simp: ordered_disjoint_def)
    apply (drule_tac x=0 in spec)
    apply fastforce
   apply (prop_tac "unat (r_amount a) \<le> unat (r_time r1)")
    apply (fastforce simp: ordered_disjoint_def)
   apply (subst unat_add_lem', clarsimp simp: unat_minus_one_word)
   apply (clarsimp simp: ordered_disjoint_def)
   apply (drule_tac x=1 in spec)
   apply (simp add: hd_conv_nth)
  apply simp
  done

lemma non_overlapping_merge_refills_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                                         (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (clarsimp simp: refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; (solves simp)?)
  apply (rename_tac list)
  apply (case_tac list; (solves simp)?)
  apply (fastforce dest: non_overlapping_merge_refills_ordered_disjoint_helper
                   simp: add_ac cong: refill.ext_split)
  done

lemma head_insufficient_loop_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    defer
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (wpsimp wp: non_overlapping_merge_refills_ordered_disjoint)
  done

lemma head_time_plus_budget_bounded:
  "\<lbrakk>no_overflow refills; ordered_disjoint refills\<rbrakk>
   \<Longrightarrow> unat (r_time (hd refills)) + sum_list (map unat (map r_amount refills)) \<le> unat max_time"
  supply map_map[simp del]
  apply (induct refills rule: length_induct)
  apply (rename_tac xs)
  apply (case_tac xs; simp)
  apply (rename_tac xs a list)
  apply (case_tac list)
   apply (fastforce simp: no_overflow_def)
  apply (drule_tac x=list in spec)
  apply (elim impE; fastforce?)
    apply (fastforce intro: no_overflow_tail)
   apply (fastforce intro: ordered_disjoint_tail)
  apply (rule_tac j="unat (r_time (hd list)) + sum_list (map unat (map r_amount list))" in le_trans)
   apply (fastforce simp: ordered_disjoint_def)
  apply assumption
  done

lemma non_overlapping_merge_refills_no_overflow_helper:
  "\<lbrakk>no_overflow (a # r1 # rs); ordered_disjoint (a # r1 # rs)\<rbrakk>
   \<Longrightarrow> no_overflow (\<lparr>r_time = r_time r1 - r_amount a, r_amount = r_amount a + r_amount r1\<rparr> # rs)"
  apply (frule (1) head_time_plus_budget_bounded)
  apply (rule_tac left="[\<lparr>r_time = r_time r1 - r_amount a, r_amount = r_amount a + r_amount r1\<rparr>]"
              and right="rs"
               in no_overflow_append)
    apply (clarsimp simp: no_overflow_def)
    apply (prop_tac "unat (r_amount a) \<le> unat (r_time r1)")
     apply (fastforce simp: ordered_disjoint_def)
    apply (subst unat_sub)
     apply (clarsimp simp: word_le_nat_alt)
    apply (subst unat_add_lem', clarsimp simp:  unat_minus_one_word)
    apply linarith
   apply (meson no_overflow_tail)
  apply simp
  done

lemma non_overlapping_merge_refills_no_overflow:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg))
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; (solves simp)?)
  apply (rename_tac list)
  apply (case_tac list; (solves simp)?)
  apply (fastforce dest: non_overlapping_merge_refills_no_overflow_helper
                   simp: add_ac cong: refill.ext_split)
  done

lemma head_insufficient_loop_no_overflow:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
     defer
     apply (wpsimp wp: non_overlapping_merge_refills_ordered_disjoint)
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (wpsimp wp: non_overlapping_merge_refills_no_overflow)
  apply (fastforce dest: head_insufficient_length_at_least_two)
  done

lemma head_insufficient_loop_refills_window:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow>  pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg))
                         (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
     defer
     apply (wpsimp wp: non_overlapping_merge_refills_ordered_disjoint)
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def merge_refill_def
                        update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (frule head_insufficient_length_at_least_two, clarsimp)
  apply (clarsimp simp: vs_all_heap_simps refills_unat_sum_def obj_at_def window_def)
  apply (rename_tac sc n)
  apply (prop_tac "last (tl (tl (sc_refills sc))) = refill_tl sc")
   apply (case_tac "sc_refills sc"; simp)
   apply (rename_tac list)
   apply (case_tac list; simp)
  apply (prop_tac "unat (r_time (refill_hd sc))
                    \<le> unat (r_time (hd (tl (sc_refills sc))) - r_amount (refill_hd sc))")
   apply (subst unat_sub)
    apply (fastforce simp: ordered_disjoint_def word_le_nat_alt hd_conv_nth nth_tl tl_Nil)
   apply (fastforce simp: ordered_disjoint_def hd_conv_nth nth_tl tl_Nil)
  apply clarsimp
  done

lemma head_insufficient_loop_hd_r_time:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. unat (r_time (last (scrc_refills cfg))) \<le> P (cur_time s))
                      (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                         (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg))) \<le> P (cur_time s))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg))) \<le> P (cur_time s))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
        defer
        apply (wpsimp wp: non_overlapping_merge_refills_ordered_disjoint)
       apply (wpsimp wp: non_overlapping_merge_refills_no_overflow)
       apply (fastforce dest: head_insufficient_length_at_least_two)
      apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
      apply (fastforce dest: head_insufficient_length_at_least_two)
     apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
     apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_nonempty_refills)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def)
   apply (rename_tac sc n)
   apply (rule_tac y="unat (r_time (refill_tl sc))" in order_trans
          ; fastforce?)
   apply (frule_tac k=0 and l="length (sc_refills sc) - 1"
                 in ordered_disjoint_no_overflow_implies_sorted
          ; fastforce?)
   apply (simp add: hd_conv_nth last_conv_nth unat_arith_simps(1))
  apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def merge_refill_def
                        update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (frule head_insufficient_length_at_least_two, clarsimp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (intro conjI impI)
   apply (subst unat_sub)
    apply (clarsimp simp: word_le_nat_alt ordered_disjoint_def)
    apply (drule_tac x=0 in spec)
    apply clarsimp
    apply (metis add_leE hd_conv_nth hd_tl_nth numeral_nat(7))
   apply (rename_tac sc n)
   apply (rule_tac y="unat (r_time (hd (tl (sc_refills sc))))" in order_trans
          ; fastforce?)
   apply (frule_tac k=0 and l=1 in ordered_disjoint_no_overflow_implies_sorted
          ; fastforce?)
   apply (metis Nitpick.size_list_simp(2) One_nat_def hd_conv_nth last_conv_nth last_tl length_tl
                rel_simps(71))
  apply (simp add: last_tl tl_Nil)
  done

lemma head_insufficient_loop_hd_r_time_same:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) \<le> P (cur_time s))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow>  pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (hd (scrc_refills cfg)))
                                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) \<le> P (cur_time s))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (rule hoare_weaken_pre)
   apply (rule hoare_pre_cont)
  apply (fastforce dest: head_insufficient_true_imp_insufficient
                   simp: vs_all_heap_simps refills_unat_sum_def)
  done

lemma head_insufficient_loop_MIN_BUDGET_in_head:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                      (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                         (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (hd (scrc_refills cfg)))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (hd (scrc_refills cfg)))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
     apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
     apply (fastforce dest: head_insufficient_length_at_least_two)
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_nonempty_refills)
  apply (fastforce dest: head_insufficient_false_imp_sufficient
                   simp: vs_all_heap_simps refills_unat_sum_def)
  done

lemma non_overlapping_merge_refills_length_bounded:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr \<longrightarrow>  pred_map (\<lambda>cfg. 1 < length (scrc_refills cfg))
                                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply fastforce
  done

lemma head_insufficient_loop_length_bounded:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow>  pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                         (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) \<le> unat max_time)
                           (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  apply (cases "sc_ptr' \<noteq> sc_ptr")
   apply head_insufficient_loop_simple
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    defer
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest: head_insufficient_length_at_least_two)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum)
   apply (fastforce dest: head_insufficient_length_at_least_two)
  apply (wpsimp wp: non_overlapping_merge_refills_length_bounded)
  apply (fastforce dest: head_insufficient_length_at_least_two
                   simp: vs_all_heap_simps obj_at_def)
  done

lemma valid_refills_unbundled:
  "\<lbrakk>\<not> round_robin sc_ptr s; sp_valid_refills_unbundled sc_ptr s\<rbrakk> \<Longrightarrow> valid_refills sc_ptr s"
  apply (fastforce simp: vs_all_heap_simps round_robin_def sc_valid_refills_def)
  done

lemma refill_new_active_sc_tcb_at:
  "\<lbrace>\<lambda>s. if (pred_map_eq (Some sc_ptr) (tcb_scps_of s) t) then 0 < mrefills else active_sc_tcb_at t s\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  unfolding active_sc_tcb_at_def2
  apply (wpsimp wp: hoare_vcg_ex_lift)
  by (fastforce simp: active_sc_def vs_all_heap_simps pred_map_def tcb_at_kh_simps split: if_splits)

lemma refill_new_budget_ready:
  "\<lbrace>\<lambda>s. if (pred_map_eq (Some sc_ptr) (tcb_scps_of s) t) then (current_time_bounded s) else budget_ready t s\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. budget_ready t\<rbrace>"
  unfolding budget_ready_def2
  apply (wpsimp wp: hoare_vcg_ex_lift)
  by (auto simp: vs_all_heap_simps tcb_at_kh_simps split: if_splits dest: cur_time_no_overflow)

lemma update_sched_context_not_active_sc_tcb_at:
  "\<lbrace>\<lambda>s. \<not> active_sc_tcb_at t s
        \<and> (\<forall>sc. pred_map_eq (Some sc_ptr) (tcb_scps_of s) t
                \<longrightarrow> \<not> sc_active (f sc))\<rbrace>
   update_sched_context sc_ptr f
   \<lbrace>\<lambda>x s. \<not> active_sc_tcb_at t s\<rbrace>"
   apply (wpsimp wp: update_sched_context_wp)
   apply (clarsimp simp: vs_all_heap_simps split: if_splits)
   done

lemma refill_new_valid_blocked_no_sc_tcb:
  "\<lbrace>valid_blocked and K (0 < mrefills)
    and (\<lambda>s. \<exists>sc n. kheap s sc_ptr = Some (SchedContext sc n) \<and> sc_tcb sc = None)
    and (\<lambda>s. sym_refs (state_refs_of s))\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_blocked\<rbrace>"
  supply if_split [split del]
  unfolding refill_new_def valid_blocked_defs maybe_add_empty_tail_def refill_add_tail_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' is_round_robin_wp
                    update_sched_context_not_active_sc_tcb_at hoare_vcg_if_lift2 hoare_vcg_disj_lift)
  apply (intro conjI;
         intro impI allI;
         clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_eq_def;
         frule sym_ref_tcb_sc; fastforce?)
  done

lemma refill_new_not_active_sc:
  "\<lbrace>\<lambda>s. if scp = sc_ptr then mrefills = 0 else \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv s.  \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>"
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: set_refills_wp is_round_robin_wp update_sched_context_wp)
  apply (clarsimp simp: active_sc_def vs_all_heap_simps obj_at_def)
  done

lemma refill_new_bounded_release_time[wp]:
  "\<lbrace>\<lambda>s. if scp = p then current_time_bounded s
                   else bounded_release_time scp s\<rbrace>
   refill_new p max_refills budget period
   \<lbrace>\<lambda>s. bounded_release_time scp\<rbrace>"
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp set_refills_wp)
  by (clarsimp simp: vs_all_heap_simps cfg_bounded_release_time_def obj_at_def current_time_bounded_def)

lemma no_underflow_sub_plus:
  "unat k \<le> unat new_budget \<Longrightarrow>
   unat (new_budget - k :: time) + unat k \<le> unat max_time"
  apply (subst unat_split_plus[symmetric]; simp)
   apply (rule word_sub_le; simp add: word_le_nat_alt[symmetric])
  done

lemma refill_new_valid_refills[wp]:
  "\<lbrace>(\<lambda>s. unat (cur_time s) + unat period \<le> unat max_time)
    and (\<lambda>s. if scptr \<noteq> p then valid_refills scptr s else \<exists>sc n. ko_at (SchedContext sc n) p s)
    and K (if period=0
           then max_refills = MIN_REFILLS \<and> MIN_BUDGET \<le> budget \<and> budget \<le> MAX_PERIOD
           else MIN_REFILLS \<le> max_refills \<and> budget \<le> period \<and> MIN_BUDGET \<le> budget \<and> period \<le> MAX_PERIOD)\<rbrace>
   refill_new p max_refills budget period
   \<lbrace>\<lambda>_. valid_refills scptr\<rbrace>"
  supply if_split [split del]
  apply (wpsimp simp: refill_new_def update_sched_context_def set_refills_def is_round_robin_def
                      maybe_add_empty_tail_def refill_add_tail_def get_refills_def
                  wp: set_object_wp get_object_wp get_sched_context_wp)
  apply (cases "period=0";
         clarsimp simp: refills_sum_def obj_at_def MIN_REFILLS_def vs_all_heap_simps
                        ordered_disjoint_def no_overflow_def
                        window_def sc_valid_refills_def rr_valid_refills_def split: if_splits)
  apply (insert MIN_BUDGET_pos)
  apply (clarsimp simp: word_le_nat_alt)
  apply (metis linorder_not_le unat_gt_0 word_less_nat_alt)
  done

lemma refill_update_valid_refills:
  "\<lbrace>valid_refills scptr
    and (\<lambda>s. unat (cur_time s) + 2 * unat new_period \<le> unat max_time)
    and (\<lambda>s. p = scptr \<longrightarrow> (\<exists>sc n. obj_at (\<lambda>ko. ko = SchedContext sc n
                                   \<and> unat (r_time (refill_hd sc)) + 2 * unat new_period
                                     \<le> unat max_time) p s))
    and K (if new_period = 0
           then new_max_refills = MIN_REFILLS \<and> MIN_BUDGET \<le> new_budget \<and> new_budget \<le> MAX_PERIOD
           else MIN_REFILLS \<le> new_max_refills \<and> MIN_BUDGET \<le> new_budget
                \<and> new_period \<le> MAX_PERIOD \<and> new_budget \<le> new_period)\<rbrace>
   refill_update p new_period new_budget new_max_refills
   \<lbrace>\<lambda>_. valid_refills scptr\<rbrace>"
  supply if_split [split del]
  apply (insert MIN_BUDGET_pos)
  unfolding refill_update_def maybe_add_empty_tail_def refill_add_tail_def update_refill_tl_def
            update_refill_hd_def
  apply (wpsimp wp: set_refills_wp update_sched_context_wp is_round_robin_wp get_refills_wp)
  apply (clarsimp simp: obj_at_def)

   \<comment> \<open>a useful fact\<close>
  apply (prop_tac "unat (cur_time s + new_period) = unat (cur_time s) + unat new_period")
   using unat_plus_simple unat_sum_bound_equiv apply fastforce

  apply (case_tac "new_period = 0"; clarsimp)
   apply (clarsimp simp: valid_refills_def rr_valid_refills_def no_overflow_def window_def
                         MIN_REFILLS_def vs_all_heap_simps
                  split: if_splits)
   apply (metis Groups.add_ac(2) linorder_not_less no_underflow_sub_plus unat_arith_simps(1)
                word_le_less_eq)

  apply (clarsimp simp: vs_all_heap_simps split: if_split)
  apply (intro conjI; intro impI allI)

    \<comment> \<open>scptr is refill_ready\<close>
   apply (clarsimp simp: valid_refills_def no_overflow_def window_def MIN_REFILLS_def)
   apply (intro conjI)
    apply (clarsimp simp: word_le_nat_alt)
    apply (metis linorder_not_le unat_gt_0 word_less_nat_alt)
   apply (clarsimp simp: valid_refills_def rr_valid_refills_def no_overflow_def window_def
                         MIN_REFILLS_def)
   apply (intro conjI impI)
        apply (fastforce elim: word_plus_mono_right2 intro: unat_sum_boundE unat_le_mono)
       apply (fastforce simp: word_le_nat_alt)
      apply (fastforce simp: word_le_nat_alt unat_sub)
     apply presburger
    apply (clarsimp simp: word_le_nat_alt word_less_nat_alt split: if_splits)
   apply (fastforce simp: word_le_nat_alt unat_sub)

  \<comment> \<open>scptr is not refill_ready\<close>

  apply (rename_tac sc n)
  apply (insert MIN_BUDGET_pos)
  apply (intro conjI; intro allI impI)
   apply (fastforce simp: valid_refills_def no_overflow_def window_def MIN_REFILLS_def
                          word_le_nat_alt word_less_nat_alt)
  apply (clarsimp simp: valid_refills_def rr_valid_refills_def no_overflow_def window_def
                        MIN_REFILLS_def)
  apply (intro conjI)
        apply (subst unat_add_lem')
         apply (clarsimp simp:  unat_minus_one_word)
        apply (meson add_le_cancel_left linorder_not_less order_trans word_le_less_eq
                     word_less_nat_alt)
       apply (fastforce simp: word_le_nat_alt)
      apply (subst unat_sub; fastforce?)
      apply (subst unat_add_lem')
       apply (clarsimp simp:  unat_minus_one_word)
      apply (prop_tac "unat new_budget - unat (r_amount (refill_hd sc)) \<le> unat new_period")
       using diff_le_self le_trans unat_le_mono apply blast
      apply fastforce
     using unat_plus_gt apply blast
    apply presburger
   apply (clarsimp simp: word_le_nat_alt word_less_nat_alt split: if_splits)
  apply (fastforce simp: word_le_nat_alt unat_sub)
  done

method schedule_used_simple
  = (wpsimp wp: set_refills_wp get_refills_wp
          simp: update_refill_hd_rewrite update_sched_context_set_refills_rewrite schedule_used_defs
     , clarsimp simp: round_robin_def vs_all_heap_simps obj_at_def sc_valid_refills_def)

lemma schedule_used_sum:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. refills_sum ((scrc_refills cfg) @ [new]) = t)
                      (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = t) (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = t) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc")
   apply (clarsimp simp: schedule_used_def obj_at_def vs_all_heap_simps)
  apply (rename_tac a list)
  apply (clarsimp simp: refills_sum_def obj_at_def vs_all_heap_simps)
  apply (prop_tac "butlast list @ [last list] = list", simp)
  apply (prop_tac "sum_list (map r_amount [last list]) = r_amount (last list)", simp)
  apply (metis sum_list_append map_append)
  done

lemma valid_refills_unat_sum_list_helper_helper:
  "ordered_disjoint (list :: refill list) \<Longrightarrow>
   no_overflow list \<Longrightarrow> list \<noteq> [] \<Longrightarrow>
   (unat (r_time (hd list)) + unat (sum_list (map r_amount (list))) \<le> unat max_time)"
  unfolding refills_sum_def
  apply (induction list; simp)
  apply (subgoal_tac "ordered_disjoint list \<and> no_overflow list", clarsimp)
   apply (subst unat_add_lem', overflow_hammer)
    apply (case_tac list; simp)
     apply (clarsimp simp: ordered_disjoint_def no_overflow_def)
    apply (erule order_trans[rotated])
    apply (clarsimp simp: ordered_disjoint_def no_overflow_def, fastforce)
   apply (case_tac list; simp)
    apply (clarsimp simp: ordered_disjoint_def no_overflow_def)
   apply (erule order_trans[rotated])
   apply (clarsimp simp: ordered_disjoint_def no_overflow_def, fastforce)
  apply (auto elim: ordered_disjoint_tail no_overflow_tail)
  done

lemma valid_refills_unat_sum_list_helper:
  "ordered_disjoint (list :: refill list) \<Longrightarrow>
   no_overflow list \<Longrightarrow> list \<noteq> [] \<Longrightarrow>
   unat (r_amount (hd list)) + unat (sum_list (map r_amount (tl list))) \<le> unat max_time"
  unfolding refills_sum_def
  apply (induction list; simp)
  apply (case_tac list; simp)
  apply (rule_tac y="unat (r_time a) + unat (r_amount a) + unat (sum_list (map r_amount list))" in order_trans)
   apply (clarsimp simp: ordered_disjoint_def no_overflow_def)
  apply (rule_tac y="unat (r_time (hd list)) + unat (sum_list (map r_amount list))" in order_trans)
   apply (clarsimp simp: ordered_disjoint_def no_overflow_def)
   apply (drule_tac x=0 in spec)+
   apply clarsimp
  apply (rule valid_refills_unat_sum_list_helper_helper; clarsimp elim!: ordered_disjoint_tail no_overflow_tail)
  done

lemma valid_refills_unat_sum_list:
  "ordered_disjoint (list :: refill list) \<Longrightarrow>
   no_overflow list \<Longrightarrow>
   unat (sum_list (map r_amount list)) = sum_list (map (unat \<circ> r_amount) list)"
  unfolding refills_sum_def
  apply (induction list; simp)
  apply (subst unat_add_lem', overflow_hammer)
   apply (frule valid_refills_unat_sum_list_helper, simp, simp, simp)
  apply (subgoal_tac "ordered_disjoint list \<and> no_overflow list", simp)
  apply (fastforce elim: ordered_disjoint_tail no_overflow_tail)
  done

lemma valid_refills_r_amount_bounded_sc_budget:
  "sc_valid_refills sc \<Longrightarrow> r_amount (refill_hd sc) \<le> sc_budget sc"
  apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def split: if_splits)
   apply (clarsimp simp: list_length_2 MIN_REFILLS_def unat_sum_bound_equiv)
  apply (subst (asm) eq_commute[where b = "sc_budget x" for x], simp)
  apply (case_tac "sc_refills sc"; simp)
  apply (overflow_hammer)
  apply (drule_tac valid_refills_unat_sum_list_helper; simp add: refills_sum_def)
  done

lemma valid_refills_r_amount_bounded_max_sc_period:
  "sc_valid_refills sc \<Longrightarrow> r_amount (refill_hd sc) \<le> MAX_PERIOD"
  apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def split: if_splits)
  apply (rule order_trans[rotated], assumption)
  apply (rule valid_refills_r_amount_bounded_sc_budget)
  apply (clarsimp simp: sc_valid_refills_def rr_valid_refills_def)
  apply (rule order_trans[rotated], assumption)
  apply (rule order_trans[rotated], assumption)
  apply (rule valid_refills_r_amount_bounded_sc_budget)
  apply (clarsimp simp: sc_valid_refills_def)
  done

lemma schedule_used_release_time_bounded:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> [] \<longrightarrow> r_time (scrc_refill_hd cfg) \<le> r_time new)
                      (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> [] \<longrightarrow> r_time new - r_amount (scrc_refill_hd cfg)
                                                           \<le> r_time new)
                        (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) \<le> r_time new) (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) \<le> r_time new) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_defs)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (case_tac "sc_refills sc"; fastforce)
  done

lemma schedule_used_refills_unat_sum:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. refills_unat_sum ((scrc_refills cfg) @ [new]) = unat (scrc_budget cfg))
                 (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  supply map_map[simp del]
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def)

  apply (rename_tac sc n)
  apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (case_tac "can_merge_refill (refill_tl sc) new")
   apply clarsimp
   apply (intro conjI impI)
    apply (simp add: unat_plus_simple)
   apply (simp add: refills_unat_sum_def)
   apply (subst unat_add_lem'')
   apply (prop_tac "unat (r_amount (refill_tl sc)) \<in> set (map unat (map r_amount (sc_refills sc)))")
     apply force
    apply (frule member_le_sum_list)
    apply (rule_tac y="unat (sc_budget sc)" in order_trans, linarith)
    apply force
   subgoal by (metis (no_types, lifting) ab_semigroup_add_class.add_ac(1) append_butlast_last_id
                                         map_append refills_unat_sum_def refills_unat_sum_length_one
                                         sum_list.append)
  apply (case_tac "sc_refills sc"; fastforce?)
  apply (clarsimp simp: refills_unat_sum_def split: if_splits)
   apply (rule word_unat.Rep_eqD)
   apply (subst unat_add_lem''; fastforce)
  apply (subst unat_add_lem''; fastforce?)
   apply (prop_tac "unat (r_amount (refill_tl sc)) \<in> set (map unat (map r_amount (sc_refills sc)))")
    apply force
   apply (frule member_le_sum_list)
   apply (rule_tac y="unat (sc_budget sc)" in order_trans, force)
   apply force
  by (metis Groups.add_ac(1) append_butlast_last_id refills_unat_sum_append refills_unat_sum_def
            refills_unat_sum_length_one)

(* FIXME RT: move *)
lemma add_less_mono_trans:
  "\<lbrakk>(a :: nat) + c < d; b \<le> c\<rbrakk> \<Longrightarrow> a + b < d"
  by fastforce

lemma unat_add_subtract_cancel:
  "\<lbrakk>unat (a :: 64 word) + unat b \<le> unat max_time; b \<le> c\<rbrakk>
   \<Longrightarrow> unat (a + b) + unat (c - b) = unat a + unat c"
  apply (subst unat_sub; assumption?)
  apply (subst unat_add_lem', clarsimp simp: unat_minus_one_word)
  apply (clarsimp simp: word_le_nat_alt)
  done

lemma refill_budget_check_refill_amount_helper:
  "\<lbrakk>refills_sum (sc_refills sc) = sc_budget sc; ordered_disjoint (sc_refills sc);
    no_overflow (sc_refills sc); sc_refills sc \<noteq> []; MIN_BUDGET \<le> sc_budget sc;
    sc_budget sc \<le> sc_period sc; refill \<in> set (sc_refills sc)\<rbrakk>
   \<Longrightarrow> unat (r_amount refill) \<le> unat (sc_period sc)"
  apply (frule (2) unat_sum_list_equals_budget)
   apply (clarsimp simp: word_le_nat_alt)
  apply (rule_tac j="unat (sc_budget sc)" in le_trans)
   apply (clarsimp simp: refills_sum_def word_le_nat_alt)
   apply (prop_tac "unat (r_amount refill) \<in> set (map unat (map r_amount (sc_refills sc)))", force)
   apply (fastforce dest: member_le_sum_list simp: refills_unat_sum_def)
  apply (clarsimp simp: word_le_nat_alt)
  done

lemma schedule_used_no_overflow:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> (pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []
                                \<longrightarrow> unat (r_time (last (scrc_refills cfg)))
                                     + unat (r_amount (last (scrc_refills cfg)))
                                     + unat (r_amount new)
                                    \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
                \<and> no_overflow [new]))\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  supply map_map[simp del]
  apply (cases "sc_ptr'\<noteq>sc_ptr")
   apply schedule_used_simple
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc")
   apply (clarsimp simp: schedule_used_def Let_def ordered_disjoint_def vs_all_heap_simps obj_at_def)
  apply (rename_tac a lista)
  apply (case_tac "can_merge_refill (last (sc_refills sc)) new")
   apply (clarsimp simp: schedule_used_def Let_def can_merge_refill_def vs_all_heap_simps obj_at_def)
   apply (intro conjI impI)
    apply (clarsimp simp: no_overflow_def)
    apply (subst unat_add_lem''; fastforce)
   apply (rule_tac left="a # butlast lista"
               and right="[\<lparr>r_time = r_time (last lista),
                            r_amount = r_amount (last lista) + r_amount new\<rparr>]"
                in no_overflow_append)
     apply (metis no_overflow_sublist butlast.simps(2) sublist_butlast)
    apply (clarsimp simp: no_overflow_def)
    apply (subst unat_add_lem''; fastforce)
   apply simp
  apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (intro conjI impI)
     apply (rule_tac left="[a]" and right="[new]" in no_overflow_append; fastforce?)
    apply (clarsimp simp: no_overflow_def can_merge_refill_def)
    apply (subst unat_add_lem'')
     apply (fastforce simp: unat_max_word word_le_nat_alt)
    apply (clarsimp simp: word_le_nat_alt not_le)
    apply (subst unat_sub)
     apply (prop_tac "unat (r_time a + r_amount a) = unat (r_time a) + unat (r_amount a)")
      apply (subst unat_add_lem'')
       apply (fastforce simp: unat_max_word word_le_nat_alt)
      apply simp
     apply (clarsimp simp: word_le_nat_alt not_le)
    apply linarith
   apply (rule_tac left="a # lista" and right="[new]" in no_overflow_append; fastforce?)
  apply (rule_tac left="a # butlast lista"
              and right=" [\<lparr>r_time = r_time new - r_amount (last lista),
                            r_amount = r_amount (last lista) + r_amount new\<rparr>]"
               in no_overflow_append
         ; fastforce?)
   apply (metis no_overflow_sublist butlast.simps(2) sublist_butlast)
  apply (clarsimp simp: no_overflow_def can_merge_refill_def)
  apply (subst unat_add_lem', clarsimp simp: unat_minus_one_word)
  apply (subst unat_sub)
   apply (prop_tac "unat (r_time (last lista) + r_amount (last lista))
                    = unat (r_time (last lista)) + unat (r_amount (last lista))")
    apply (subst unat_add_lem'')
     apply (fastforce simp: unat_max_word word_le_nat_alt)
    apply blast
   apply (clarsimp simp: not_le word_le_nat_alt)
  apply linarith
  done

lemma schedule_used_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow>  pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> [] \<longrightarrow> unat (r_time (last (scrc_refills cfg)))
                                                             \<le> unat (r_time new))
                           (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (cases "sc_ptr'\<noteq>sc_ptr")
   apply schedule_used_simple
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc")
   apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (rename_tac a lista)
  apply (case_tac "can_merge_refill (refill_tl sc) new")
   apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
   apply (rule_tac left="a # butlast lista"
              and right="[\<lparr>r_time = r_time (last lista),
                           r_amount = r_amount (last lista) + r_amount new\<rparr>]"
               in ordered_disjoint_append)
      apply (intro impI)
      apply (rule ordered_disjoint_sublist; assumption?)
      apply (metis sublist_butlast butlast.simps(2))
     apply (clarsimp simp: ordered_disjoint_def)
    apply (intro impI)
    apply clarsimp
    apply (intro conjI impI)
     apply (rule_tac j="unat (r_time (hd lista))" in le_trans)
      apply (fastforce simp: ordered_disjoint_def hd_conv_nth)
     apply (subst last_conv_nth; fastforce?)
     apply (metis Nat.add_0_right hd_conv_nth length_butlast list.size(3) nat_le_iff_add)
    apply (clarsimp simp: last_butlast_list)
    apply (subst last_conv_nth; fastforce?)
    apply (metis ordered_disjoint_def One_nat_def Suc_diff_Suc butlast_nonempty_length lessI
                 ordered_disjoint_tail)
   apply (fastforce simp: word_le_nat_alt)
  apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (intro conjI impI)
    apply (clarsimp simp: ordered_disjoint_def can_merge_refill_def)
    apply (metis no_overflow_def list.set_intros(1) nat_le_linear unat_arith_simps(1)
                 unat_plus_simple unat_sum_bound_equiv)
   apply (rule_tac left="a # lista" and right="[new]" in ordered_disjoint_append)
      apply simp
     apply (clarsimp simp: ordered_disjoint_def)
    apply (clarsimp simp: can_merge_refill_def)
    apply (metis no_overflow_def last_in_set nat_le_linear no_overflow_tail unat_arith_simps(1)
                 unat_plus_simple unat_sum_bound_equiv)
   apply simp
  apply (rule_tac left="a # butlast lista"
              and right="[\<lparr>r_time = r_time new - r_amount (last lista),
                           r_amount = r_amount (last lista) + r_amount new\<rparr>]"
               in ordered_disjoint_append
         ; fastforce?)
   apply (metis ordered_disjoint_sublist butlast.simps(2) sublist_butlast)
  apply (clarsimp simp: ordered_disjoint_def can_merge_refill_def)
  apply (prop_tac "unat (r_time (last lista) + r_amount (last lista))
                   = unat (r_time (last lista)) + unat (r_amount (last lista))")
   apply (subst unat_add_lem'; fastforce?)
   apply (metis no_overflow_def Groups.add_ac(2) last_in_set le_simps(3) linorder_not_less
                no_overflow_tail power_two_max_word_fold)
  apply (clarsimp simp: word_le_nat_alt)
  apply (intro conjI impI)
   apply (subst unat_sub, clarsimp simp: word_le_nat_alt)
   apply (prop_tac "unat (r_time a) + unat (r_amount a) \<le> unat (r_time (hd lista))")
    apply (metis One_nat_def butlast.simps(2) hd_conv_nth length_butlast lessI list.size
                 nth_Cons_0 semiring_norm(175))
   apply (rule_tac j="unat (r_time (hd lista))" in le_trans; blast?)
   apply (prop_tac "hd lista = last lista")
    apply (metis hd_conv_nth last_conv_nth length_butlast list.size(3))
   apply simp
  apply (subst unat_sub, clarsimp simp: word_le_nat_alt)
  apply (prop_tac "unat (r_time (last (butlast lista))) + unat (r_amount (last (butlast lista)))
                   \<le> unat (r_time (last lista))")
   apply (prop_tac "ordered_disjoint lista")
    apply (fastforce simp: ordered_disjoint_def nat_diff_add
                    intro: ordered_disjoint_tail)
   apply (metis ordered_disjoint_def One_nat_def Suc_diff_Suc butlast_nonempty_length
                last_butlast_list last_conv_nth lessI)
  apply simp
  done

lemma schedule_used_window:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. r_time new \<le> r_time (scrc_refill_hd cfg) + scrc_period cfg)
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) +  unat MAX_PERIOD \<le> unat max_time)
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (cases "sc_ptr'\<noteq>sc_ptr")
   apply schedule_used_simple
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc")
   apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (rename_tac a lista)
  apply (case_tac "can_merge_refill (refill_tl sc) new")
   apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def split: if_splits)
    apply (clarsimp simp: window_def)
   apply (clarsimp simp: window_def can_merge_refill_def)
  apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def window_def split: if_splits)
   apply safe
     apply (fastforce simp: window_def le_trans unat_plus_gt word_le_nat_alt)
   apply (fastforce simp: le_trans unat_plus_gt word_le_nat_alt)
  apply (clarsimp simp: can_merge_refill_def)
  apply (rule_tac y="unat (r_time new)" in order_trans)
   apply (subst unat_sub)
    apply (clarsimp simp: no_overflow_def not_le word_less_nat_alt)
    apply (subst (asm) unat_add_lem'')
     apply (clarsimp simp: last_conv_nth)
    apply (clarsimp simp: word_le_nat_alt)
   apply linarith
  apply (fastforce simp: le_trans unat_plus_gt word_le_nat_alt)
  done

lemma refill_full_sp:
  "\<lbrace>Q\<rbrace>
   refill_full sc_ptr
   \<lbrace>\<lambda>rv s. Q s \<and> (\<exists>sc n. kheap s sc_ptr = Some (SchedContext sc n)
                         \<and> (rv = (length (sc_refills sc) = sc_refill_max sc)))\<rbrace>"
  apply (wpsimp simp: is_round_robin_def)
  apply (clarsimp simp: obj_at_def)
  done

lemma refill_budget_check_refills_unat_sum_word_helper:
  "\<lbrakk>sc_refills sc \<noteq> []; refills_unat_sum (sc_refills sc) = unat (sc_budget sc);
    usage < r_amount (refill_hd sc)\<rbrakk>
   \<Longrightarrow> unat (r_amount (refill_hd sc) - usage)
       + sum_list (map unat (map r_amount (tl (sc_refills sc))))
       + unat usage
         = unat (sc_budget sc)"
  apply (subst unat_sub; fastforce?)
  apply (case_tac "sc_refills sc"; clarsimp)
  apply (clarsimp simp: word_less_nat_alt refills_unat_sum_def)
  done

abbreviation all_sp_valid_refills_but_MIN_BUDGET_in_head where
  "all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s \<equiv>
   pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
               (sc_refill_cfgs_of s) sc_ptr"

abbreviation all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow where
  "all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s \<equiv>
   pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> scrc_budget cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
   \<and> pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
               (sc_refill_cfgs_of s) sc_ptr"

lemma schedule_used_length_max:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. l = length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> Suc l) (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> Suc l) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: get_refills_wp update_sched_context_wp simp: schedule_used_defs)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma head_insufficient_loop_r_time_helper:
  "(n + 1) * unat MAX_PERIOD \<le> unat max_time \<Longrightarrow>
   \<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
             \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                         (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + (n + 1) * unat MAX_PERIOD
                                \<le> unat max_time)
                         (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + n * unat MAX_PERIOD
                             \<le> unat max_time)
                      (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + n * unat MAX_PERIOD
                          \<le> unat max_time)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (cases "sc_ptr'\<noteq>sc_ptr")
   apply head_insufficient_loop_simple
   apply (clarsimp simp: vs_all_heap_simps)
  apply (rule_tac Q="\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg))
                                            \<le> unat max_time - n * unat MAX_PERIOD)
                                    (sc_refill_cfgs_of s) sc_ptr"
               in hoare_strengthen_post[rotated])
   apply (clarsimp simp: vs_all_heap_simps)
  apply fastforce
  apply (wpsimp wp: head_insufficient_loop_hd_r_time)
  apply (fastforce simp: window_def vs_all_heap_simps word_le_nat_alt)
  done

lemma no_ofail_head_time_buffer:
  "no_ofail (\<lambda>s. \<exists>sc n. kheap s (cur_sc s) = Some (SchedContext sc n)) (head_time_buffer usage)"
  unfolding head_time_buffer_def no_ofail_def
  apply (clarsimp simp: obind_def ogets_def read_sched_context_def)
  done

lemma bound_head_time_buffer:
  "pred_map \<top> (scs_of s) (cur_sc s) \<Longrightarrow> bound (head_time_buffer usage s)"
  apply (clarsimp simp: head_time_buffer_def obind_def read_sched_context_def ogets_def
                        vs_all_heap_simps
                 split: kernel_object.splits)
  done

lemma head_time_buffer_true_imp_buffer:
  "pred_map \<top> (scs_of s) (cur_sc s)
   \<Longrightarrow> the (head_time_buffer usage s)
       = (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                   (sc_refill_cfgs_of s) (cur_sc s)
          \<and> pred_map (\<lambda>cfg. r_amount (scrc_refill_hd cfg) \<le> usage )
                     (sc_refill_cfgs_of s) (cur_sc s))"
  apply (fastforce simp: head_time_buffer_def obind_def read_sched_context_def ogets_def
                         vs_all_heap_simps MAX_RELEASE_TIME_def
                  split: kernel_object.splits)
  done

lemma head_time_buffer_true_imp_unat_buffer:
  "pred_map \<top> (scs_of s) (cur_sc s)
   \<Longrightarrow> the (head_time_buffer usage s)
       = (pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) < unat MAX_RELEASE_TIME)
                   (sc_refill_cfgs_of s) (cur_sc s)
          \<and> pred_map (\<lambda>cfg. r_amount (scrc_refill_hd cfg) \<le> usage )
                     (sc_refill_cfgs_of s) (cur_sc s))"
  apply (intro iffI)
   apply (fastforce dest!: head_time_buffer_true_imp_buffer[THEN iffD1, where usage1=usage]
                     simp: vs_all_heap_simps obj_at_kh_kheap_simps word_less_nat_alt)
  apply (fastforce simp: head_time_buffer_true_imp_buffer[THEN iffD2, where usage1=usage]
                    simp: vs_all_heap_simps obj_at_kh_kheap_simps word_less_nat_alt)
  done

lemma refill_single_sp:
  "\<lbrace>P\<rbrace>
   refill_single sc_ptr
   \<lbrace>\<lambda>rv s. P s
           \<and> (\<exists>sc n. kheap s sc_ptr = Some (SchedContext sc n)
                     \<and> ((length (sc_refills sc) = 1)) = rv)\<rbrace>"
  apply (clarsimp simp: refill_single_def refill_size_def)
  apply (wpsimp wp: get_refills_wp)
  apply (clarsimp simp: obj_at_def)
  done

lemma handle_overrun_loop_body_nonzero_refills[wp]:
  "handle_overrun_loop_body usage
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply handle_overrun_loop_simple
  done

lemma handle_overrun_loop_nonzero_refills:
  "handle_overrun_loop usage
   \<lbrace>\<lambda>s. pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: whileLoop_wp' handle_overrun_loop_body_nonzero_refills)
  done

lemma handle_overrun_loop_body_refills_unat_sum_equals_budget:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop_body usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  supply map_map[simp del]
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ refill_single_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. ?post s" in hoare_seq_ext; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp simp: update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                   wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def refills_unat_sum_def)
   apply (rename_tac sc n)
   apply (case_tac "sc_refills sc"; clarsimp)
  apply (wpsimp wp: schedule_used_refills_unat_sum)
  apply (wpsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite
                      update_refill_hd_rewrite
                  wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; simp)
  done

lemma handle_overrun_loop_refills_unat_sum_equals_budget:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow>  pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (rule_tac I="\<lambda>_. ?pre" in valid_whileLoop; fastforce?)
  apply (wpsimp wp: handle_overrun_loop_body_refills_unat_sum_equals_budget
                    handle_overrun_loop_body_nonzero_refills hoare_vcg_if_lift2 hoare_vcg_imp_lift')
  done

lemma handle_overrun_loop_body_window:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s
           \<longrightarrow>  pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 2 * unat MAX_PERIOD \<le> unat max_time)
                           (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop_body usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "\<lbrace>_\<rbrace> _ \<lbrace>(\<lambda>_ s. ?post s)\<rbrace>")
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ refill_single_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. ?post s" in hoare_seq_ext; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp simp: update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                   wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def window_def)
   apply (simp add: less_not_refl2 tail_nonempty_length)
   apply (wpsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite
                   wp: schedule_used_window set_refills_wp get_refills_wp)
  apply (case_tac "sc_ptr \<noteq> cur_sc s")
   apply (clarsimp simp: vs_all_heap_simps obj_at_def window_def)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def window_def)
  apply (rename_tac sc n)
  apply (prop_tac "unat (r_time (refill_hd sc)) \<le> unat (r_time (hd (tl (sc_refills sc))))")
   apply (clarsimp simp: hd_conv_nth hd_tl_nth)
   apply (subst hd_tl_nth)
    apply (metis Nitpick.size_list_simp tail_nonempty_length)
   apply (fastforce intro: ordered_disjoint_no_overflow_implies_sorted
                     simp: Suc_length_not_empty nat_less_le)
  apply (prop_tac " unat (r_time (hd (tl (sc_refills sc)))) \<le> unat (r_time (refill_tl sc))")
   apply (clarsimp simp: hd_conv_nth hd_tl_nth)
   apply (subst hd_tl_nth)
    apply (metis Nitpick.size_list_simp tail_nonempty_length)
   apply (subst last_conv_nth)
    apply blast
   apply (rule_tac refills="sc_refills sc" in ordered_disjoint_no_overflow_implies_sorted; simp?)
    apply (simp add: Suc_length_not_empty nat_less_le)
   apply (metis Nitpick.size_list_simp One_nat_def length_tl nat_less_le not_less_eq_eq zero_order)
  apply (prop_tac "last (tl (sc_refills sc)) = refill_tl sc")
   apply (metis Nitpick.size_list_simp last_tl)
  apply (intro conjI impI allI; fastforce?)
      apply (blast intro: ordered_disjoint_sublist)
     apply (blast intro: no_overflow_sublist)
    apply (metis Nitpick.size_list_simp)
   apply (rule word_add_le_mono1)
    apply (clarsimp simp: word_le_nat_alt)
   apply (subst power_two_max_word_fold)
   apply (clarsimp simp: unat_max_word word_le_nat_alt)
  apply (clarsimp simp: word_le_nat_alt)
  done

lemma head_time_buffer_implies_no_overflow:
  "\<lbrakk>pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 2 * unat MAX_PERIOD \<le> unat max_time)
             (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
             (sc_refill_cfgs_of s) sc_ptr;
    pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr\<rbrakk>
   \<Longrightarrow> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps)
  apply (rename_tac sc n)
  apply (clarsimp simp: no_overflow_def)
  apply (clarsimp simp: in_set_conv_nth)
  apply (rename_tac i)
  apply (case_tac "i = length (sc_refills sc) - 1")
   apply (clarsimp simp: window_def ordered_disjoint_def)
   apply (rule_tac y="unat (r_time (refill_hd sc)) + unat (sc_period sc) + unat MAX_PERIOD"
                in order_trans[rotated])
    apply (clarsimp simp: word_le_nat_alt)
   apply (clarsimp simp: last_conv_nth)
   apply (prop_tac "unat (r_amount (sc_refills sc ! (length (sc_refills sc) - Suc 0)))
                    \<le> unat (sc_budget sc)")
    apply (rule_tac refills="sc_refills sc" in refills_unat_sum_member_bound)
     apply linarith
    apply force
   apply (clarsimp simp: word_le_nat_alt)
  apply (clarsimp simp: ordered_disjoint_def)
  apply (meson nat_le_Suc_less_imp nat_less_le order_trans unat_bounded_above)
  done

lemma handle_overrun_loop_body_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s
           \<longrightarrow>  pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 2 * unat MAX_PERIOD \<le> unat max_time)
                           (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                           (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
    handle_overrun_loop_body usage
    \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  apply (rule_tac R1="\<lambda>s. sc_ptr = cur_sc s
                          \<longrightarrow> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg))
                                       (sc_refill_cfgs_of s) (cur_sc s)"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (clarsimp split: if_splits)
   apply (case_tac "sc_ptr \<noteq> cur_sc s")
    apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply (fastforce intro: head_time_buffer_implies_no_overflow)
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ refill_single_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. ?post s" in hoare_seq_ext; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp simp: update_refill_hd_rewrite
                   wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps ordered_disjoint_def obj_at_kh_kheap_simps)
  apply (wpsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite
                  wp: schedule_used_ordered_disjoint set_refills_wp get_refills_wp)
  apply (case_tac "sc_ptr \<noteq> cur_sc s")
   apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (intro conjI impI)
    apply (blast intro: ordered_disjoint_sublist)
   apply (blast intro: no_overflow_sublist)
  apply (clarsimp simp: word_le_nat_alt)
  apply (subst unat_add_lem'; fastforce simp: unat_minus_one_word window_def last_tl)
  done

lemma hoare_vcg_imp_lift_pre_add:
  "\<lbrakk> \<lbrace>P and Q\<rbrace> f \<lbrace>\<lambda>rv s. R rv s\<rbrace>; f \<lbrace>\<lambda>s. \<not> Q s\<rbrace> \<rbrakk> \<Longrightarrow> \<lbrace>P\<rbrace> f \<lbrace>\<lambda>rv s. Q s \<longrightarrow> R rv s\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (rule hoare_vcg_imp_lift')
    apply fastforce
   apply fastforce
  apply (clarsimp simp: pred_conj_def valid_def)
  done

lemma handle_overrun_loop_ordered_disjoint:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s
           \<longrightarrow> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  supply if_split[split del]
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_ s. ?pre s"]
         ; (fastforce split: if_splits)?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: handle_overrun_loop_body_ordered_disjoint)
    apply (fastforce dest: head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated]
                     simp: vs_all_heap_simps unat_MAX_RELEASE_TIME)
  apply (rule hoare_vcg_imp_lift_pre_add; (solves handle_overrun_loop_body_simple)?)
  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves handle_overrun_loop_body_simple)?)
   apply wpsimp
   apply (rule_tac f=cur_sc in hoare_lift_Pf2)
    apply (wpsimp wp: handle_overrun_loop_body_window)
    apply (fastforce intro!: head_time_buffer_implies_no_overflow
                      dest: head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated]
                      simp: vs_all_heap_simps unat_MAX_RELEASE_TIME)
   apply wpsimp
  apply clarsimp
  apply (rule_tac f=cur_sc in hoare_lift_Pf2)
   apply (wpsimp wp: handle_overrun_loop_body_refills_unat_sum_equals_budget)
  apply wpsimp
  done

lemma handle_overrun_loop_window:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg))
                 (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s
           \<longrightarrow> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg))
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  supply if_split[split del]
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (rule hoare_vcg_conj_lift_pre_fix)
   apply (wpsimp wp: handle_overrun_loop_body_window)
   apply (fastforce intro!: head_time_buffer_implies_no_overflow
                     dest!: head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated]
                      simp: vs_all_heap_simps unat_MAX_RELEASE_TIME)
  apply (rule hoare_vcg_imp_lift_pre_add; (solves handle_overrun_loop_body_simple)?)
  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves handle_overrun_loop_simple)?)
    apply (rule hoare_weaken_pre)
     apply (rule_tac f=cur_sc in hoare_lift_Pf2)
      apply (wpsimp wp: handle_overrun_loop_body_window)
     apply wpsimp
    apply (fastforce intro!: head_time_buffer_implies_no_overflow
                      dest!: head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated]
                       simp: vs_all_heap_simps  unat_MAX_RELEASE_TIME)
   apply (rule hoare_weaken_pre)
    apply (rule_tac f=cur_sc in hoare_lift_Pf2)
     apply (wpsimp wp: handle_overrun_loop_body_ordered_disjoint)
    apply wpsimp
   apply (fastforce dest: head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated]
                    simp: vs_all_heap_simps MAX_RELEASE_TIME_def MAX_PERIOD_mult unat_sub)
  apply wpsimp
  apply (rule_tac f=cur_sc in hoare_lift_Pf2)
   apply (wpsimp wp: handle_overrun_loop_body_refills_unat_sum_equals_budget)
  apply wpsimp
  done

lemma handle_overrun_loop_head_bound:
  "\<lbrace>\<lambda>s. cur_sc_offset_ready 0 s \<and> valid_refills (cur_sc s) s \<and> current_time_bounded s
        \<and> \<not> round_robin (cur_sc s) s
        \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg))) + 4 * unat MAX_PERIOD \<le> unat max_time)
                   (sc_refill_cfgs_of s) (cur_sc s)\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) (cur_sc s)"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (blast intro: head_time_buffer_implies_no_overflow)
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (rule_tac I="\<lambda>_ s. ?post s
                           \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD)
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg))
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg))
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                              = unat (scrc_budget cfg))
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. scrc_budget cfg \<le> scrc_period cfg)
                                       (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg)
                                       (sc_refill_cfgs_of s) (cur_sc s)"
               in valid_whileLoop
         ; fastforce?)
   apply (fastforce simp: cur_sc_offset_ready_def vs_all_heap_simps current_time_bounded_def
                          valid_refills_def round_robin_def)

  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves handle_overrun_loop_body_simple)?)
     defer
     apply (rule_tac f=cur_sc in hoare_lift_Pf2)
      apply (wpsimp wp: handle_overrun_loop_body_window)
      apply (fastforce intro!: head_time_buffer_implies_no_overflow
                         simp: vs_all_heap_simps)
     apply wpsimp
    apply (rule_tac f=cur_sc in hoare_lift_Pf2)
     apply (wpsimp wp: handle_overrun_loop_body_ordered_disjoint)
     apply (fastforce simp: vs_all_heap_simps)
    apply wpsimp
   apply (rule_tac f=cur_sc in hoare_lift_Pf2)
    apply (wpsimp wp: handle_overrun_loop_body_refills_unat_sum_equals_budget)
   apply wpsimp

  apply (rule_tac f=cur_sc in hoare_lift_Pf2; (solves wpsimp)?)
  apply (rename_tac sc_ptr)
  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (fastforce dest!: head_time_buffer_implies_no_overflow[rotated 1]
                     simp: vs_all_heap_simps)
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ refill_single_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg))) + 4 * unat MAX_PERIOD
                                            \<le> unat max_time)
                                    (sc_refill_cfgs_of s) sc_ptr
                           \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD)
                                       (sc_refill_cfgs_of s) sc_ptr
                           \<and> pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg))
                                       (sc_refill_cfgs_of s) sc_ptr"
               in hoare_seq_ext)
   apply wpsimp

  apply (rule hoare_if)
   apply (clarsimp simp: update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
   apply (wpsimp wp: get_refills_wp set_refills_wp)
   apply (frule head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated])
    apply (fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply (clarsimp simp: obj_at_def vs_all_heap_simps word_le_nat_alt)
   apply (rename_tac sc n)
   apply (subst unat_add_lem')
    apply (clarsimp simp: unat_minus_one_word)
   apply (insert MAX_PERIOD_mult[where n=4]; simp)
   apply (clarsimp simp: window_def)
   apply (subst unat_add_lem')
    apply (clarsimp simp: unat_minus_one_word word_le_nat_alt)
   apply (frule head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated])
    apply (fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply (fastforce simp: unat_minus_one_word unat_MAX_RELEASE_TIME less_not_refl2 tail_nonempty_length)

  apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_simple)?)
   defer
   apply (rule_tac f=cur_sc in hoare_lift_Pf2)
    apply (wpsimp wp: schedule_used_window get_refills_wp set_refills_wp update_sched_context_wp
                simp: refill_pop_head_def)
    apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps)
    apply (rename_tac sc n)
    apply (frule head_time_buffer_true_imp_unat_buffer[THEN iffD1, rotated])
     apply (fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps)
    apply (prop_tac "unat (r_time (refill_hd sc)) \<le> unat (r_time (hd (tl (sc_refills sc))))")
     apply (subst hd_tl_nth)
      apply (simp add: Suc_lessI)
     apply (subst hd_conv_nth)
      apply blast
     apply (erule (1) ordered_disjoint_no_overflow_implies_sorted)
       apply force
      apply (simp add: Suc_lessI)
     apply simp

    apply (prop_tac "hd (tl (sc_refills sc)) \<in> set (sc_refills sc)")
     apply (metis Nitpick.size_list_simp(2) hd_Cons_tl hd_in_set list.set_intros(2))
    apply (frule (2) ordered_disjoint_last)
    apply (intro conjI impI)
         apply (clarsimp simp: window_def)
         apply (prop_tac "last (tl (sc_refills sc)) = refill_tl sc")
          apply (metis Nitpick.size_list_simp(2) last_tl)
         apply clarsimp
        apply (blast intro: ordered_disjoint_sublist)
       apply (blast intro: no_overflow_sublist)
      apply (metis Nitpick.size_list_simp(2))
     apply (rule word_add_le_mono1)
      apply (clarsimp simp: word_le_nat_alt)
     apply (frule (1) ordered_disjoint_last)
      apply metis
     apply (subst power_two_max_word_fold)
     apply (clarsimp simp: unat_max_word word_le_nat_alt)
     apply (rule le_imp_less_Suc)
     apply (fastforce simp: window_def)
    apply (fastforce simp: window_def word_le_nat_alt)
   apply wpsimp

  apply (wpsimp wp: get_refills_wp set_refills_wp update_sched_context_wp
              simp: refill_pop_head_def schedule_used_defs)
  apply (prop_tac "pred_map \<top> (scs_of s) (cur_sc s)")
   apply (clarsimp simp: obj_at_def vs_all_heap_simps split: if_splits)
  apply (frule_tac usage=r in  head_time_buffer_true_imp_unat_buffer)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps split: if_splits)
  apply (frule (1) ordered_disjoint_last)
   apply metis
  apply (case_tac "tl (sc_refills scb)")
   apply (clarsimp simp: window_def MAX_RELEASE_TIME_def unat_sub)
   apply (metis Nitpick.size_list_simp(2))
  apply (prop_tac "unat (r_time a) + 4 * unat MAX_PERIOD \<le> unat max_time")
   apply (prop_tac "hd (tl (sc_refills scb)) \<in> set (tl (sc_refills scb))", fastforce)
   apply (drule_tac x="hd (tl (sc_refills scb))" in bspec)
    apply (simp add: list.set_sel(2))
   apply (frule (2) ordered_disjoint_last)
   apply (drule_tac x="hd (tl (sc_refills scb))" in bspec)
    apply (simp add: list.set_sel(2))
   apply (clarsimp simp: window_def MAX_RELEASE_TIME_def unat_sub word_le_nat_alt)
   apply (fastforce simp: MAX_PERIOD_mult[where n=5])
  apply clarsimp
  apply (subst unat_sub)
   apply (clarsimp simp: window_def MAX_RELEASE_TIME_def unat_sub word_le_nat_alt)
   apply (subst unat_add_lem''; fastforce?)
   apply (metis MIN_REFILLS_def Nitpick.size_list_simp(2) le_def list.size(4) list_exhaust_size_eq0
                minus_Suc_0_lt mult_is_add.mult_1_left numerals(2))
  apply (clarsimp simp: window_def MAX_RELEASE_TIME_def unat_sub word_le_nat_alt)
  by (metis MIN_REFILLS_def One_nat_def length_tl list.size(3) list.size(4) mult_is_add.mult_1_left
            not_less_eq_eq numerals(2) order_refl)

lemma schedule_used_refills_sum:
  "\<lbrace>\<lambda>s. if sc_ptr' = sc_ptr
        then pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) + r_amount new = scrc_budget cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_defs refill_add_tail_def update_refill_tl_def)
  apply (rename_tac sc n)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (intro conjI impI)
    apply (clarsimp simp: refills_sum_def)
   apply (prop_tac "sc_refills sc = butlast (sc_refills sc) @ [refill_tl sc]", simp)
   apply (case_tac "sc_refills sc"; fastforce?)
   apply (prop_tac "refills_sum (sc_refills sc)
                    = refills_sum (butlast (sc_refills sc)) + r_amount (refill_tl sc)")
    apply (subst add_ac)
    apply (clarsimp simp: refills_sum_def)
   apply (metis add.assoc)
  apply (prop_tac "sc_refills sc = butlast (sc_refills sc) @ [refill_tl sc]", simp)
  apply (case_tac "sc_refills sc"; fastforce?)
  apply (prop_tac "refills_sum (sc_refills sc)
                   = refills_sum (butlast (sc_refills sc)) + r_amount (refill_tl sc)")
   apply (clarsimp simp: refills_sum_def add_ac split: if_splits)
  apply (metis add.assoc)
  done

lemma handle_overrun_loop_body_refills_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop_body r
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ refill_single_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. ?post s" in hoare_seq_ext; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp simp: update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                   wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply (rename_tac sc n)
   apply (case_tac "sc_refills sc"; clarsimp)
  apply (wpsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite schedule_used_defs
                  wp: schedule_used_refills_sum set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps pred_map_simps)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp simp: refills_sum_def add_ac)
  done

lemma handle_overrun_loop_refills_sum:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  supply if_split[split del]
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_body_simple)?)
  apply (wpsimp wp: handle_overrun_loop_body_refills_sum)
  done

lemma head_insufficient_loop_round_robin[wp]:
  "head_insufficient_loop sc_ptr' \<lbrace>\<lambda>s. P (round_robin sc_ptr s)\<rbrace>"
  apply head_insufficient_loop_simple
  done

lemma handle_overrun_loop_round_robin[wp]:
  "handle_overrun_loop sc_ptr' \<lbrace>\<lambda>s. P (round_robin sc_ptr s)\<rbrace>"
  apply handle_overrun_loop_simple
  done

lemma handle_overrun_loop_body_length:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop_body usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  apply handle_overrun_loop_body_simple
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp)
  done

lemma handle_overrun_loop_length:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  supply if_split[split del]
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (rule_tac I="\<lambda>_. ?pre" in valid_whileLoop; (solves simp)?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_body_simple)?)
  apply (wpsimp wp: handle_overrun_loop_body_length)
  done

lemma handle_overrun_loop_body_scs_of_cur_sc[wp]:
  "handle_overrun_loop_body usage \<lbrace>\<lambda>s. pred_map \<top> (scs_of s) (cur_sc s)\<rbrace>"
  apply (clarsimp simp: handle_overrun_loop_body_def schedule_used_defs)
  apply (wpsimp simp: update_refill_hd_def refill_pop_head_def refill_single_def refill_size_def
                  wp: update_sched_context_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps)
  done

lemma refill_budget_check_ordered_disjoint_helper:
  "\<lbrakk>ordered_disjoint (sc_refills sc); sc_refills sc \<noteq> []; u < r_amount (refill_hd sc);
    no_overflow (sc_refills sc)\<rbrakk>
   \<Longrightarrow> ordered_disjoint (r_time_update (\<lambda>t. t + u) (r_amount_update (\<lambda>m. m - u) (refill_hd sc))
                         # tl (sc_refills sc))"
  apply (rule_tac left="[r_time_update (\<lambda>t. t + u) (r_amount_update (\<lambda>m. m - u) (refill_hd sc))]"
              and right="tl (sc_refills sc)"
               in ordered_disjoint_append)
     apply (clarsimp simp: ordered_disjoint_def)
    apply (blast intro: ordered_disjoint_sublist)
   apply clarsimp
   apply (subst unat_add_subtract_cancel)
     apply (fastforce dest: hd_in_set
                      simp: word_less_nat_alt no_overflow_def)
    apply fastforce
   apply (clarsimp simp: ordered_disjoint_def)
   apply (subst hd_tl_nth)
    apply (blast intro: tail_nonempty_length)
   apply (metis length_greater_0_conv length_tl numeral_nat(7) hd_conv_nth)
  apply (simp add: hd_conv_nth)
  done

lemma refill_budget_check_no_overflow_helper:
  "\<lbrakk>no_overflow (sc_refills sc); ordered_disjoint (sc_refills sc); sc_refills sc \<noteq> [];
    u < r_amount (refill_hd sc)\<rbrakk>
   \<Longrightarrow> no_overflow (r_time_update (\<lambda>t. t + u) (r_amount_update (\<lambda>m. m - u) (refill_hd sc))
                    # tl (sc_refills sc))"
  apply (rule_tac left="[r_time_update (\<lambda>t. t + u) (r_amount_update (\<lambda>m. m - u) (refill_hd sc))]"
              and right="tl (sc_refills sc)"
               in no_overflow_append)
    apply (clarsimp simp: no_overflow_def)
    apply (subst unat_add_subtract_cancel)
      apply (fastforce dest: hd_in_set
                       simp: word_less_nat_alt no_overflow_def)
     apply fastforce
    apply (clarsimp simp: ordered_disjoint_def)
   apply (blast intro: no_overflow_sublist)
  apply simp
  done

lemma refill_budget_check_refills_sum_helper:
  "\<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_sum (scrc_refills cfg) = scrc_budget cfg)
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (rule_tac f=cur_sc in hoare_lift_Pf2)
   apply (wpsimp wp: schedule_used_refills_sum set_refills_wp get_refills_wp
               simp: update_refill_hd_rewrite)
   apply (clarsimp simp: obj_at_def vs_all_heap_simps)
   apply (case_tac "sc_refills sc"; simp)
  apply wpsimp
  done

lemma refill_budget_check_ordered_disjoint_helper':
  "r_time (hd refills) < MAX_RELEASE_TIME \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
        \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 4 * unat MAX_PERIOD
                           \<le> unat max_time)
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                     (sc_refill_cfgs_of s) sc_ptr
            \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr)
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) sc_ptr s \<and> refills = sc_refills sc)
        \<and> (\<exists>n. ko_at (SchedContext sc n) sc_ptr s)\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. ordered_disjoint (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: schedule_used_ordered_disjoint set_refills_wp get_refills_wp
              simp: update_refill_hd_rewrite)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (intro conjI impI)
      apply (clarsimp simp: no_overflow_def)
      apply (subst unat_sub)
       apply force
      apply (subst unat_add_lem'')
       apply (clarsimp simp: word_less_nat_alt)
       apply (case_tac "sc_refills sc")
        apply blast
       apply fastforce
      apply (clarsimp simp: word_less_nat_alt)
     apply (subst unat_add_lem'')
      apply (fastforce dest: hd_in_set
                       simp: word_less_nat_alt no_overflow_def)
     apply (subst unat_add_lem'')
      apply (clarsimp simp: word_le_nat_alt)
     apply (frule_tac refill="refill_hd sc" in refill_budget_check_refill_amount_helper; simp)
     apply (clarsimp simp: word_less_nat_alt no_overflow_def)
    apply (fastforce intro: refill_budget_check_ordered_disjoint_helper)
   apply (fastforce intro: refill_budget_check_no_overflow_helper)
  apply (clarsimp simp: window_def last_tl)
  apply (subst unat_add_lem'', clarsimp simp: word_le_nat_alt)
  apply blast
  done

lemma refill_budget_check_no_overflow':
  "r_time (hd refills) < MAX_RELEASE_TIME \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 4 * unat MAX_PERIOD
                           \<le> unat max_time)
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                     (sc_refill_cfgs_of s) sc_ptr
            \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr)
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) sc_ptr s \<and> refills = sc_refills sc)
        \<and> (\<exists>n. ko_at (SchedContext sc n) sc_ptr s)\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: schedule_used_no_overflow set_refills_wp get_refills_wp
              simp: update_refill_hd_rewrite)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (intro conjI impI allI)
       apply (clarsimp simp: no_overflow_def)
       apply (subst unat_add_subtract_cancel)
         apply (fastforce dest: hd_in_set
                          simp: word_less_nat_alt no_overflow_def)
        apply fastforce
       apply (clarsimp simp: ordered_disjoint_def)
      apply (subst unat_add_subtract_cancel)
        apply (fastforce dest: hd_in_set
                         simp: word_less_nat_alt no_overflow_def)
       apply fastforce
      apply (clarsimp simp: ordered_disjoint_def)
      apply (frule_tac refill="refill_hd sc" in refill_budget_check_refill_amount_helper; simp?)
       apply (clarsimp simp: ordered_disjoint_def)
      apply (clarsimp simp: word_less_nat_alt word_le_nat_alt)
     apply (clarsimp simp: no_overflow_def)
     apply (subst unat_add_lem'')
      apply (clarsimp simp: word_less_nat_alt word_le_nat_alt)
     apply (frule_tac refill="refill_hd sc" in refill_budget_check_refill_amount_helper; simp?)
      apply (clarsimp simp: no_overflow_def)
     apply (clarsimp simp: word_less_nat_alt word_le_nat_alt)
    apply (fastforce intro: refill_budget_check_no_overflow_helper)
   apply (frule_tac refill="last (tl (sc_refills sc))" in refill_budget_check_refill_amount_helper
          ; simp?)
    apply (simp add: last_tl)
   apply (frule_tac refill="refill_hd sc" in refill_budget_check_refill_amount_helper; simp?)
   apply (clarsimp simp: window_def word_less_nat_alt word_le_nat_alt)
   apply (subst last_tl)
    apply blast
   apply linarith
  apply (clarsimp simp: no_overflow_def)
  apply (subst unat_add_lem'')
   apply (clarsimp simp: word_less_nat_alt word_le_nat_alt)
  apply (fastforce dest!: refill_budget_check_refill_amount_helper[where refill="refill_hd sc"]
                    simp: word_less_nat_alt word_le_nat_alt no_overflow_def)
  done

lemma refill_budget_check_window_helper:
  "r_time (hd refills) < MAX_RELEASE_TIME \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
        \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 4 * unat MAX_PERIOD
                           \<le> unat max_time)
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                     (sc_refill_cfgs_of s) sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr)
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) sc_ptr s \<and> refills = sc_refills sc)
        \<and> (\<exists>n. ko_at (SchedContext sc n) sc_ptr s)\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. window (scrc_refills cfg) (scrc_period cfg)) (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: schedule_used_window set_refills_wp get_refills_wp
              simp: update_refill_hd_rewrite)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (frule_tac refill="refill_hd sc" in refill_budget_check_refill_amount_helper; simp?)
  apply (intro conjI impI allI)
      apply (fastforce simp: unat_add_lem'' word_less_nat_alt word_le_nat_alt window_def last_tl)
     apply (fastforce intro: refill_budget_check_ordered_disjoint_helper)
    apply (fastforce intro: refill_budget_check_no_overflow_helper)
   apply (fastforce simp: unat_add_lem'' word_less_nat_alt word_le_nat_alt)
  apply (fastforce simp: unat_add_lem'' word_less_nat_alt word_le_nat_alt)
  done

lemma refill_budget_check_length_helper:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. 0 < length (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr
        \<and> pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                    (sc_refill_cfgs_of s) sc_ptr \<and> sc_ptr = csc_ptr\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. length (scrc_refills cfg) \<le> scrc_refill_max cfg)
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: set_refills_wp get_refills_wp
              simp: vs_all_heap_simps update_sched_context_set_refills_rewrite
                    update_refill_hd_rewrite schedule_used_defs)
  apply (clarsimp simp: obj_at_def)
  apply (metis Nitpick.size_list_simp(2) Suc_leI Suc_le_mono Suc_length_not_empty diff_Suc_Suc
               minus_Suc_0_lt)
  done

lemma refill_budget_check_refills_unat_sum_helper:
  "r_time (hd refills) < MAX_RELEASE_TIME \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                     (sc_refill_cfgs_of s) sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr)
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) sc_ptr s \<and> refills = sc_refills sc)\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: schedule_used_refills_unat_sum set_refills_wp get_refills_wp
              simp: update_refill_hd_rewrite)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (fastforce dest: refill_budget_check_refills_unat_sum_word_helper
                   simp: refills_unat_sum_def)
  done

lemma schedule_used_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. refills_unat_sum ((scrc_refills cfg) @ [new]) \<le> unat (scrc_budget cfg))
                        (sc_refill_cfgs_of s) sc_ptr
               \<and> 0 < unat (r_amount new))\<rbrace>
   schedule_used sc_ptr' new
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
            (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  supply map_map[simp del]
  apply schedule_used_simple
  apply (prop_tac " 0 < unat (r_amount (refill_tl sc) + r_amount new)")
   apply (subst unat_add_lem'')
    apply (clarsimp simp: refills_unat_sum_append)
    apply (prop_tac "unat (r_amount (refill_tl sc)) \<le> refills_unat_sum (sc_refills sc)")
     apply (fastforce intro: refills_unat_sum_member_bound last_in_set)
    apply (rule_tac y="unat (sc_budget sc)" in order_trans)
     apply linarith
    apply simp
   apply blast
  apply (meson in_set_butlastD)
  done

crunches refill_pop_head
   for non_zero_refills[wp]:
         "\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                       (sc_refill_cfgs_of s) sc_ptr"
   (wp: crunch_wps update_sched_context_wp)

lemma handle_overrun_loop_body_non_zero_refills:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
             \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                        (sc_refill_cfgs_of s) sc_ptr
        else pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>
   handle_overrun_loop_body usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "\<lbrace>_\<rbrace> _ \<lbrace>\<lambda>_. ?Q\<rbrace>")
  supply map_map[simp del] list.set_sel[simp add]
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext_skip, wpsimp simp: refill_single_def refill_size_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. ?Q s \<and> csc_ptr = cur_sc s" in hoare_seq_ext)
   apply wpsimp
  apply (rule hoare_if)
   apply (wpsimp wp: update_sched_context_wp
               simp: update_refill_hd_def)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
  apply (wpsimp wp: schedule_used_non_zero_refills update_sched_context_wp get_refills_wp
              simp: refill_pop_head_def)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refills_unat_sum_def)
  apply (intro conjI impI; force?)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refills_unat_sum_def)
  apply (rename_tac sc n)
  apply (case_tac "sc_refills sc"; clarsimp)
  done

lemma handle_overrun_loop_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr = cur_sc s
           \<longrightarrow>  pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
                \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                           (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill\<in>set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "valid ?pre _ _")
  supply if_split[split del]
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (rule_tac I="\<lambda>_. ?pre" in valid_whileLoop; (solves simp)?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_body_simple)?)
   apply (wpsimp wp: handle_overrun_loop_body_non_zero_refills)
   apply (clarsimp split: if_splits)
  apply (rule hoare_vcg_imp_lift_pre_add; (solves simp)?)
   apply (wpsimp wp: handle_overrun_loop_body_refills_unat_sum_equals_budget)
  apply (wpsimp wp: handle_overrun_loop_body_non_zero_refills)
  done

lemma non_overlapping_merge_refills_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill\<in>set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> the (head_insufficient sc_ptr s))\<rbrace>
   non_overlapping_merge_refills sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill\<in>set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (frule head_insufficient_length_at_least_two[rotated])
   apply (clarsimp simp: vs_all_heap_simps)
  apply (intro conjI impI)
   apply (subst unat_add_lem'')
    apply (case_tac "sc_refills sc"; clarsimp)
    apply (clarsimp simp: refills_unat_sum_cons)
    apply (rule_tac y="unat (sc_budget sc)" in order_trans)
     apply (prop_tac "unat (r_amount (hd list)) \<le> refills_unat_sum list")
      apply (prop_tac "hd list \<in> set list")
       apply (clarsimp simp: vs_all_heap_simps)
      apply (frule_tac refill="hd list" in refills_unat_sum_member_bound[rotated])
       apply (fastforce dest: refills_unat_sum_member_bound simp: vs_all_heap_simps)
      apply fast
     apply linarith
    apply fastforce
   apply simp
  apply (metis list.sel(2) list.set_sel(2))
  done

lemma head_insufficient_loop_non_zero_refills:
  "\<lbrace>\<lambda>s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                      (sc_refill_cfgs_of s) sc_ptr
        \<and> (sc_ptr' = sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. unat MIN_BUDGET \<le> refills_unat_sum (scrc_refills cfg))
                          (sc_refill_cfgs_of s) sc_ptr
               \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                          (sc_refill_cfgs_of s) sc_ptr)\<rbrace>
   head_insufficient_loop sc_ptr'
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                   (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  (is "\<lbrace>?P\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (rule_tac I="\<lambda>_. ?P" in valid_whileLoop; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves non_overlapping_merge_refills_simple)?)
   apply (wpsimp wp: non_overlapping_merge_refills_non_zero_refills)
  apply (rule hoare_vcg_imp_lift_pre_add)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves non_overlapping_merge_refills_simple)?)
    apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_lower_bound)
    apply (fastforce dest!: head_insufficient_length_at_least_two[rotated]
                      simp: vs_all_heap_simps)
   apply (wpsimp wp: non_overlapping_merge_refills_refills_unat_sum_equals_budget)
   apply (fastforce dest!: head_insufficient_length_at_least_two[rotated]
                       simp: vs_all_heap_simps)
  apply (wpsimp wp: non_overlapping_merge_refills_non_zero_refills)
  done

lemma refill_budget_check_non_zero_refills_helper:
  "\<lbrakk>0 < u \<and> r_time (hd refills) < MAX_RELEASE_TIME\<rbrakk> \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                    (sc_refill_cfgs_of s) sc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME) (sc_refill_cfgs_of s) sc_ptr
           \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr)
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) csc_ptr s \<and> refills = sc_refills sc)\<rbrace>
   do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
      schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
   od
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. \<forall>refill \<in> set (scrc_refills cfg). 0 < unat (r_amount refill))
                    (sc_refill_cfgs_of s) sc_ptr\<rbrace>"
  apply (wpsimp wp: schedule_used_non_zero_refills set_refills_wp get_refills_wp
              simp: update_refill_hd_rewrite)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (intro conjI impI allI)
     apply (subst unat_sub)
      apply fastforce
     apply (clarsimp simp: word_less_nat_alt)
    apply (simp add: list.set_sel(2))
   apply (fastforce dest: refill_budget_check_refills_unat_sum_word_helper
                    simp: refills_unat_sum_def)
  apply (clarsimp simp: word_less_nat_alt)
  done

lemma refill_budget_check_valid_refills[wp]:
  "\<lbrace>\<lambda>s. valid_refills sc_ptr s \<and> cur_sc_offset_ready 0 s \<and> current_time_bounded s
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_ s. valid_refills sc_ptr s\<rbrace>"
  supply map_map[simp del] round_robin_def[simp add]
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp], rename_tac robin)
  apply (rule hoare_seq_ext[OF _ assert_sp], clarsimp)

  apply (case_tac "sc_ptr \<noteq> csc_ptr")
   apply (rule_tac B="\<lambda>_ s. valid_refills sc_ptr s \<and> robin = round_robin csc_ptr s
                           \<and> cur_sc s = csc_ptr"
                in hoare_seq_ext[rotated])
    apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                 simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                       schedule_used_defs
           | fastforce simp: obj_at_def vs_all_heap_simps )+)[1]
   apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                      schedule_used_defs
          | fastforce simp: obj_at_def vs_all_heap_simps)+)[1]

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                   (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (clarsimp simp: vs_all_heap_simps)
   apply (frule valid_refills_refills_unat_sum_equals_budget
          ; (fastforce simp: )?)
   apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)

  apply (rule_tac B="\<lambda>usage' s. \<not> round_robin sc_ptr s
                                \<and> all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s
                                \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                                   = unat (scrc_budget cfg))
                                           (sc_refill_cfgs_of s) sc_ptr
                                \<and> pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg)))
                                                   + 4 * unat MAX_PERIOD
                                                  \<le> unat max_time)
                                           (sc_refill_cfgs_of s) (cur_sc s)
                                \<and> cur_sc s = sc_ptr
                                \<and> cur_sc s \<noteq> idle_sc_ptr
                                \<and> (pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) < MAX_RELEASE_TIME)
                                            (sc_refill_cfgs_of s) sc_ptr
                                   \<longrightarrow> pred_map (\<lambda>cfg. usage' < r_amount (hd (scrc_refills cfg)))
                                                (sc_refill_cfgs_of s) sc_ptr)"
               in hoare_seq_ext[rotated])

   apply (intro hoare_vcg_conj_lift_pre_fix
          ; (solves handle_overrun_loop_simple)?)
          apply (wpsimp wp: handle_overrun_loop_refills_sum)
          apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
         apply (wpsimp wp: handle_overrun_loop_ordered_disjoint)
         apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
        apply (wpsimp wp: handle_overrun_loop_window)
        apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
       apply (wpsimp wp: handle_overrun_loop_length)
       apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
      apply (wpsimp wp: handle_overrun_loop_non_zero_refills)
      apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
     apply (wpsimp wp: handle_overrun_loop_refills_unat_sum_equals_budget)
     apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
    apply (wpsimp wp: handle_overrun_loop_head_bound)
    apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
   apply (clarsimp simp: handle_overrun_loop_def)
   apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_ s. pred_map \<top> (scs_of s) (cur_sc s)
                                                    \<and> sc_ptr = cur_sc s"])
    apply (fastforce simp: head_time_buffer_true_imp_unat_buffer vs_all_heap_simps word_less_nat_alt
                           word_le_nat_alt)
   apply (clarsimp simp: vs_all_heap_simps)

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (fastforce intro!: head_time_buffer_implies_no_overflow
                      simp: vs_all_heap_simps)

  apply (rule hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_ s. \<not> round_robin sc_ptr s
                           \<and> all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
                           \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                              = unat (scrc_budget cfg))
                                       (sc_refill_cfgs_of s) sc_ptr
                           \<and> sc_ptr = cur_sc s \<and> cur_sc s \<noteq> idle_sc_ptr"
               in hoare_seq_ext[rotated])
   apply (rule hoare_when_cases, clarsimp simp: vs_all_heap_simps)
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (intro hoare_vcg_conj_lift_pre_fix
          ; (solves schedule_used_simple)?)

          apply (find_goal \<open>match conclusion in "\<lbrace>_\<rbrace> head_insufficient_loop _ \<lbrace>\<lambda>_. _\<rbrace>" \<Rightarrow> \<open>-\<close>\<close>)
          apply (rule_tac Q="\<lambda>_ s. \<not> round_robin sc_ptr s \<and> sp_valid_refills_unbundled sc_ptr s"
                       in hoare_strengthen_post[rotated])
           apply (fastforce simp: valid_refills_def vs_all_heap_simps)
          apply (intro hoare_vcg_conj_lift_pre_fix
                 ; (solves head_insufficient_loop_simple)?)
                apply (wpsimp wp: head_insufficient_loop_refills_sum)
                apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
               apply (wpsimp wp: head_insufficient_loop_ordered_disjoint)
               apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
              apply (wpsimp wp: head_insufficient_loop_no_overflow)
              apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
             apply (wpsimp wp: head_insufficient_loop_refills_window)
             apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
            apply (wpsimp wp: head_insufficient_loop_MIN_BUDGET_in_head)
            apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
           apply (wpsimp wp: head_insufficient_loop_length_bounded)
           apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
          apply (wpsimp wp: head_insufficient_loop_non_zero_refills)
          apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt)
         apply (wpsimp wp: refill_budget_check_refills_sum_helper)
        apply (wpsimp wp: refill_budget_check_ordered_disjoint_helper', fastforce+)
       apply (wpsimp wp: refill_budget_check_no_overflow', fastforce+)
      apply (wpsimp wp: refill_budget_check_window_helper, fastforce+)
     apply (wpsimp wp: refill_budget_check_length_helper)
    apply (wpsimp wp: refill_budget_check_non_zero_refills_helper)
   apply (wpsimp wp: refill_budget_check_refills_unat_sum_helper, fastforce+)
  apply (clarsimp simp: obj_at_def)
  apply (wpsimp wp: set_refills_wp get_refills_wp
              simp: vs_all_heap_simps update_sched_context_set_refills_rewrite update_refill_hd_rewrite)+
  done

lemma valid_refills_sc_update:
  "valid_refills p (s\<lparr>kheap := kheap s(p \<mapsto> SchedContext sc n)\<rparr>) = sc_valid_refills sc"
  by (clarsimp simp: obj_at_def vs_all_heap_simps)

lemma update_sc_consumed_valid_refills[wp]:
  "\<lbrace>valid_refills p and sc_at ptr\<rbrace>
   update_sched_context ptr (sc_consumed_update f)
   \<lbrace>\<lambda>_. valid_refills p\<rbrace>"
  by (wpsimp simp: obj_at_def vs_all_heap_simps window_def
                      update_sched_context_def obj_at_def
                  wp: set_object_wp get_object_wp )

lemma valid_refills_sc_consumed_update[iff]:
    "valid_refills p (s\<lparr>kheap := kheap s(p' \<mapsto> SchedContext (sc\<lparr>sc_consumed:=x\<rparr>) n)\<rparr>)
         = valid_refills p (s\<lparr>kheap := kheap s(p' \<mapsto> SchedContext sc n)\<rparr>)"
  by (clarsimp simp: obj_at_def vs_all_heap_simps window_def)

lemma valid_refills_domain_time_update[simp]:
  "valid_refills sc (domain_time_update f s) = valid_refills sc s"
  by (simp add: obj_at_def vs_all_heap_simps)

lemma refill_budget_check_round_robin_valid_refills[wp]:
   "\<lbrace>valid_refills p
     and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) (cur_sc s))
     and (\<lambda>s. is_refill_sufficient usage (cur_sc s) s)
     and K (unat usage + unat MAX_PERIOD \<le> unat max_time)\<rbrace>
    refill_budget_check_round_robin usage
    \<lbrace>\<lambda>_. valid_refills p\<rbrace>"
  supply if_split[split del]
  apply (clarsimp simp: refill_budget_check_round_robin_def
                        update_refill_tl_rewrite update_refill_hd_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (case_tac "p \<noteq> cur_sc s"; simp?)
   apply (clarsimp simp: vs_all_heap_simps)
  apply (clarsimp simp: vs_all_heap_simps valid_refills_def rr_valid_refills_def obj_at_def
                        list_length_2 MIN_REFILLS_def
                 split: if_splits)
  apply (intro conjI)
   apply (clarsimp simp: refill_sufficient_def refill_capacity_def split: if_splits)
  apply (subst unat_split_plus[symmetric]; clarsimp)
  apply (clarsimp simp: refill_sufficient_def refill_capacity_def split: if_splits)
   using MIN_BUDGET_nonzero apply blast
  by (simp add: unat_sum_bound_equiv word_le_imp_diff_le)

lemma consumed_time_bounded_helper:
  "consumed_time_bounded s
   \<Longrightarrow> current_time_bounded s
   \<Longrightarrow> unat (consumed_time s) + unat MAX_PERIOD \<le> unat max_time"
  unfolding consumed_time_bounded_def current_time_bounded_def
  by linarith

lemmas valid_refills_kheap_tcb_update'[iff] = valid_refills_kheap_tcb_update[simplified fun_upd_def obj_at_def is_tcb]

context DetSchedSchedule_AI begin

crunches copy_mrs, make_fault_msg, do_ipc_transfer
  for sc_refill_cfgs_of[wp]: "(\<lambda>s. P (sc_refill_cfgs_of s)) :: 'state_ext state \<Rightarrow> bool"
  (wp: mapM_wp')

crunches do_ipc_transfer
  for valid_sched_misc[wp]:
    "\<lambda>s :: 'state_ext state. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s)
                               (cur_thread s) (idle_thread s) (last_machine_time_of s)
                               (etcbs_of s) (tcb_scps_of s) (tcb_faults_of s)
                               (sc_refill_cfgs_of s)"
  (wp: crunch_wps)

end

context DetSchedSchedule_AI begin

crunches send_ipc
  for valid_sched_misc[wp]:
    "\<lambda>s :: 'state_ext state. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s)
                               (cur_thread s) (idle_thread s)
                               (etcbs_of s) (tcb_faults_of s)"
  (wp: crunch_wps)

end

lemma set_refills_check_no_change:
  "\<forall>x scsc. f (scsc\<lparr>scrc_refills := x\<rparr>) = f (scsc) \<Longrightarrow>
   set_refills scp x
   \<lbrace>\<lambda>s. Q (pred_map (\<lambda>cfg. P (f cfg)) (sc_refill_cfgs_of s) p)\<rbrace>"
  apply (wpsimp wp: set_refills_wp)
  by (clarsimp simp: vs_all_heap_simps obj_at_def)

context DetSchedSchedule_AI begin

lemma send_ipc_valid_refills[wp]:
  "\<lbrace>valid_refills scptr and current_time_bounded\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_. valid_refills scptr :: 'state_ext state \<Rightarrow> bool\<rbrace>"
  supply if_weak_cong[cong del]
  apply (clarsimp simp: send_ipc_def)
  apply wpsimp
               apply (rule_tac Q="\<lambda>_. valid_refills scptr and current_time_bounded"
                      in hoare_strengthen_post[rotated])
                apply (clarsimp cong: conj_cong simp: current_time_bounded_def valid_refills_def2)
               apply (wpsimp wp: hoare_drop_imp gts_wp hoare_vcg_all_lift)+
  done

lemma handle_timeout_valid_refills[wp]:
  "\<lbrace>valid_refills scptr and current_time_bounded\<rbrace>
   handle_timeout tptr ex
   \<lbrace>\<lambda>_. valid_refills scptr :: 'state_ext state \<Rightarrow> bool\<rbrace>"
  supply if_weak_cong[cong del]
  apply (clarsimp simp: handle_timeout_def)
  by (wpsimp simp: send_fault_ipc_def wp: hoare_drop_imps split_del: if_split)

lemma end_timeslice_valid_refills[wp]:
  "\<lbrace>valid_refills scptr and current_time_bounded\<rbrace>
   end_timeslice canTimeout
   \<lbrace>\<lambda>_. valid_refills scptr :: 'state_ext state \<Rightarrow> bool\<rbrace>"
  supply if_weak_cong[cong del]
  apply (clarsimp simp: end_timeslice_def)
  by (wpsimp simp: end_timeslice_def wp: hoare_drop_imps split_del: if_split)

lemma active_sc_tcb_at_budget_sufficient:
  "active_sc_tcb_at t s \<Longrightarrow> active_sc_valid_refills s \<Longrightarrow> budget_sufficient t (s :: 'z :: state_ext state)"
  by (fastforce simp: budget_sufficient_def2 active_sc_tcb_at_def2 is_sc_active_kh_simp
                dest: valid_refills_refill_sufficient active_sc_valid_refillsE)

lemma awaken_body_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> valid_release_q s \<and> active_sc_valid_refills s
        \<and> release_queue s \<noteq> [] \<and> budget_ready (hd (release_queue s)) s\<rbrace>
   awaken_body
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (clarsimp simp: awaken_body_def tcb_release_dequeue_def bind_assoc)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac rq)
  apply (rule_tac B="\<lambda>_ s. valid_ready_qs s \<and> st_tcb_at runnable (hd rq) s
                           \<and> released_sc_tcb_at (hd rq) s"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp simp: valid_release_q_def obj_at_kh_kheap_simps)
   apply (wpsimp simp: valid_release_q_def obj_at_kh_kheap_simps released_sc_tcb_at_def)
   apply (clarsimp intro!: active_sc_tcb_at_budget_sufficient)
  apply (wpsimp wp: possible_switch_to_valid_ready_qs
              simp: released_sc_tcb_at_def)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  done

lemma awaken_body_valid_sched_action:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> valid_release_q s \<and> active_sc_valid_refills s
        \<and> release_queue s \<noteq> [] \<and> budget_ready (hd (release_queue s)) s\<rbrace>
   awaken_body
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  apply (clarsimp simp: awaken_body_def tcb_release_dequeue_def bind_assoc)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac rq)
  apply (rule_tac B="\<lambda>_ s. valid_sched_action s \<and> st_tcb_at runnable (hd rq) s
                           \<and> released_sc_tcb_at (hd rq) s"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp simp: valid_release_q_def obj_at_kh_kheap_simps)
   apply wpsimp
   apply (fastforce intro: active_sc_tcb_at_budget_sufficient
                     simp: released_sc_tcb_at_def valid_release_q_def)
  apply (wpsimp simp: obj_at_kh_kheap_simps)
  done

lemma read_tcb_refill_ready_SomeD:
  "read_tcb_refill_ready tp s = Some b
    \<Longrightarrow> \<exists>scp. read_tcb_obj_ref tcb_sched_context tp s = Some (Some scp)
              \<and> read_sc_refill_ready scp s = Some b"
  by (clarsimp simp: read_tcb_refill_ready_def omonad_defs split: option.split_asm
              dest!: read_sched_context_SomeD)

lemma read_tcb_refill_ready_NoneD:
  "read_tcb_refill_ready tp s = None
    \<Longrightarrow> read_tcb_obj_ref tcb_sched_context tp s = None
        \<or> read_tcb_obj_ref tcb_sched_context tp s = Some None
        \<or> (\<exists>scp. read_tcb_obj_ref tcb_sched_context tp s = Some (Some scp)
                  \<and> read_sc_refill_ready scp s = None)"
  by (clarsimp simp: read_tcb_refill_ready_def obind_def omonad_defs
              split: option.split_asm)

lemma read_release_q_non_empty_and_ready_SomeD:
  "read_release_q_non_empty_and_ready s = Some b
   \<Longrightarrow> (b \<longrightarrow> release_queue s \<noteq> [] \<and> read_tcb_refill_ready (hd (release_queue s)) s = Some True)
       \<and> (\<not>b \<longrightarrow> release_queue s = [] \<or> read_tcb_refill_ready (hd (release_queue s)) s = Some False)"
  by (clarsimp simp: read_release_q_non_empty_and_ready_def asks_def split: if_split_asm)

lemma read_release_q_non_empty_and_ready_simp:
  "read_release_q_non_empty_and_ready s
   = (if release_queue s = []
         then Some False
         else read_tcb_refill_ready (hd (release_queue s)) s)"
  by (clarsimp simp: read_release_q_non_empty_and_ready_def asks_def obind_def
              split: if_split_asm)

lemma no_ofail_read_tcb_refill_ready:
  "no_ofail (\<lambda>s. bound_sc_tcb_at (\<lambda>p. \<exists>scp. p = Some scp
                                            \<and> (\<exists>sc n. kheap s scp = Some (SchedContext sc n))) tp s)
            (read_tcb_refill_ready tp)"
  unfolding read_tcb_refill_ready_def no_ofail_def
  apply (clarsimp simp: omonad_defs obind_def split: option.split)
  by (fastforce simp: pred_tcb_at_def obj_at_def is_sc_obj
               dest!: read_sc_refill_ready_NoneD read_sched_context_NoneD
                      read_sched_context_SomeD read_sc_refill_ready_SomeD
                      read_tcb_obj_ref_NoneD read_tcb_obj_ref_SomeD)

lemma no_ofail_read_release_q_non_empty_and_ready:
  "no_ofail (\<lambda>s. release_queue s = []
                 \<or> bound_sc_tcb_at (\<lambda>p. \<exists>scp. p = Some scp
                                              \<and> (\<exists>sc n. kheap s scp = Some (SchedContext sc n)))
                                    (hd (release_queue s)) s)
            read_release_q_non_empty_and_ready"
  unfolding read_release_q_non_empty_and_ready_def no_ofail_def
  by (clarsimp dest!: no_ofailD[OF no_ofail_read_tcb_refill_ready] simp: omonad_defs obind_def)

lemma valid_release_q_read_release_q_non_empty_and_ready_bound:
  "valid_release_q s \<Longrightarrow> bound (read_release_q_non_empty_and_ready s)"
  apply (clarsimp simp: valid_release_q_def)
  apply (prop_tac "release_queue s = [] \<or>
              bound_sc_tcb_at (\<lambda>p. \<exists>scp. p = Some scp
                     \<and> ((\<exists>sc n. kheap s scp = Some (SchedContext sc n)))) (hd (release_queue s)) s")
   apply (case_tac "release_queue s"; simp)
   apply (clarsimp simp: valid_release_q_def pred_tcb_at_def obj_at_def active_sc_tcb_at_def2
                         vs_all_heap_simps)
  apply (clarsimp dest!: no_ofailD[OF no_ofail_read_release_q_non_empty_and_ready])
  done

lemma read_release_q_non_empty_and_ready_True_simp:
  "\<lbrakk>valid_release_q s; read_release_q_non_empty_and_ready s = Some True\<rbrakk>
   \<Longrightarrow> release_queue s \<noteq> [] \<and> budget_ready (hd (release_queue s)) s"
  apply (clarsimp dest!: read_release_q_non_empty_and_ready_SomeD read_sched_context_SomeD
                         read_tcb_refill_ready_SomeD read_sc_refill_ready_SomeD
                         read_tcb_obj_ref_SomeD)
  by (clarsimp simp: vs_all_heap_simps map_project_simps map_join_simps opt_map_simps)


lemma valid_release_q_read_tcb_sched_context_bound:
  "\<lbrakk>valid_release_q s; t \<in> set (release_queue s)\<rbrakk>
   \<Longrightarrow> \<exists>scp. read_tcb_obj_ref tcb_sched_context t s = Some (Some scp)"
  apply (clarsimp simp: valid_release_q_def)
  apply (drule_tac x=t in bspec, simp)
  by (clarsimp simp: vs_all_heap_simps read_tcb_obj_ref_def thread_read_def oliftM_def
                     obind_def get_tcb_def)

lemma awaken_valid_sched:
  "\<lbrace>valid_sched and valid_idle\<rbrace>
   awaken
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: awaken_def)
  apply (rule_tac I="\<lambda>_ s. ?pre s" in valid_whileLoop; (solves simp)?)
  apply (clarsimp simp: valid_sched_def)
  apply (rule_tac Q="\<lambda>s. valid_ready_qs s \<and> valid_release_q s \<and> ready_or_release s
                         \<and> ct_not_in_q s \<and> valid_sched_action s \<and> ct_in_cur_domain s
                         \<and> valid_blocked s \<and> valid_idle_etcb s \<and> released_ipc_queues s
                         \<and> active_reply_scs s \<and> active_sc_valid_refills s \<and> valid_idle s
                         \<and> release_queue s \<noteq> [] \<and> budget_ready (hd (release_queue s)) s"
               in hoare_weaken_pre[rotated])
   apply clarsimp
   apply (prop_tac "read_release_q_non_empty_and_ready s = Some True")
    using valid_release_q_read_release_q_non_empty_and_ready_bound apply force
   apply (clarsimp dest!: read_tcb_refill_ready_SomeD read_sc_refill_ready_SomeD
                          read_tcb_obj_ref_SomeD read_sched_context_SomeD
                          read_release_q_non_empty_and_ready_SomeD
                    simp: vs_all_heap_simps)
  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves \<open>wpsimp simp: awaken_body_def tcb_release_dequeue_def\<close>)?)
     apply (wpsimp wp: awaken_body_valid_ready_qs)
    apply (wpsimp wp: possible_switch_to_not_it_ct_not_in_q simp: awaken_body_def tcb_release_dequeue_def)
    apply (clarsimp simp: valid_release_q_def valid_idle_def vs_all_heap_simps pred_tcb_at_def
                          obj_at_def)
    apply (fastforce dest: hd_in_set)
   apply (wpsimp wp: awaken_body_valid_sched_action)
  apply (wpsimp wp: possible_switch_to_valid_blocked tcb_release_remove_valid_blocked_except
              simp: awaken_body_def tcb_release_dequeue_def)
  done

end

crunches awaken
  for cur_tcb[wp]: cur_tcb
  and budget_ready[wp]: "\<lambda>s. P (budget_ready t s)"
  and budget_sufficient[wp]: "\<lambda>s. P (budget_sufficient t s)"
  and budget_ready_ct[wp]: "\<lambda>s. P (budget_ready (cur_thread s) s)"
  and budget_sufficient_ct[wp]: "\<lambda>s. P (budget_sufficient (cur_thread s) s)"
  and active_sc_tcb_at'[wp]: "\<lambda>s. P (active_sc_tcb_at t s)"
  and active_sc_tcb_at_ct[wp]: "\<lambda>s. P (active_sc_tcb_at (cur_thread s) s)"
  (wp: crunch_wps)

(* commit_time *)

lemma sc_consumed_update_sc_tcb_sc_at[wp]:
  "update_sched_context csc (\<lambda>sc. sc\<lparr>sc_consumed := f (sc_consumed sc)\<rparr>)
   \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  done

lemma sc_refills_update_sc_tcb_sc_at[wp]:
  "update_sched_context csc (sc_refills_update f)
   \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  done

crunches check_domain_time, refill_budget_check, refill_budget_check_round_robin,
         refill_unblock_check
  for sc_tcb_sc_at[wp]: "\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)"
  and ct_in_cur_domain[wp]: "ct_in_cur_domain"
  and in_cur_domain[wp]: "in_cur_domain t"
  and valid_idle_etcb[wp]: "valid_idle_etcb"
  and etcb_at[wp]: "etcb_at P t"
  (wp: crunch_wps set_refills_budget_ready
   simp: crunch_simps refill_budget_check_defs schedule_used_defs update_refill_tl_rewrite
   ignore: update_sched_context)

lemma commit_time_sc_tcb_sc_at[wp]:
  "commit_time \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  (is "_ \<lbrace>?pred\<rbrace>")
  apply (clarsimp simp: commit_time_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_. ?pred" in hoare_seq_ext)
   apply wpsimp
  apply clarsimp
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule_tac B="\<lambda>_. ?pred" in hoare_seq_ext)
   apply (wpsimp wp: update_sched_context_wp)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
  apply (wpsimp wp: update_sched_context_wp)
  done

crunches commit_time
  for ct_not_in_q[wp]: "ct_not_in_q"
  (wp: crunch_wps simp: crunch_simps)

lemma head_insufficient_loop_valid_sched_action_not:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   head_insufficient_loop csc_ptr
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply non_overlapping_merge_refills_simple
    apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                           obj_at_def scheduler_act_not_def is_activatable_def
                           switch_in_cur_domain_def in_cur_domain_def etcb_at'_def)
   apply non_overlapping_merge_refills_simple
   apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                          obj_at_def scheduler_act_not_def is_activatable_def
                          switch_in_cur_domain_def in_cur_domain_def etcb_at'_def
                   split: if_splits)
  apply non_overlapping_merge_refills_simple
  done

lemma refill_head_overlapping_loop_valid_sched_action_not:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   refill_head_overlapping_loop csc_ptr
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply merge_refills_simple
    apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                           obj_at_def scheduler_act_not_def is_activatable_def
                           switch_in_cur_domain_def in_cur_domain_def etcb_at'_def)
   apply merge_refills_simple
   apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                          obj_at_def scheduler_act_not_def is_activatable_def
                          switch_in_cur_domain_def in_cur_domain_def etcb_at'_def
                   split: if_splits)
  apply merge_refills_simple
  done

lemma handle_overrun_loop_valid_sched_action_not:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply handle_overrun_loop_body_simple
  apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                         obj_at_def scheduler_act_not_def is_activatable_def
                         switch_in_cur_domain_def in_cur_domain_def etcb_at'_def)
  done

crunches head_insufficient_loop, handle_overrun_loop
  for sc_scheduler_act_not_cur_sc[wp]: "\<lambda>s. sc_scheduler_act_not (cur_sc s) s"
  (wp: crunch_wps)

lemma refill_budget_check_valid_sched_action_act_not:
  "\<lbrace>valid_sched_action and (\<lambda>s. sc_scheduler_act_not (cur_sc s) s)\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: handle_overrun_loop_valid_sched_action_not)
   apply fastforce
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s
                           \<and> cur_sc s = csc_ptr"
               in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_wp get_refills_wp
               simp: update_refill_hd_rewrite update_sched_context_set_refills_rewrite
                     schedule_used_defs)
   subgoal by (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                               obj_at_def scheduler_act_not_def is_activatable_def
                               switch_in_cur_domain_def in_cur_domain_def etcb_at'_def
                        split: if_splits)
  apply (wpsimp wp: head_insufficient_loop_valid_sched_action_not)
  done

lemma refill_budget_check_round_robin_valid_sched_action_act_not:
  "\<lbrace>valid_sched_action and (\<lambda>s. sc_scheduler_act_not (cur_sc s) s)\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_hd_rewrite
            update_refill_tl_rewrite update_sched_context_set_refills_rewrite
  by (wpsimp wp: set_refills_valid_sched_action_act_not is_round_robin_wp)

lemma head_insufficient_loop_valid_ready_qs_not:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> sc_not_in_ready_q (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   head_insufficient_loop csc_ptr
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply non_overlapping_merge_refills_simple
    apply (fastforce simp: valid_ready_qs_def vs_all_heap_simps obj_at_def not_queued_def)
   apply non_overlapping_merge_refills_simple
   apply (fastforce simp: vs_all_heap_simps obj_at_def split: if_splits)
  apply non_overlapping_merge_refills_simple
  done

lemma refill_head_overlapping_loop_valid_ready_qs_not:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> sc_not_in_ready_q (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   refill_head_overlapping_loop csc_ptr
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply merge_refills_simple
    apply (fastforce simp: valid_ready_qs_def vs_all_heap_simps obj_at_def not_queued_def)
   apply merge_refills_simple
   apply (fastforce simp: vs_all_heap_simps obj_at_def split: if_splits)
  apply merge_refills_simple
  done

lemma handle_overrun_loop_valid_ready_qs_not:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> sc_not_in_ready_q (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply handle_overrun_loop_body_simple
  apply (fastforce simp: valid_ready_qs_def vs_all_heap_simps obj_at_def not_queued_def)
  done

crunches head_insufficient_loop, handle_overrun_loop
  for sc_not_in_ready_q_cur_sc[wp]: "\<lambda>s. sc_not_in_ready_q (cur_sc s) s"
  (wp: crunch_wps)

lemma refill_budget_check_valid_ready_qs_not_queued:
  "\<lbrace>valid_ready_qs and (\<lambda>s. sc_not_in_ready_q (cur_sc s) s)\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  supply map_map[simp del]
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: handle_overrun_loop_valid_ready_qs_not)
   apply fastforce
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_ready_qs s \<and> sc_not_in_ready_q (cur_sc s) s
                           \<and> cur_sc s = csc_ptr"
               in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_wp get_refills_wp
               simp: update_refill_hd_rewrite update_sched_context_set_refills_rewrite
                     schedule_used_defs)
   apply (clarsimp simp: obj_at_def vs_all_heap_simps not_queued_def valid_ready_qs_def
                  split: if_splits, fastforce)
  apply (wpsimp wp: head_insufficient_loop_valid_ready_qs_not)
  done

lemma is_refill_ready_alt:
  "is_refill_ready sc_ptr s
   = pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) \<le> (cur_time s) + kernelWCET_ticks)
              (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: refill_ready_def vs_all_heap_simps)
  done

method handle_overrun_loop_fail_simple
  = (clarsimp simp: handle_overrun_loop_def
     , rule valid_whileLoop_cond_fail
     , (fastforce simp: head_time_buffer_def obind_def ogets_def read_sched_context_def
                        vs_all_heap_simps refill_sufficient_def refill_capacity_def
                        MIN_BUDGET_nonzero sc_valid_refills_def vs_all_heap_simps
                 split: option.splits kernel_object.splits if_splits)+)

lemma refill_budget_check_refill_ready_offset_ready_and_sufficient:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then valid_refills (cur_sc s) s \<and> current_time_bounded s \<and> cur_sc s \<noteq> idle_sc_ptr
             \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s
        else is_refill_ready sc_ptr s\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_ s. is_refill_ready sc_ptr s\<rbrace>"
  supply map_map[simp del] round_robin_def[simp add]
  apply (subst is_refill_ready_alt)+
  apply (clarsimp simp: refill_budget_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp])
  apply (rule hoare_seq_ext[OF _ assert_sp])

   apply (case_tac "sc_ptr \<noteq> csc_ptr")
   apply (rule_tac B="\<lambda>_ s. pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg)
                                            \<le> cur_time s + kernelWCET_ticks)
                                     (sc_refill_cfgs_of s) sc_ptr
                            \<and> robin = round_robin csc_ptr s
                            \<and> cur_sc s = csc_ptr"
                in hoare_seq_ext[rotated])
    apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                 simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                       schedule_used_defs
           | fastforce simp: obj_at_def vs_all_heap_simps )+)[1]
   apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                      schedule_used_defs
          | fastforce simp: obj_at_def vs_all_heap_simps)+)[1]

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                   (sc_refill_cfgs_of s) (cur_sc s)"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (clarsimp simp: vs_all_heap_simps)
   apply (frule valid_refills_refills_unat_sum_equals_budget
          ; (fastforce simp: )?)
   apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)

  apply (rule_tac B="\<lambda>rv s. cur_sc_offset_ready usage s
                            \<and> cur_sc_offset_sufficient usage s
                            \<and> current_time_bounded s
                            \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (scrc_refill_hd cfg))
                                       (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD)
                                       (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> pred_map (\<lambda>cfg. MIN_REFILLS \<le> scrc_refill_max cfg)
                                       (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg))
                                       (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                              = unat (scrc_budget cfg))
                                       (sc_refill_cfgs_of s) (cur_sc s)
                            \<and> csc_ptr = cur_sc s \<and> cur_sc s \<noteq> idle_sc_ptr
                            \<and> (pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) < MAX_RELEASE_TIME)
                                         (sc_refill_cfgs_of s) (cur_sc s)
                               \<longrightarrow> pred_map (\<lambda>cfg. rv < r_amount (hd (scrc_refills cfg)))
                                            (sc_refill_cfgs_of s) (cur_sc s))
                            \<and> rv = usage"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_fail_simple)?)
   apply (clarsimp simp: handle_overrun_loop_def)
   apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_ s. pred_map \<top> (scs_of s) (cur_sc s)"])
    apply (fastforce simp: head_time_buffer_true_imp_unat_buffer vs_all_heap_simps word_less_nat_alt
                           word_le_nat_alt)
   apply (clarsimp simp: vs_all_heap_simps)

  apply (rule hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_ s. pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg)
                                           \<le> cur_time s + kernelWCET_ticks)
                                    (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (scrc_refill_hd cfg))
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. scrc_period cfg \<le> MAX_PERIOD)
                                      (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> csc_ptr = cur_sc s"
               in hoare_seq_ext)
   apply (wpsimp wp: head_insufficient_loop_hd_r_time_same)

  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp wp: update_sched_context_wp set_refills_wp get_refills_wp
                simp: schedule_used_defs)
    apply (clarsimp simp: vs_all_heap_simps word_le_nat_alt refill_ready_no_overflow_def
                          current_time_bounded_def obj_at_def)
    apply (prop_tac "unat (cur_time s + kernelWCET_ticks) = unat (cur_time s) + unat kernelWCET_ticks")
     apply (subst unat_add_lem''; fastforce?)
    apply simp
    apply (subst unat_add_lem''; fastforce?)
    apply (intro conjI impI)
       apply (subst unat_add_lem''; fastforce?)
      apply (subst unat_add_lem''; fastforce?)
     apply (rename_tac sc n)
     apply (case_tac "sc_refills sc"; clarsimp)
     apply (simp add: MIN_REFILLS_def)
    apply (subst unat_add_lem''; fastforce?)
   apply (clarsimp simp: refills_unat_sum_def unat_sub word_less_nat_alt word_le_nat_alt)
   apply (wpsimp wp: update_sched_context_wp set_refills_wp get_refills_wp
                simp: schedule_used_defs)
   apply (clarsimp simp: vs_all_heap_simps current_time_bounded_def obj_at_def)
   apply (intro conjI impI)
    apply (prop_tac "unat (cur_time s + kernelWCET_ticks) = unat (cur_time s) + unat kernelWCET_ticks")
     apply (subst unat_add_lem''; fastforce?)
    apply (rule word_le_nat_alt[THEN iffD1])
    apply (clarsimp simp: refill_sufficient_def refill_capacity_def split: if_splits)
   apply (clarsimp simp:  word_less_nat_alt word_le_nat_alt refill_sufficient_def refill_capacity_def)
  apply (wpsimp wp: update_sched_context_wp set_refills_wp get_refills_wp
              simp: schedule_used_defs)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma is_refill_sufficient_0_alt:
  "is_refill_sufficient 0 sc_ptr s
   = pred_map (\<lambda>cfg. MIN_BUDGET \<le> r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) sc_ptr"
  apply (clarsimp simp: vs_all_heap_simps refill_sufficient_def refill_capacity_def)
  done

lemma refill_budget_check_is_refill_sufficient:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then valid_refills (cur_sc s) s \<and> current_time_bounded s \<and> cur_sc s \<noteq> idle_sc_ptr
             \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s
         else is_refill_sufficient 0 sc_ptr s\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_ s. is_refill_sufficient 0 sc_ptr s\<rbrace>"
  (is "valid _ _ ?post")
  supply map_map[simp del] round_robin_def[simp add]
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp])
  apply (rule hoare_seq_ext[OF _ assert_sp])

  apply (case_tac "sc_ptr \<noteq> csc_ptr")
   apply (rule_tac B="\<lambda>_ s. is_refill_sufficient 0 sc_ptr s \<and> robin = round_robin csc_ptr s
                            \<and> cur_sc s = csc_ptr"
                in hoare_seq_ext[rotated])
    apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                 simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                       schedule_used_defs
           | fastforce simp: obj_at_def vs_all_heap_simps )+)[1]
   apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                      schedule_used_defs
          | fastforce simp: obj_at_def vs_all_heap_simps)+)[1]

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                   (sc_refill_cfgs_of s) (cur_sc s)"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (clarsimp simp: vs_all_heap_simps)
   apply (frule valid_refills_refills_unat_sum_equals_budget
          ; fastforce?)
   apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)

  apply (rule_tac B="\<lambda>usage' s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                    (sc_refill_cfgs_of s) (cur_sc s)
                                \<and> valid_refills (cur_sc s) s
                                \<and> csc_ptr = cur_sc s \<and> cur_sc s \<noteq> idle_sc_ptr
                                \<and> \<not> round_robin (cur_sc s) s
                                \<and> (pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) < MAX_RELEASE_TIME)
                                             (sc_refill_cfgs_of s) (cur_sc s)
                                   \<longrightarrow> pred_map (\<lambda>cfg. usage' < r_amount (hd (scrc_refills cfg)))
                                                (sc_refill_cfgs_of s) (cur_sc s))"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves handle_overrun_loop_fail_simple)?)
   apply (clarsimp simp: handle_overrun_loop_def)
   apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_ s. pred_map \<top> (scs_of s) (cur_sc s)"])
    apply (fastforce simp: head_time_buffer_true_imp_unat_buffer vs_all_heap_simps word_less_nat_alt
                           word_le_nat_alt)
   apply (clarsimp simp: vs_all_heap_simps)

  apply (rule hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_ s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                    (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. MIN_BUDGET \<le> scrc_budget cfg)
                                       (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) (cur_sc s)
                           \<and> csc_ptr = cur_sc s"
               in hoare_seq_ext)
   apply (subst is_refill_sufficient_0_alt)
   apply (wpsimp wp: head_insufficient_loop_MIN_BUDGET_in_head)
   apply (fastforce simp: vs_all_heap_simps word_le_nat_alt)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves head_insufficient_loop_simple)?)
   apply (rule_tac f=cur_sc in hoare_lift_Pf2)
    apply (wpsimp wp: schedule_used_refills_unat_sum set_refills_wp get_refills_wp
                simp: update_refill_hd_rewrite)
    apply (fastforce dest!: refill_budget_check_refills_unat_sum_word_helper
                      simp: refills_unat_sum_def vs_all_heap_simps obj_at_def sc_valid_refills_def)
   apply wpsimp
  apply wpsimp
  done

crunches refill_budget_check
  for etcb_eq[wp]: "etcb_eq p d t"
  (wp: crunch_wps simp: crunch_simps)

lemma refill_budget_check_round_robin_refill_ready_offset_ready_and_sufficient:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then current_time_bounded s \<and> cur_sc s \<noteq> idle_sc_ptr
             \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s
         else is_refill_ready sc_ptr s\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_ s. is_refill_ready sc_ptr s\<rbrace>"
  unfolding refill_budget_check_round_robin_def get_sc_refill_ready_def is_round_robin_def
            update_sched_context_set_refills_rewrite update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: vs_all_heap_simps refill_ready_no_overflow_def refill_ready_def obj_at_def)
  using cur_time_no_overflow word_le_nat_alt unat_plus_simple apply force
  done

lemma refill_budget_check_round_robin_is_refill_sufficient:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then valid_refills (cur_sc s) s \<and> current_time_bounded s \<and> cur_sc s \<noteq> idle_sc_ptr
             \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s
         else is_refill_sufficient 0 sc_ptr s\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_ s. is_refill_sufficient 0 sc_ptr s\<rbrace>"
  unfolding refill_budget_check_round_robin_def get_sc_refill_ready_def is_round_robin_def
            update_refill_tl_def update_refill_hd_def update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  by (auto simp: pred_map_def obj_at_def vs_all_heap_simps refill_sufficient_def refill_capacity_def
                 refill_ready_no_overflow_def valid_refills_def rr_valid_refills_def
          split: if_splits)

lemma refill_budget_check_round_robin_valid_ready_qs_not_queued:
  "\<lbrace>valid_ready_qs and (\<lambda>s. sc_not_in_ready_q (cur_sc s) s)\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
            update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_valid_ready_qs get_refills_wp is_round_robin_wp hoare_vcg_all_lift
                    hoare_vcg_imp_lift' set_refills_wp)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps split: if_splits)
  done

lemma update_refill_hd_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s
        \<and> (\<forall>t. pred_map_eq (Some sc_ptr) (tcb_scps_of s) t
               \<longrightarrow> in_release_q t s
               \<longrightarrow> (scs_of s ||> sc_refills |> hd_opt ||> f ||> r_time) sc_ptr = tcb_ready_times_of s t)\<rbrace>
   update_refill_hd sc_ptr f
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding update_refill_hd_rewrite
  apply (wpsimp wp: set_refills_valid_release_q get_refills_wp)
  by (fastforce simp: tcb_ready_times_defs vs_all_heap_simps obj_at_def opt_map_red
                      sc_heap_of_state_def  map_project_def map_join_def sc_refill_cfgs_of_scs_def)

lemma non_overlapping_merge_refills_cur_sc_not_in_release_q:
  "non_overlapping_merge_refills csc_ptr \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply non_overlapping_merge_refills_simple
  apply (fastforce split: if_splits)
  done

lemma head_insufficient_loop_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> sc_not_in_release_q (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   head_insufficient_loop csc_ptr
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: set_refills_valid_release_q get_refills_wp hoare_vcg_all_lift
                      hoare_vcg_imp_lift' set_refills_wp
                simp: non_overlapping_merge_refills_def refill_pop_head_def
                      update_refill_hd_rewrite update_sched_context_set_refills_rewrite)
    apply (fastforce simp: vs_all_heap_simps obj_at_def split: if_splits)
   apply non_overlapping_merge_refills_simple
   apply (fastforce split: if_splits)
  apply non_overlapping_merge_refills_simple
  done

lemma handle_overrun_loop_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> sc_not_in_release_q (cur_sc s) s\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (wpsimp wp: set_refills_valid_release_q get_refills_wp hoare_vcg_all_lift
                    hoare_vcg_imp_lift'
              simp: refill_budget_check_defs update_sched_context_set_refills_rewrite schedule_used_defs
         | wpsimp wp: set_refills_wp)+
  done

crunches head_insufficient_loop, handle_overrun_loop
  for sc_not_in_release_q_cur_sc[wp]: "\<lambda>s. sc_not_in_release_q (cur_sc s) s"
  (wp: crunch_wps)

lemma sorted_release_q_sc_not_in_sc_update:
  "\<lbrakk>sc_not_in_release_q scp s;  \<forall>t\<in> set (release_queue s). tcb_at t s;
    kheap s scp = Some (SchedContext sc' n)\<rbrakk> \<Longrightarrow>
   sorted_release_q (s\<lparr> kheap := (kheap s(scp \<mapsto> SchedContext sc n)) \<rparr>) = sorted_release_q s"
  apply (clarsimp simp: sorted_release_q_def not_in_release_q_def obj_at_def is_tcb)
  apply (rule sorted_wrt_img_ord_eq_lift; simp?)
  apply (rename_tac tp; drule_tac x=tp in bspec, simp)
  apply (case_tac "tcb_ready_times_of s tp"; clarsimp)
  by (fastforce simp: vs_all_heap_simps tcb_ready_times_defs map_project_def map_join_def opt_map_def
               split: option.splits)+

lemma valid_release_q_sc_not_in_sc_update:
  "\<lbrakk>valid_release_q (s::('a::state_ext state)); sc_not_in_release_q scp s;
    kheap s scp = Some (SchedContext sc' n)\<rbrakk> \<Longrightarrow>
   valid_release_q (s\<lparr> kheap := (kheap s(scp \<mapsto> SchedContext sc n)) \<rparr>) "
  apply (clarsimp simp: valid_release_q_def sorted_release_q_sc_not_in_sc_update)
  apply (rule conjI)
   apply (fastforce simp: not_in_release_q_def vs_all_heap_simps)
  by (subst sorted_release_q_sc_not_in_sc_update[simplified];
      fastforce simp: obj_at_def is_tcb vs_all_heap_simps)

lemma schedule_used_valid_release_q:
  "\<lbrace>valid_release_q and (\<lambda>s. sc_not_in_release_q (cur_sc s) s) and (\<lambda>s. sc_ptr = cur_sc s)\<rbrace>
   schedule_used sc_ptr usage
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (clarsimp simp: schedule_used_defs)
  apply (wpsimp wp: set_refills_valid_release_q update_sched_context_wp get_refills_wp
         | wp (once) hoare_drop_imp)+
  apply (fastforce dest: valid_release_q_sc_not_in_sc_update
                   simp: vs_all_heap_simps obj_at_def)
  done

lemma refill_budget_check_valid_release_q:
  "\<lbrace>valid_release_q and (\<lambda>s. sc_not_in_release_q (cur_sc s) s)\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def update_sched_context_set_refills_rewrite
                        update_refill_hd_rewrite)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip, wpsimp wp: handle_overrun_loop_valid_release_q)
  apply (rule hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_ s. valid_release_q s \<and> sc_not_in_release_q (cur_sc s) s
                           \<and> cur_sc s = csc_ptr"
               in hoare_seq_ext[rotated])
   apply (wpsimp wp: schedule_used_valid_release_q get_refills_wp set_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def)
   apply (drule_tac scp="cur_sc s" in valid_release_q_sc_not_in_sc_update; simp?)
   apply (clarsimp simp: vs_all_heap_simps obj_at_def is_sc_obj valid_release_q_sc_not_in_sc_update)
  apply (wpsimp wp: head_insufficient_loop_valid_release_q)
  done


lemma refill_budget_check_round_robin_valid_release_q:
  "\<lbrace>valid_release_q and (\<lambda>s. sc_not_in_release_q (cur_sc s) s)\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
            update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_valid_release_q is_round_robin_wp get_refills_wp hoare_vcg_all_lift
                    hoare_vcg_imp_lift' set_refills_wp)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps split: if_splits)
  done

lemma valid_state_sym_refs[dest]: "valid_state s \<Longrightarrow> sym_refs (state_refs_of s)"
  by (clarsimp simp: valid_state_def valid_pspace_def)

(* FIXME RT: remove duplicated versions below, possible move more stuff up with these. *)
lemma refill_budget_check_active_sc_tcb_at[wp]:
  "refill_budget_check usage \<lbrace>\<lambda>s. P (active_sc_tcb_at t s)\<rbrace>"
  unfolding refill_budget_check_defs schedule_used_defs
  apply (wpsimp wp: hoare_drop_imp whileLoop_wp')
  done

lemma refill_budget_check_active_sc_tcb_at':
  assumes "\<And>P. refill_budget_check usage \<lbrace>\<lambda>s. P (t s)\<rbrace>"
  shows "refill_budget_check usage \<lbrace>\<lambda>s. P (active_sc_tcb_at (t s) s)\<rbrace>"
  by (rule hoare_lift_Pf[where f=t, OF _ assms]) wp

lemmas refill_budget_check_active_sc_tcb_at_ct[wp]
  = refill_budget_check_active_sc_tcb_at'[where t=cur_thread, OF refill_budget_check_valid_sched_misc]

lemma refill_budget_check_round_robin_active_sc_tcb_at[wp]:
  "refill_budget_check_round_robin usage \<lbrace>\<lambda>s. P (active_sc_tcb_at t s)\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
  by (wpsimp wp: hoare_drop_imp)

lemma refill_budget_check_valid_ready_qs_offset_ready_and_sufficient:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> cur_sc_active s \<and> current_time_bounded s
        \<and> active_sc_valid_refills s
        \<and> cur_sc s \<noteq> idle_sc_ptr
        \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (rule hoare_lift_Pf2[where f="ready_queues", rotated], wpsimp)
  apply (clarsimp simp: valid_ready_qs_def released_sc_tcb_at_def)
  apply (intro hoare_vcg_all_lift_N_pre_conj)
  apply (rule hoare_vcg_conj_lift_N_pre_conj[rotated], wpsimp)
  apply (intro hoare_vcg_ball_lift_N_pre_conj hoare_vcg_conj_lift_pre_fix; (solves \<open>wpsimp\<close>)?)
   apply (clarsimp simp: pred_map2'_pred_maps)
   apply (wpsimp wp: hoare_vcg_ex_lift)
      apply (wpsimp wp: refill_budget_check_refill_ready_offset_ready_and_sufficient)
      apply (clarsimp, strengthen active_sc_valid_refillsE)
    apply (fastforce simp: vs_all_heap_simps split: if_splits)
  done

lemma refill_budget_check_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> cur_sc_active s
        \<and> active_sc_valid_refills s \<and> cur_sc s \<noteq> idle_sc_ptr
        \<and> ((cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s )
            \<or> (sc_not_in_ready_q (cur_sc s) s))
        \<and> current_time_bounded s\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. valid_ready_qs s \<or> valid_ready_qs s" in hoare_strengthen_post[rotated], simp)
  apply (wpsimp wp: hoare_vcg_disj_lift)
  apply (rule refill_budget_check_valid_ready_qs_offset_ready_and_sufficient)
  apply (rule refill_budget_check_valid_ready_qs_not_queued)
  apply fastforce
  done

lemma refill_budget_check_round_robin_valid_ready_qs_offset_ready_and_sufficient:
  "\<lbrace>\<lambda>s. valid_ready_qs s
        \<and> active_sc_valid_refills s
        \<and> pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) (cur_sc s)
        \<and> cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s
        \<and> current_time_bounded s \<and> unat usage + unat MAX_PERIOD \<le> unat max_time
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (rule hoare_lift_Pf2[where f="ready_queues", rotated], wpsimp)
  apply (clarsimp simp: valid_ready_qs_def released_sc_tcb_at_def)
  apply (intro hoare_vcg_all_lift_N_pre_conj)
  apply (rule hoare_vcg_conj_lift_N_pre_conj[rotated], wpsimp)
  apply (intro hoare_vcg_ball_lift_N_pre_conj hoare_vcg_conj_lift_pre_fix; (solves \<open>wpsimp\<close>)?)
   apply (clarsimp simp: pred_map2'_pred_maps)
   apply (wpsimp wp: hoare_vcg_ex_lift)
   apply (wpsimp wp: refill_budget_check_round_robin_refill_ready_offset_ready_and_sufficient)
  apply (fastforce simp: vs_all_heap_simps split: if_splits)
  done

lemma refill_budget_check_round_robin_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and>
         active_sc_valid_refills s \<and>
         current_time_bounded s \<and> pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) (cur_sc s) \<and>
         unat usage + unat MAX_PERIOD \<le> unat max_time \<and>
        ((cur_sc_offset_ready usage s \<and> cur_sc_offset_sufficient usage s )
         \<or> (sc_not_in_ready_q (cur_sc s) s))
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. valid_ready_qs s \<or> valid_ready_qs s" in hoare_strengthen_post[rotated], simp)
  apply (wpsimp wp: hoare_vcg_disj_lift)
  apply (rule refill_budget_check_round_robin_valid_ready_qs_offset_ready_and_sufficient)
  apply (rule refill_budget_check_round_robin_valid_ready_qs_not_queued)
  apply fastforce
  done

lemma commit_time_valid_sched_misc[wp]:
  "commit_time
   \<lbrace>\<lambda>s. P (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
          (ready_queues s) (release_queue s) (scheduler_action s)
          (etcbs_of s) (tcb_sts_of s) (tcb_scps_of s) (tcb_faults_of s) (sc_replies_of s)
          (ep_send_qs_of s) (ep_recv_qs_of s)\<rbrace>"
  unfolding commit_time_def
  by (wpsimp wp: hoare_drop_imp)

lemma commit_time_valid_release_q:
  "\<lbrace>valid_release_q and cur_sc_in_release_q_imp_zero_consumed and valid_state\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding commit_time_def
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (case_tac "sc_active sc \<and> csc \<noteq> idle_sc_ptr"; simp add: bind_assoc)
   apply (rule hoare_seq_ext[OF _ gets_sp])
   apply (rename_tac csc sc consumed)
  apply (rule_tac P="\<lambda>s. \<exists>tp. bound_sc_tcb_at ((=) (Some (cur_sc s))) tp s" in hoare_pre_tautI)
   apply (rule_tac P="\<lambda>s. sc_with_tcb_prop (cur_sc s) (\<lambda>s. in_release_q s) s" in hoare_pre_tautI)
    apply (rule_tac Q="valid_release_q and (\<lambda>s. consumed_time s = consumed)
                       and K (consumed = 0)"
                    in hoare_weaken_pre[rotated])
     apply (fastforce simp: vs_all_heap_simps obj_at_kh_kheap_simps cur_sc_in_release_q_imp_zero_consumed_def)
    apply (rule hoare_gen_asm)
    apply clarsimp
    apply (wpsimp simp: update_sched_context_def set_object_def wp: get_object_wp)
    apply (clarsimp simp: vs_all_heap_simps valid_release_q_def obj_at_def)
   apply (rule_tac Q="valid_release_q and (\<lambda>s. \<exists>tp. bound_sc_tcb_at ((=) (Some (cur_sc s))) tp s)
                      and (\<lambda>s. sc_not_in_release_q (cur_sc s) s) and (\<lambda>s. cur_sc s = csc)"
                   in hoare_weaken_pre[rotated])
    apply (clarsimp simp: obj_at_def pred_neg_def)
    apply (subgoal_tac "t = ta", clarsimp)
    apply (rule_tac z="cur_sc s" in sym_refs_bound_sc_tcb_at_inj)
      apply (clarsimp simp: valid_state_def valid_pspace_def, assumption)
     apply (clarsimp simp: pred_tcb_at_eq_commute[symmetric] tcb_at_kh_simps pred_map_eq_def)
    apply (clarsimp simp: pred_tcb_at_eq_commute[symmetric] tcb_at_kh_simps pred_map_eq_def)
  apply (wpsimp wp: sc_consumed_update_sc_tcb_sc_at hoare_vcg_all_lift hoare_drop_imps
                    set_refills_valid_release_q refill_budget_check_round_robin_valid_release_q
                    refill_budget_check_valid_release_q
              simp: cur_sc_in_release_q_imp_zero_consumed_def)+
  done

lemma commit_time_valid_ready_qs:
  "\<lbrace>valid_ready_qs
    and active_sc_valid_refills
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_more_than_ready s \<or> sc_not_in_ready_q (cur_sc s) s)\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding commit_time_def
  apply (wpsimp wp: refill_budget_check_round_robin_valid_ready_qs
                    refill_budget_check_valid_ready_qs
                    hoare_vcg_all_lift assert_inv hoare_vcg_imp_lift' is_round_robin_wp
              simp: cur_sc_more_than_ready_def)
  apply (subgoal_tac "cur_sc_active s", clarsimp simp: vs_all_heap_simps obj_at_def)
    apply (clarsimp simp: current_time_bounded_def)
   apply (erule consumed_time_bounded_helper)
   apply (clarsimp simp: current_time_bounded_def)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  done

lemma commit_time_valid_release_q_cur_sc_not_in_release_q:
  "\<lbrace>invs and schact_is_rct and valid_release_q and (\<lambda>s. sc_not_in_release_q (cur_sc s) s)\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding commit_time_def
  apply (wpsimp wp: sc_consumed_update_sc_tcb_sc_at hoare_vcg_all_lift hoare_drop_imp
                     refill_budget_check_valid_release_q
                     refill_budget_check_round_robin_valid_release_q
         split_del: if_split)
  by clarsimp

lemma commit_time_released_ipc_queues[wp]:
  "\<lbrace>released_ipc_queues
    and cur_sc_more_than_ready
    and active_sc_valid_refills
    and current_time_bounded\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  supply if_split[split del]
  apply (simp add: commit_time_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext_skip', wpsimp)
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rename_tac csc sc consumed)
  apply (rule hoare_seq_ext_skip', wpsimp)
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?)+
  apply (rule hoare_weaken_pre)
   apply (rule_tac R="cur_sc_more_than_ready and current_time_bounded
                      and (\<lambda>s. consumed = consumed_time s) and cur_sc_active
                      and (\<lambda>s. valid_refills (cur_sc s) s)
                      and (\<lambda>s. csc = cur_sc s)"
          in released_ipc_queues_lift_pre_conj)
    apply (wpsimp simp: budget_ready_def2
                    wp: hoare_vcg_ex_lift
                        refill_budget_check_round_robin_refill_ready_offset_ready_and_sufficient
                        refill_budget_check_refill_ready_offset_ready_and_sufficient)+
    apply (fastforce simp: cur_sc_more_than_ready_def current_time_bounded_def split: if_split)
   apply (wpsimp simp: budget_sufficient_def2
                     wp: hoare_vcg_ex_lift
                         refill_budget_check_round_robin_is_refill_sufficient
                         refill_budget_check_is_refill_sufficient)
   apply (fastforce simp: cur_sc_more_than_ready_def current_time_bounded_def split: if_split)
  by (fastforce simp: is_active_sc_def obj_at_def pred_map_def vs_all_heap_simps
                      active_sc_valid_refills_def)

lemma commit_time_valid_sched_action:
  "\<lbrace>valid_sched_action and simple_sched_action\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
   unfolding commit_time_def
   by (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps set_refills_valid_sched_action_act_not
                  refill_budget_check_valid_sched_action_act_not
            simp: refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
                  update_sched_context_set_refills_rewrite
       | strengthen simple_sched_act_not
       | intro conjI)+

crunches check_domain_time, refill_budget_check, refill_budget_check_round_robin
  for valid_blocked_except_set[wp]: "valid_blocked_except_set S"
  (wp: crunch_wps reschedule_required_valid_blocked
   simp: crunch_simps update_sched_context_set_refills_rewrite
   ignore: update_sched_context)

lemma refill_budget_check_not_active_sc[wp]:
   "\<lbrace>(\<lambda>s. \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>
    refill_budget_check usage
    \<lbrace>\<lambda>_ s. \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>"
  unfolding refill_budget_check_def update_sched_context_set_refills_rewrite update_refill_hd_def
  apply (rule hoare_seq_ext_skip, solves wpsimp, clarsimp?)+
  apply (rule hoare_seq_ext_skip)
   apply handle_overrun_loop_simple
  apply (rule hoare_seq_ext_skip, solves wpsimp, clarsimp?)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: hoare_drop_imp whileLoop_wp' set_refills_wp get_refills_wp
                     update_sched_context_wp
               simp: obj_at_def vs_all_heap_simps schedule_used_defs)
  apply head_insufficient_loop_simple
  done

lemma commit_time_not_active_sc[wp]:
  "\<lbrace>(\<lambda>s. \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>
   commit_time
   \<lbrace>\<lambda>_ s. \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>"
  apply (clarsimp simp: commit_time_def )
  by (wpsimp wp: hoare_drop_imp)

lemma refill_budget_check_round_robin_bounded_release_time[wp]:
  "\<lbrace>bounded_release_time scp
    and current_time_bounded\<rbrace>
   refill_budget_check_round_robin consumed
   \<lbrace>\<lambda>_. bounded_release_time scp\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: valid_sched_wp is_round_robin_wp get_refills_wp set_refills_wp)
  by (auto simp: vs_all_heap_simps bounded_release_time_def pred_map_simps obj_at_def
                 heap_upd_def current_time_bounded_def)

lemma set_refills_bounded_release_time:
  "\<lbrace>bounded_release_time scp
    and (\<lambda>s. sc_ptr = scp \<longrightarrow> bounded_release_time_2 (r_time (hd rfls)) )\<rbrace>
   set_refills sc_ptr rfls
   \<lbrace>\<lambda>_. bounded_release_time scp\<rbrace>"
  unfolding refill_budget_check_def
  apply (wpsimp wp: valid_sched_wp)
  by (clarsimp simp: vs_all_heap_simps bounded_release_time_def pred_map_simps obj_at_def
                    heap_upd_def split: if_split)

lemma refill_budget_check_schedule_used_r_time_helper:
  "r_time (hd refills) < MAX_RELEASE_TIME \<Longrightarrow>
   \<lbrace>\<lambda>s. all_sp_valid_refills_but_MIN_BUDGET_in_head (cur_sc s) s
        \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg) = unat (scrc_budget cfg))
                    (sc_refill_cfgs_of s) (cur_sc s)
        \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + (Suc n) * unat MAX_PERIOD
                           \<le> unat max_time)
                    (sc_refill_cfgs_of s) (cur_sc s)
        \<and> cur_sc s = csc_ptr
        \<and> (pred_map (\<lambda>cfg. r_time (scrc_refill_hd cfg) < MAX_RELEASE_TIME)
                     (sc_refill_cfgs_of s) (cur_sc s)
           \<longrightarrow> pred_map (\<lambda>cfg. u < r_amount (scrc_refill_hd cfg)) (sc_refill_cfgs_of s) (cur_sc s))
        \<and> (\<exists>sc n. ko_at (SchedContext sc n) csc_ptr s \<and> refills = sc_refills sc)
        \<and> (\<exists>n. ko_at (SchedContext sc n) csc_ptr s)\<rbrace>
    do y \<leftarrow> update_refill_hd csc_ptr (r_time_update (\<lambda>t. t + u) \<circ> r_amount_update (\<lambda>m. m - u));
            schedule_used csc_ptr \<lparr>r_time = r_time (refill_hd sc) + sc_period sc, r_amount = u\<rparr>
    od
    \<lbrace>\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + n * unat MAX_PERIOD \<le> unat max_time)
                      (sc_refill_cfgs_of s) (cur_sc s)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp get_refills_wp
              simp: schedule_used_def refill_add_tail_def update_refill_tl_def update_refill_hd_def)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  apply (case_tac "sc_refills sc")
   apply (clarsimp simp: schedule_used_def vs_all_heap_simps obj_at_def)
  apply (prop_tac "unat (r_amount a) \<le> unat (sc_budget sc)")
   apply (fastforce simp: refills_unat_sum_member_bound refills_unat_sum_cons)
  apply (subst unat_sub | subst unat_add_lem'' | linarith
         | clarsimp simp: word_le_nat_alt word_less_nat_alt no_overflow_def unat_sub window_def)+
  done
lemma refill_budget_check_bounded_release_time:
  "\<lbrace>bounded_release_time sc_ptr and cur_sc_offset_ready 0 and current_time_bounded
    and valid_refills sc_ptr and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. bounded_release_time sc_ptr\<rbrace>"
  (is "valid _ _ ?post")
  supply map_map[simp del] round_robin_def[simp add]
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext[OF _ is_round_robin_sp], rename_tac robin)
  apply (rule hoare_seq_ext[OF _ assert_sp], clarsimp)

  apply (case_tac "sc_ptr \<noteq> csc_ptr")
   apply (rule_tac B="\<lambda>_ s. bounded_release_time sc_ptr s \<and> robin = round_robin csc_ptr s
                            \<and> cur_sc s = csc_ptr"
                in hoare_seq_ext[rotated])
    apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                 simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                       schedule_used_defs
           | fastforce simp: obj_at_def vs_all_heap_simps )+)[1]
   apply ((wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
                simp: refill_budget_check_defs update_sched_context_set_refills_rewrite
                      schedule_used_defs
          | fastforce simp: obj_at_def vs_all_heap_simps)+)[1]

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                           = unat (scrc_budget cfg))
                                   (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (clarsimp simp: vs_all_heap_simps)
   apply (frule valid_refills_refills_unat_sum_equals_budget
          ; (fastforce simp: )?)
   apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)

  apply (rule_tac B="\<lambda>usage' s. \<not> round_robin sc_ptr s
                                \<and> all_sp_valid_refills_but_MIN_BUDGET_in_head_no_overflow sc_ptr s
                                \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                                   = unat (scrc_budget cfg))
                                            (sc_refill_cfgs_of s) sc_ptr
                                \<and> pred_map (\<lambda>cfg. unat (r_time (hd (scrc_refills cfg)))
                                                   + 4 * unat MAX_PERIOD
                                                   \<le> unat max_time)
                                            (sc_refill_cfgs_of s) (cur_sc s)
                                \<and> cur_sc s = sc_ptr \<and> cur_sc s \<noteq> idle_sc_ptr
                                \<and> (pred_map (\<lambda>cfg. r_time (hd (scrc_refills cfg)) < MAX_RELEASE_TIME)
                                             (sc_refill_cfgs_of s) sc_ptr
                                   \<longrightarrow> pred_map (\<lambda>cfg. usage' < r_amount (hd (scrc_refills cfg)))
                                                (sc_refill_cfgs_of s) sc_ptr)"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix
          ; (solves handle_overrun_loop_simple)?)
          apply (wpsimp wp: handle_overrun_loop_refills_sum)
          apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
         apply (wpsimp wp: handle_overrun_loop_ordered_disjoint)
         apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
        apply (wpsimp wp: handle_overrun_loop_window)
        apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
       apply (wpsimp wp: handle_overrun_loop_length)
       apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
      apply (wpsimp wp: handle_overrun_loop_non_zero_refills)
      apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
     apply (wpsimp wp: handle_overrun_loop_refills_unat_sum_equals_budget)
     apply (clarsimp simp: sc_valid_refills_def vs_all_heap_simps)
    apply (wpsimp wp: handle_overrun_loop_head_bound)
    apply (fastforce simp: sc_valid_refills_def vs_all_heap_simps)
   apply (clarsimp simp: handle_overrun_loop_def)
   apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_ s. pred_map \<top> (scs_of s) (cur_sc s)
                                                    \<and> sc_ptr = cur_sc s"])
    apply (fastforce simp: head_time_buffer_true_imp_unat_buffer vs_all_heap_simps word_less_nat_alt
                           word_le_nat_alt is_sc_obj_def)
   apply (clarsimp simp: vs_all_heap_simps)

  apply (rule_tac R1="\<lambda>s. pred_map (\<lambda>cfg. no_overflow (scrc_refills cfg)) (sc_refill_cfgs_of s) sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (fastforce intro!: head_time_buffer_implies_no_overflow simp: vs_all_heap_simps)

  apply (rule hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_ s. \<not> round_robin (cur_sc s) s
                           \<and> all_sp_valid_refills_but_MIN_BUDGET_in_head sc_ptr s
                           \<and> pred_map (\<lambda>cfg. refills_unat_sum (scrc_refills cfg)
                                              = unat (scrc_budget cfg))
                                       (sc_refill_cfgs_of s) sc_ptr
                           \<and> sc_ptr = cur_sc s \<and> cur_sc s \<noteq> idle_sc_ptr
                           \<and> pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 3 * unat MAX_PERIOD
                                             \<le> unat max_time)
                                      (sc_refill_cfgs_of s) (cur_sc s)"
               in hoare_seq_ext[rotated])
   apply (rule hoare_when_cases)
    apply ( clarsimp simp: vs_all_heap_simps current_time_bounded_def)
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves schedule_used_simple)?)
            apply (wpsimp wp: refill_budget_check_refills_sum_helper)
           apply (wpsimp wp: refill_budget_check_ordered_disjoint_helper', fastforce+)
          apply (wpsimp wp: refill_budget_check_no_overflow', fastforce+)
         apply (wpsimp wp: refill_budget_check_window_helper, fastforce+)
        apply (wpsimp wp: refill_budget_check_length_helper)
       apply (wpsimp wp: refill_budget_check_non_zero_refills_helper)
      apply (wpsimp wp: refill_budget_check_refills_unat_sum_helper, fastforce+)
     apply wpsimp
    apply (wpsimp wp: set_refills_wp get_refills_wp
                simp: vs_all_heap_simps update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
   apply (wpsimp wp: refill_budget_check_schedule_used_r_time_helper, fastforce+)
  apply (rule_tac Q="\<lambda>_ s. pred_map (\<lambda>cfg. unat (r_time (scrc_refill_hd cfg)) + 2 * unat MAX_PERIOD
                                           \<le> unat max_time) (sc_refill_cfgs_of s) sc_ptr"
               in hoare_strengthen_post[rotated])
   apply (clarsimp simp: bounded_release_time_def vs_all_heap_simps)
  apply (wpsimp wp: head_insufficient_loop_r_time_helper)
   apply (insert getCurrentTime_buffer_no_overflow)
   apply (clarsimp simp: MAX_PERIOD_def)
  apply clarsimp
  done

lemma refill_budget_check_round_robin_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) (cur_sc s))
    and K (unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and cur_sc_offset_sufficient consumed
    and current_time_bounded and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   refill_budget_check_round_robin consumed
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  unfolding active_sc_valid_refills_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift)

lemma cur_sc_bounded_release_helper:
  "kheap s (cur_sc s) = Some (SchedContext sc n)
  \<Longrightarrow> sc_period sc \<le> MAX_PERIOD
  \<Longrightarrow> unat (r_time (refill_hd sc)) + unat (sc_period sc) + unat MAX_PERIOD + unat consumed \<le> unat max_time
  \<Longrightarrow> unat (r_time (refill_hd sc)) + 2 * unat (sc_period sc) + unat consumed \<le> unat max_time"
  by (simp add: word_le_nat_alt)

lemma refill_budget_check_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and cur_sc_offset_ready 0
    and current_time_bounded and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   refill_budget_check consumed
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  unfolding active_sc_valid_refills_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift
                    refill_budget_check_bounded_release_time)
  done

(* These complicated preconditions maybe slightly improved since we should know that
   the cur_sc is ready at this point *)
lemma commit_time_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and cur_sc_more_than_ready
    and current_time_bounded
    and consumed_time_bounded\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  unfolding commit_time_def
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext[where B="\<lambda>_. active_sc_valid_refills"], wpsimp)
  apply clarsimp
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[where B="\<lambda>_. active_sc_valid_refills"], wpsimp)
  apply (rule hoare_when_cases, simp)
  apply (wpsimp wp: assert_inv
                    refill_budget_check_round_robin_active_sc_valid_refills
                    refill_budget_check_active_sc_valid_refills)
      apply (wpsimp wp: assert_inv is_round_robin_wp)+
  apply (clarsimp simp: obj_at_def cur_sc_more_than_ready_def)
  apply (subgoal_tac "cur_sc_active s";
         fastforce simp: vs_all_heap_simps consumed_time_bounded_def current_time_bounded_def
                         refill_ready_no_overflow_def)
  done

lemma commit_time_valid_blocked_except_set[wp]:
  "commit_time \<lbrace>valid_blocked_except_set S\<rbrace>"
  unfolding commit_time_def
  by (wpsimp wp: hoare_drop_imps)

lemma refill_budget_check_active_reply_scs[wp]:
  "refill_budget_check usage \<lbrace>active_reply_scs\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
  apply handle_overrun_loop_simple
    apply (fastforce simp: active_reply_scs_def active_if_reply_sc_at_def vs_all_heap_simps
                           active_sc_def obj_at_def)+
  apply (rule hoare_seq_ext_skip,
         solves \<open>wpsimp simp: update_refill_hd_rewrite update_sched_context_set_refills_rewrite
                              schedule_used_defs\<close>)+
  apply head_insufficient_loop_simple
   apply (fastforce simp: active_reply_scs_def active_if_reply_sc_at_def vs_all_heap_simps
                          active_sc_def obj_at_def)
  apply head_insufficient_loop_simple
   apply (fastforce simp: active_reply_scs_def active_if_reply_sc_at_def vs_all_heap_simps
                          active_sc_def obj_at_def)
  done

lemma refill_budget_check_round_robin_active_reply_scs[wp]:
  "refill_budget_check_round_robin usage \<lbrace>active_reply_scs\<rbrace>"
  by (wpsimp wp: refill_budget_check_round_robin_sc_refills_update_unspecified
           simp: active_reply_scs_defs)

lemma commit_time_active_reply_scs[wp]:
  "commit_time \<lbrace>active_reply_scs\<rbrace>"
  unfolding commit_time_def by (wpsimp wp: hoare_drop_imps)

lemma commit_time_valid_sched:
  "\<lbrace>valid_sched
    and simple_sched_action
    and cur_sc_in_release_q_imp_zero_consumed
    and cur_sc_more_than_ready
    and current_time_bounded
    and consumed_time_bounded
    and valid_state\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def
  apply (wpsimp wp: commit_time_valid_release_q commit_time_active_sc_valid_refills
                    commit_time_valid_ready_qs commit_time_valid_sched_action)
  done

(* end commit_time *)

(* refill_unblock_check *)

lemma update_sched_context_tcb_ready_times_idem:
  assumes "Q t"
  assumes "\<And>sc. sc_refill_cfg_of (f sc) = g (sc_refill_cfg_of sc)"
  assumes "\<And>sc. sc_tcb (f sc) = h (sc_tcb sc)"
  assumes "\<And>sc. sc_replies (f sc) = k (sc_replies sc)"
  shows "\<lbrace>\<lambda>s. P (tcb_ready_times_of s t) \<and> sc_with_tcb_prop sc_ptr (\<lambda>t s. \<not> Q t) s\<rbrace>
         update_sched_context sc_ptr f
         \<lbrace>\<lambda>_ s. P (tcb_ready_times_of s t)\<rbrace>"
  apply (wpsimp wp: update_sched_context_valid_sched_pred'
                    [where g=g and f=f and h=h and k=k, OF assms(2-4), THEN hoare_drop_assertion])
  using assms
  by (fastforce simp: heap_upd_def tcb_ready_times_defs
                      map_project_simps opt_map_simps map_join_simps vs_all_heap_simps
               split: if_splits
               elim!: rsubst[of P]
              intro!: option_eqI[where opt'="map_project _ _ _"])

lemma ready_or_release_reprogram_timer_update[simp]:
  "ready_or_release (s\<lparr>reprogram_timer := b\<rparr>)
          = ready_or_release s"
  by (clarsimp simp: ready_or_release_def)

crunches refill_unblock_check
  for sc_at_period[wp]: "sc_at_period P p"
  and sc_at_period_sc[wp]: "\<lambda>s. sc_at_period P (cur_sc s) s"
    (wp: crunch_wps simp: crunch_simps update_sched_context_set_refills_rewrite
     ignore: update_sched_context)

lemma refill_unblock_check_cur_sc_budget_sufficient[wp]:
  "\<lbrace>\<lambda>s. cur_sc_budget_sufficient s \<and> sc_ptr \<noteq> cur_sc s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_ s. cur_sc_budget_sufficient s\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps)
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply merge_refills_simple
  done

(* end refill_unblock_check *)

lemma ready_or_release_updates[simp]:
  "ready_or_release (trans_state a s) = ready_or_release s"
  by (simp add: ready_or_release_def)+

lemma refill_unblock_check_refill_ready_no_overflow_sc:
  "\<lbrace>\<lambda>s. pred_map (refill_ready_no_overflow_sc usage curtime) (sc_refill_cfgs_of s) sc_ptr'
        \<and> sc_ptr' \<noteq> sc_ptr\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_ s. pred_map (refill_ready_no_overflow_sc usage curtime) (sc_refill_cfgs_of s) sc_ptr'\<rbrace>"
  unfolding refill_unblock_check_defs refill_ready_no_overflow_def merge_refill_def
  apply (wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp' is_round_robin_wp
              simp: vs_all_heap_simps obj_at_def update_sched_context_set_refills_rewrite)
  done

lemma ruc_is_refill_sufficient_indep:
  "\<lbrace>\<lambda>s. is_refill_sufficient usage sc_ptr' s \<and> sc_ptr' \<noteq> sc_ptr\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_ s. is_refill_sufficient usage sc_ptr' s\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: vs_all_heap_simps)
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply merge_refills_simple
  done

lemma refill_unblock_check_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. scptr \<noteq> cur_sc s)\<rbrace>
   refill_unblock_check scptr
   \<lbrace>\<lambda>_. cur_sc_more_than_ready\<rbrace>"
  apply (wpsimp wp: hoare_vcg_imp_lift' simp: cur_sc_more_than_ready_def)
    apply (wps, wpsimp)
   apply (wps, wpsimp wp: refill_unblock_check_refill_ready_no_overflow_sc
                          ruc_is_refill_sufficient_indep hoare_vcg_imp_lift')
  apply clarsimp
  done

lemma if_cond_refill_unblock_check_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. \<forall>scp. scopt = Some scp \<longrightarrow> scp \<noteq> cur_sc s)\<rbrace>
   if_cond_refill_unblock_check scopt act ast
   \<lbrace>\<lambda>_. cur_sc_more_than_ready\<rbrace>"
  by (wpsimp simp: if_cond_refill_unblock_check_def)

lemma cur_tcb_sc_at:
  "\<lbrakk>valid_objs s; cur_tcb s; bound_sc_tcb_at ((=) (Some sc_ptr)) (cur_thread s) s\<rbrakk>
   \<Longrightarrow> sc_at sc_ptr s"
  apply (clarsimp simp: cur_tcb_def valid_objs_def)
  apply (drule_tac x="cur_thread s" in bspec)
   apply (clarsimp simp: obj_at_def is_tcb_def)
  apply (clarsimp simp: valid_obj_def obj_at_def pred_tcb_at_def valid_tcb_def valid_bound_obj_def
                        option_None_True_const)
  done

lemma switch_sched_context_valid_sched:
  "\<lbrace>valid_sched and simple_sched_action
     and valid_state and cur_tcb
     and cur_sc_in_release_q_imp_zero_consumed
     and cur_sc_more_than_ready
     and current_time_bounded
     and consumed_time_bounded
     and (\<lambda>s. \<forall>a. bound_sc_tcb_at ((=) (Some a)) (cur_thread s) s \<longrightarrow> a \<noteq> cur_sc s \<longrightarrow> ct_not_in_release_q s)\<rbrace>
   switch_sched_context
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (clarsimp simp: switch_sched_context_def assert_opt_def if_cond_refill_unblock_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac sc_opt; clarsimp simp: bind_assoc)
  apply (wpsimp wp: commit_time_valid_sched hoare_drop_imp assert_inv refill_unblock_check_valid_sched)
  apply (clarsimp cong: conj_cong)
  apply (intro conjI impI; (simp add: current_time_bounded_def)?)
    apply (clarsimp simp: tcb_at_kh_simps pred_map_eq_normalise)
    apply (subgoal_tac "t = cur_thread s", simp)
    apply (erule (1) heap_refs_inj_eq[rotated])
    apply (rule sym_refs_inj_tcb_scps, clarsimp simp: valid_state_def valid_pspace_def)
   apply (clarsimp simp: valid_state_def)+
  done

lemma sc_and_timer_valid_sched:
  "\<lbrace>valid_sched and simple_sched_action
     and valid_state and cur_tcb
     and cur_sc_in_release_q_imp_zero_consumed
     and cur_sc_more_than_ready
     and current_time_bounded
     and consumed_time_bounded
     and (\<lambda>s. \<forall>a. bound_sc_tcb_at ((=) (Some a)) (cur_thread s) s \<longrightarrow> a \<noteq> cur_sc s \<longrightarrow> ct_not_in_release_q s)\<rbrace>
   sc_and_timer
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (clarsimp simp: sc_and_timer_def)
  by (wpsimp wp: switch_sched_context_valid_sched)

context DetSchedSchedule_AI begin

lemma schedule_choose_new_thread_sc_not_in_ready_q[wp]:
  "schedule_choose_new_thread \<lbrace>\<lambda>s :: 'state_ext state. sc_not_in_ready_q (cur_sc s) s \<rbrace>"
  unfolding schedule_choose_new_thread_def
  by (wpsimp wp:  choose_thread_sc_not_in_ready_q_cur)

(*
we know that after calling awaken,
all threads in the release queue are either not sufficient or ready
the current thread can be in the release queue
*)

(* FIXME: remove.
   Currently only mentioned by commented out schedule_valid_sched_helper.
   And if rephrased using heap projections, it's just a specialisation of existing [wp] rules. *)
lemma schedule_tcb_sched_enqueue_helper:
  "tcb_sched_action tcb_sched_enqueue ct
   \<lbrace>\<lambda>s. bound_sc_tcb_at (\<lambda>p. \<exists>scp. p = Some scp \<and> is_refill_ready scp s
                                                \<and> is_refill_sufficient 0 scp s)
                        candidate s\<rbrace>"
  by (wpsimp simp: obj_at_kh_kheap_simps)

(* FIXME: this should be expressed more elegantly *)
lemma enqueue_thread_queued_ct:
  "\<lbrace>\<lambda>s. thread = cur_thread s \<rbrace>
     tcb_sched_action tcb_sched_enqueue thread
   \<lbrace>\<lambda>_ s. (\<exists>d prio. cur_thread s \<in> set (ready_queues s d prio))\<rbrace>"
  apply (simp add: tcb_sched_action_def)
  apply (wpsimp wp: set_tcb_queue_wp simp: thread_get_def)
  apply (fastforce simp: etcb_at_def tcb_sched_enqueue_def obj_at_def pred_tcb_at_def
                        is_refill_ready_def is_refill_sufficient_def
                  split: option.splits dest!: get_tcb_SomeD)
  done

lemma valid_refills_cur_thread_update[simp]:
  "valid_refills ptr (s\<lparr>cur_thread := param_a\<rparr>) = valid_refills ptr s"
  by (clarsimp simp: valid_refills_def)

lemma valid_refills_domain_list_update[simp]:
  "valid_refills ptr (s\<lparr>domain_list := param_a\<rparr>) = valid_refills ptr s"
  by (clarsimp simp: valid_refills_def)

lemma valid_refills_cur_domain_update[simp]:
  "valid_refills ptr (s\<lparr>cur_domain := param_a\<rparr>) = valid_refills ptr s"
  by (clarsimp simp: valid_refills_def)

lemma valid_refills_domain_index_update[simp]:
  "valid_refills ptr (s\<lparr>domain_index := param_a\<rparr>) = valid_refills ptr s"
  by (clarsimp simp: valid_refills_def)

crunches schedule_choose_new_thread, switch_to_thread, set_scheduler_action, tcb_sched_action
  for sc_at_period[wp]: "sc_at_period P p :: 'state_ext state \<Rightarrow> _"
    (wp: valid_sched_pred_heap_proj_lowers[where R=\<top>, simplified])

lemma schedule_choose_new_thread_sc_at_period_cur[wp]:
  "\<lbrace>\<lambda>s :: ('state_ext state). sc_at_period P (cur_sc s) s\<rbrace> schedule_choose_new_thread \<lbrace>\<lambda>_ s. sc_at_period P (cur_sc s) s\<rbrace>"
   by (rule hoare_lift_Pf[where f=cur_sc];
       wpsimp wp: valid_sched_pred_heap_proj_lowers[where R=\<top>, simplified])

lemma switch_to_thread_sc_at_period_cur[wp]:
  "\<lbrace>\<lambda>s::('state_ext state). sc_at_period P (cur_sc s) s\<rbrace> switch_to_thread t \<lbrace>\<lambda>_ s. sc_at_period P (cur_sc s) s\<rbrace>"
   by (rule hoare_lift_Pf[where f=cur_sc];
       wpsimp wp: valid_sched_pred_heap_proj_lowers[where R=\<top>, simplified])

(* FIXME move *)
lemma cur_tcb_get_tcb: "cur_tcb s \<Longrightarrow> \<exists>tcb. get_tcb (cur_thread s) s = Some tcb"
  by (clarsimp simp: cur_tcb_def obj_at_def is_tcb get_tcb_rev)

lemma not_schedulable_in_release_q_case:
  "\<lbrakk>\<not> ct_schedulable s;
    ct_active s; active_sc_tcb_at (cur_thread s) s\<rbrakk>
       \<Longrightarrow> in_release_q (cur_thread s) s"
  by (clarsimp simp: schedulable_def2 ct_in_state_def tcb_at_kh_simps runnable_eq_active)

lemma awaken_valid_sched_misc[wp]:
  "awaken \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s)
                 (cur_thread s) (idle_thread s) (kheap s) \<rbrace>"
  apply (wpsimp simp: awaken_def awaken_body_def tcb_release_dequeue_def)
  apply (rule whileLoop_wp)
   apply wpsimp+
  done

crunches awaken
  for sc_at_period[wp]: "sc_at_period P p :: 'state_ext state \<Rightarrow> _"
  and sc_at_period_cur[wp]: "\<lambda>s. sc_at_period P (cur_sc s) s"
    (simp: crunch_simps wp: crunch_wps)

(* FIXME move *)
lemma valid_release_q_sorted: "valid_release_q s \<Longrightarrow> sorted_release_q s"
  by (clarsimp simp: valid_release_q_def)

(* FIXME: move up to replace sorted_wrt_img_ord_eq_lift *)
lemma sorted_wrt_cong:
  assumes "xs=ys"
  and "\<And>x y. \<lbrakk>x \<in> set ys; y \<in> set ys\<rbrakk> \<Longrightarrow> cmp x y = cmp' x y"
  shows "sorted_wrt cmp xs = sorted_wrt cmp' ys"
  using assms by (induct xs; metis sorted_wrt_mono_rel)

lemma in_release_q_has_ready_time:
  fixes s :: "'z state"
  assumes "valid_release_q s"
  assumes "t \<in> set (release_queue s)"
  shows "\<exists>rt. tcb_ready_times_of s t = Some rt"
  using assms valid_release_q_active_sc[OF assms]
  by (auto simp: tcb_ready_times_defs map_project_simps opt_map_simps map_join_simps vs_all_heap_simps)

lemma in_release_q_opt_ord_conv:
  fixes s :: "'z state"
  assumes vrq: "valid_release_q s"
  assumes t: "t \<in> set (release_queue s)"
  assumes t': "t' \<in> set (release_queue s)"
  shows "opt_ord (tcb_ready_times_of s t) (tcb_ready_times_of s t') \<longleftrightarrow> tcb_ready_time t s \<le> tcb_ready_time t' s"
  using in_release_q_has_ready_time[OF vrq t] in_release_q_has_ready_time[OF vrq t']
  by auto

lemma possible_switch_to_not_queued:
  "\<lbrace>not_queued t and K (t \<noteq> thread) and scheduler_act_not t\<rbrace>
     possible_switch_to thread \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (clarsimp simp: possible_switch_to_def)
  by (wpsimp wp: tcb_sched_enqueue_not_queued hoare_drop_imp reschedule_required_not_queued)

lemma possible_switch_to_ct_not_queued':
  "\<lbrace>ct_not_queued and (\<lambda>s. cur_thread s \<noteq> thread) and scheduler_act_sane\<rbrace>
     possible_switch_to thread \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  apply (clarsimp simp: possible_switch_to_def)
  apply (wpsimp wp: hoare_drop_imp reschedule_required_ct_not_queued)
  apply (wpsimp wp: tcb_sched_enqueue_not_queued thread_get_wp get_tcb_obj_ref_wp | wps)+
  apply (clarsimp simp: obj_at_def is_tcb)
  done

lemma possible_switch_to_scheduler_act_sane'':
  "\<lbrace>scheduler_act_sane and (\<lambda>s. cur_thread s \<noteq> thread)\<rbrace>
     possible_switch_to thread \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  apply (clarsimp simp: possible_switch_to_def)
  by (wpsimp wp: tcb_sched_action_scheduler_action hoare_drop_imp simp: set_scheduler_action_def)
     (clarsimp simp: scheduler_act_sane_def)

lemma awaken_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "awaken \<lbrace>cur_sc_in_release_q_imp_zero_consumed ::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: awaken_def awaken_body_def tcb_release_dequeue_def)
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (rule whileLoop_wp)
   apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')+
  done

lemma awaken_ready_or_release_helper:
  "\<lbrace>(\<lambda>s. \<forall>t\<in>set queue. tcb_at t s) and ready_or_release and K (distinct queue)\<rbrace>
       mapM_x (\<lambda>t. do consumed <- gets consumed_time;
                       sc_opt <- thread_get tcb_sched_context t;
                       scp <- assert_opt sc_opt;
                       sufficient <- get_sc_refill_sufficient scp consumed;
                       y <- assert sufficient;
                       y <- possible_switch_to t;
                       modify (reprogram_timer_update (\<lambda>_. True))
                    od) queue
   \<lbrace>\<lambda>_. ready_or_release :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (rule hoare_gen_asm, rule ball_mapM_x_scheme, (wpsimp wp: hoare_drop_imp)+)

(* FIXME move *)
lemma notdropWhile_takeWhile:
  "t \<in> set q
   \<Longrightarrow> t \<notin> set (dropWhile P q)
   \<Longrightarrow> t \<in> set (takeWhile P q)"
  apply (subst (asm) takeWhile_dropWhile_id[symmetric])
  apply (simp only: set_append)
  by fastforce

lemma awaken_in_release_q:
  "\<lbrace>in_release_q t and valid_release_q and (not budget_ready t)\<rbrace>
   awaken
   \<lbrace>\<lambda>_ s. in_release_q t s\<rbrace>"
   (is "valid ?pre _ _")
  apply (wpsimp simp: awaken_def awaken_body_def tcb_release_dequeue_def)
  apply (rule_tac I="\<lambda>_. ?pre" in valid_whileLoop; (solves simp)?)
  apply (clarsimp simp: pred_conj_def pred_neg_def)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves \<open>wpsimp wp: hoare_drop_imps\<close>)?)
  apply (wpsimp wp: tcb_release_remove_in_release_q_neq)
  using read_release_q_non_empty_and_ready_True_simp
        valid_release_q_read_release_q_non_empty_and_ready_bound
  by fastforce

lemma switch_to_thread_eq_idle_thread:
  "\<lbrace>\<lambda>s. t = idle_thread s\<rbrace> switch_to_thread t \<lbrace>\<lambda>_ s :: 'state_ext state. cur_thread s = idle_thread s\<rbrace>"
  by (wpsimp wp: valid_sched_wp)

lemma switch_to_thread_special:
  "\<lbrace>(\<lambda>s. (in_cur_domain candidate s \<or> candidate = idle_thread s)) :: 'state_ext state \<Rightarrow> _\<rbrace>
   switch_to_thread candidate
   \<lbrace>\<lambda>_ s. (in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s)\<rbrace>"
  by (wpsimp wp: hoare_vcg_disj_lift switch_to_thread_eq_idle_thread)

crunches tcb_sched_action
  for machine_times[wp]: "\<lambda>s. P (last_machine_time_of s) (time_state_of s) (cur_time s)"

crunches check_domain_time
  for valid_sched[wp]: valid_sched
  and cur_sc_in_release_q_imp_zero_consumed[wp]: cur_sc_in_release_q_imp_zero_consumed
  and cur_sc_more_than_ready[wp]: cur_sc_more_than_ready
  and current_time_bounded[wp]: current_time_bounded
  and consumed_time_bounded[wp]: consumed_time_bounded
  and ct_ready_if_schedulable[wp]: ct_ready_if_schedulable
  (wp: reschedule_valid_sched_const)

lemma schedule_valid_sched_helper:
  "\<lbrace> valid_sched
     and invs
     and cur_sc_in_release_q_imp_zero_consumed
     and cur_sc_more_than_ready
     and current_time_bounded
     and consumed_time_bounded
     and ct_ready_if_schedulable\<rbrace>
   do check_domain_time;
      ct <- gets cur_thread;
      ct_schedulable <- is_schedulable ct;
      action <- gets scheduler_action;
      case action of resume_cur_thread \<Rightarrow> return ()
      | switch_thread candidate \<Rightarrow>
          do when ct_schedulable (tcb_sched_action tcb_sched_enqueue ct);
             it <- gets idle_thread;
             target_prio <- thread_get tcb_priority candidate;
             ct_prio <- if ct \<noteq> it then thread_get tcb_priority ct else return 0;
             fastfail <- schedule_switch_thread_fastfail ct it ct_prio target_prio;
             cur_dom <- gets cur_domain;
             highest <- gets (is_highest_prio cur_dom target_prio);
             if fastfail \<and> \<not> highest then do tcb_sched_action tcb_sched_enqueue candidate;
                                              set_scheduler_action choose_new_thread;
                                              schedule_choose_new_thread
                                           od
             else if ct_schedulable \<and> ct_prio = target_prio then do tcb_sched_action tcb_sched_append candidate;
                   set_scheduler_action choose_new_thread;
                   schedule_choose_new_thread
                                                                  od
                  else do switch_to_thread candidate;
                          set_scheduler_action resume_cur_thread
                       od
          od
      | choose_new_thread \<Rightarrow> do when ct_schedulable (tcb_sched_action tcb_sched_enqueue ct);
                                schedule_choose_new_thread
                             od;
      sc_and_timer
   od
  \<lbrace>\<lambda>_. valid_sched :: ('state_ext state) \<Rightarrow> _\<rbrace>"
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply clarsimp
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac action)
  apply (case_tac action; clarsimp)

  (* resume_cur_thread *)
  subgoal for ct ct_schedulable
    apply (fold schact_is_rct_def)
    apply (wpsimp wp: sc_and_timer_valid_sched)
    apply (clarsimp simp: schedulable_def2)
    apply (intro conjI impI allI; (solves \<open>clarsimp\<close>)?)
    apply (clarsimp simp: invs_def cur_sc_tcb_def schact_is_rct)
    apply (subst (asm) sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[symmetric]; simp?)
     apply (clarsimp simp: valid_state_def valid_pspace_def)
    apply (clarsimp simp: tcb_at_kh_simps pred_map_def)
    done

  (* switch_thread candidate *)
  subgoal for ct ct_schedulable candidate
    apply wpsimp
      apply (wpsimp wp: sc_and_timer_valid_sched )
     apply wpsimp
               apply (rule_tac Q="\<lambda>rv s. (valid_state s \<and> cur_tcb s) \<and>
                                         valid_sched s \<and>
                                         simple_sched_action s \<and>
                                         ct_not_in_release_q s \<and>
                                         ct_not_queued s \<and>
                                         cur_sc_in_release_q_imp_zero_consumed s \<and>
                                         cur_sc_more_than_ready s \<and>
                                         current_time_bounded s \<and>
                                         consumed_time_bounded s"
                      in hoare_strengthen_post[rotated], simp)
               apply (wp add: schedule_choose_new_thread_valid_sched
                              schedule_choose_new_thread_ct_not_in_release_q
                              schedule_choose_new_thread_ct_not_queued)
              apply (rule_tac Q="\<lambda>rv. invs and
                                      valid_idle_etcb and valid_ready_qs and
                                      valid_release_q and active_reply_scs and
                                      valid_blocked and
                                      (\<lambda>s. scheduler_action s = choose_new_thread) and
                                      (\<lambda>s. active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s \<longrightarrow>
                                            ct_in_q s) and
                                      released_ipc_queues and
                                      active_sc_valid_refills and
                                      valid_ready_qs and
                                      ready_or_release and
                                      cur_sc_in_release_q_imp_zero_consumed and cur_sc_more_than_ready and
                                      current_time_bounded and consumed_time_bounded" in hoare_strengthen_post[rotated])
               apply clarsimp
              apply (wpsimp wp: set_scheduler_action_valid_blocked_const )
             apply (rule_tac Q="\<lambda>rv s. invs s \<and>
                                       valid_idle_etcb s \<and>
                                       valid_ready_qs s \<and> active_reply_scs s \<and>
                                       valid_release_q s \<and>
                                       (valid_blocked and
                                       (\<lambda>s. scheduler_action s = switch_thread candidate \<and> in_ready_q candidate s )) s \<and>
                                       released_ipc_queues s \<and>
                                       active_sc_valid_refills s \<and>
                                       ready_or_release s \<and>
                                       current_time_bounded s \<and> consumed_time_bounded s \<and>
                                       (active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s \<longrightarrow>
                                        ct_in_q s) \<and>
                                       cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_more_than_ready s"
                    in hoare_strengthen_post[rotated], clarsimp)
             apply (wpsimp wp: tcb_sched_enqueue_valid_blocked_except_set_const tcb_sched_enqueue_ct_in_q hoare_vcg_imp_lift')
            apply wpsimp
               apply (rule_tac Q="\<lambda>rv s. (valid_state s \<and> cur_tcb s) \<and>
                                          valid_sched s \<and>
                                          simple_sched_action s \<and>
                                          ct_not_in_release_q s \<and>
                                          ct_not_queued s \<and>
                                          consumed_time_bounded s \<and>
                                          current_time_bounded s \<and>
                                          cur_sc_in_release_q_imp_zero_consumed s \<and>
                                          cur_sc_more_than_ready s"
                      in hoare_strengthen_post[rotated], simp)
               apply (wp add: schedule_choose_new_thread_valid_sched
                              schedule_choose_new_thread_ct_not_in_release_q
                              schedule_choose_new_thread_ct_not_queued )
              apply (rule_tac Q="\<lambda>rv b. invs b \<and>
                                        (valid_idle_etcb and valid_ready_qs and
                                         valid_release_q and
                                         valid_blocked and active_reply_scs and
                                         (\<lambda>s. scheduler_action s = choose_new_thread) and
                                        ct_in_q and
                                        released_ipc_queues) b \<and>
                                        active_sc_valid_refills b \<and>
                                        ready_or_release b \<and>
                                        consumed_time_bounded b \<and>
                                        current_time_bounded b \<and>
                                        cur_sc_in_release_q_imp_zero_consumed b \<and>
                                        cur_sc_more_than_ready b"
                     in hoare_strengthen_post[rotated])
               apply clarsimp
              apply (wpsimp wp: set_scheduler_action_valid_blocked_const )
             apply (rule_tac Q="\<lambda>rv s. invs s \<and>
                                       valid_idle_etcb s \<and>
                                       valid_ready_qs s \<and> active_reply_scs s \<and>
                                       valid_release_q s \<and>
                                       (valid_blocked and
                                       (\<lambda>s. scheduler_action s = switch_thread candidate \<and> in_ready_q candidate s )) s \<and>
                                       released_ipc_queues s \<and>
                                       ct_in_q s \<and>
                                       active_sc_valid_refills s \<and>
                                       ready_or_release s \<and>
                                       consumed_time_bounded s \<and>
                                       current_time_bounded s \<and>
                                       cur_sc_in_release_q_imp_zero_consumed s \<and>
                                       cur_sc_more_than_ready s"
                    in hoare_strengthen_post[rotated], clarsimp)
             apply (wpsimp wp: tcb_sched_append_valid_blocked_except_set_const tcb_sched_append_ct_in_q )
            apply wpsimp
             apply (rule_tac Q="\<lambda>rv s. (valid_state s \<and> cur_tcb s) \<and>
                                       valid_sched s \<and>
                                       simple_sched_action s \<and>
                                       ct_not_in_release_q s \<and>
                                       ct_not_queued s \<and>
                                       cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_more_than_ready s \<and>
                                       current_time_bounded s \<and>
                                       consumed_time_bounded s"
                    in hoare_strengthen_post[rotated], simp)
             apply (wpsimp wp: set_scheduler_action_rct_valid_sched_ct
                               set_scheduler_action_simple_sched_action )
            apply (rule_tac Q="\<lambda>rv b. invs b \<and>
                                      (valid_sched and ct_not_queued and
                                      (\<lambda>s. scheduler_action s = switch_thread (cur_thread s)) and
                                       ct_in_state activatable) b \<and>
                                      ct_not_in_release_q b \<and>
                                      ct_not_queued b \<and>
                                      cur_sc_in_release_q_imp_zero_consumed b \<and> cur_sc_more_than_ready b \<and>
                                      current_time_bounded b \<and>
                                      consumed_time_bounded b \<and>
                                      (\<lambda>s. in_cur_domain (cur_thread s) s \<or> cur_thread s = idle_thread s) b"
                   in hoare_strengthen_post[rotated], simp add: ct_in_state_def)
             apply fastforce
            apply (wpsimp wp: switch_to_thread_invs switch_to_thread_valid_sched
                              switch_to_thread_sched_act_is_cur
                              stt_activatable switch_to_thread_special)
           apply wpsimp+
         apply (rule_tac Q="\<lambda>rv s. invs s \<and>
                                   valid_sched s \<and> (ct_schedulable = (active_sc_tcb_at (cur_thread s) s \<and>
                                   ct_active s \<and> ct_not_in_release_q s)) \<and> (ct_schedulable \<longrightarrow> ct_in_q s) \<and>
                                   consumed_time_bounded s \<and> current_time_bounded s \<and>
                                   scheduler_action s = switch_thread candidate \<and>
                                   cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_more_than_ready s"
                in hoare_strengthen_post[rotated])
          apply (clarsimp simp: valid_sched_def )
          apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def released_sc_tcb_at_def
                                switch_in_cur_domain_def tcb_at_kh_simps not_in_release_q_def)
          apply (intro conjI impI allI; clarsimp simp: ct_in_state_kh_simp runnable_eq_active ct_in_q_def pred_tcb_at_kh_simps)
          apply (erule pred_map_imp, clarsimp)
         apply wpsimp
        apply wpsimp
       apply wpsimp
      apply wpsimp
     apply (wpsimp wp: tcb_sched_enqueue_cur_ct_in_q)
    apply (clarsimp simp: schedulable_def2 valid_sched_def ct_ready_if_schedulable_def)
    apply (clarsimp simp: ct_in_state_kh_simp runnable_eq_active tcb_at_kh_simps)
    apply fastforce
  done

  (* choose_new_thread *)
  subgoal for ct ct_schedulable
    apply (wpsimp wp: sc_and_timer_valid_sched )
      apply (rule_tac Q="\<lambda>rv s. (valid_state s \<and> cur_tcb s) \<and>
                                valid_sched s \<and>
                                simple_sched_action s \<and>
                                current_time_bounded s \<and> consumed_time_bounded s \<and>
                                ct_not_in_release_q s \<and>
                                ct_not_queued s \<and>
                                cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_more_than_ready s"
             in hoare_strengthen_post[rotated], simp)
      apply (wp add: schedule_choose_new_thread_valid_sched
                     schedule_choose_new_thread_ct_not_in_release_q
                     schedule_choose_new_thread_ct_not_queued )
     apply (rule_tac Q="\<lambda>rv b. invs b \<and>
                               (valid_idle_etcb and valid_ready_qs and
                                valid_release_q and active_reply_scs and
                                valid_blocked and
                                (\<lambda>s. scheduler_action s = choose_new_thread) and
                                (\<lambda>s. active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s \<longrightarrow>
                                      ct_in_q s) and
                                released_ipc_queues) b \<and>
                               cur_sc_in_release_q_imp_zero_consumed b \<and>
                               active_sc_valid_refills b \<and>
                               current_time_bounded b \<and>
                               consumed_time_bounded b \<and>
                               ready_or_release b \<and>
                               cur_sc_more_than_ready b"
            in hoare_strengthen_post[rotated])
      apply clarsimp
     apply (wpsimp wp: set_scheduler_action_valid_blocked_const tcb_sched_enqueue_valid_blocked_except_set_const
                       tcb_sched_enqueue_cur_ct_in_q hoare_vcg_imp_lift' )
    apply (clarsimp simp: schedulable_def2 valid_sched_def ct_ready_if_schedulable_def)
    apply (intro allI conjI impI)
     apply (clarsimp simp: released_sc_tcb_at_def tcb_at_kh_simps)
    apply (clarsimp simp: ct_in_q_def tcb_at_kh_simps)
    done
  done

lemma awaken_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable
    and valid_release_q\<rbrace>
   awaken
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding ct_ready_if_schedulable_def
  apply (wpsimp wp: hoare_vcg_imp_lift' simp: tcb_at_kh_simps)
  apply (wps)
  apply (wpsimp wp: awaken_in_release_q)
  apply (wpsimp)
  apply (auto simp: tcb_at_kh_simps vs_all_heap_simps pred_neg_def)
  done

crunches awaken
  for machine_times[wp]: "\<lambda>s. P (last_machine_time_of s) (cur_time s)"
  (wp: crunch_wps)

lemma schedule_valid_sched:
  "\<lbrace> valid_sched
     and invs
     and current_time_bounded
     and consumed_time_bounded
     and scheduler_act_sane
     and cur_sc_in_release_q_imp_zero_consumed
     and cur_sc_more_than_ready
     and ct_ready_if_schedulable\<rbrace>
   schedule
  \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding schedule_def
  apply (wpsimp wp: schedule_valid_sched_helper)
   apply (wpsimp wp: awaken_valid_sched)
  by (clarsimp simp: valid_sched_def)

crunches cancel_ipc
for not_cur_thread[wp]: "not_cur_thread thread"
  (wp: hoare_drop_imps select_wp mapM_x_wp simp: unless_def if_fun_split)

lemma cancel_ipc_sc_tcb_sc_at_eq[wp]:
  "cancel_ipc thread \<lbrace>sc_tcb_sc_at ((=) tcb_opt) x\<rbrace>"
  unfolding cancel_ipc_def
  by (wpsimp simp: blocked_cancel_ipc_def get_blocking_object_def
                   reply_remove_tcb_def cancel_signal_def
               wp: get_simple_ko_wp get_ep_queue_wp hoare_vcg_all_lift hoare_drop_imps
                   update_sched_context_sc_tcb_sc_at)

crunches blocked_cancel_ipc, cancel_signal, test_reschedule
  for bound_sc_tcb_at'[wp]: "\<lambda>s. Q (bound_sc_tcb_at P t s)"
  (wp: crunch_wps)

lemma cancel_ipc_bound_sc_tcb_at[wp]:
  "cancel_ipc tptr \<lbrace>\<lambda>s. Q (bound_sc_tcb_at P t s)\<rbrace>"
  unfolding cancel_ipc_def
  apply (wpsimp simp: reply_remove_tcb_def
                  wp: gts_wp thread_set_wp get_sk_obj_ref_wp)
  apply (clarsimp dest!: get_tcb_SomeD
                   simp: pred_tcb_at_def obj_at_def)
  done

crunches cancel_ipc
  for current_time_bounded[wp]: current_time_bounded

crunches cancel_ipc
  for heap_refs_retract_tcb_scps[wp]: "\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)"
  (wp: crunch_wps ignore: thread_set)

lemma restart_valid_sched:
  "\<lbrace>valid_sched
    and (\<lambda>s. thread \<noteq> idle_thread s)
    and valid_objs
    and scheduler_act_not thread
    and (\<lambda>s. sym_refs (state_refs_of s))
    and current_time_bounded\<rbrace>
   restart thread
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  unfolding restart_def if_cond_refill_unblock_check_def
  supply refill_unblock_check_valid_sched_except_blocked[wp]
  apply (wpsimp wp: test_possible_switch_to_valid_sched wp_del: maybeM_wp)
        apply (rule_tac Q="\<lambda>r s. valid_sched_except_blocked s
                                 \<and> valid_blocked_except_set {thread} s
                                 \<and> thread \<noteq> idle_thread s
                                 \<and> (schedulable thread s \<longrightarrow> budget_ready thread s)"
                        in hoare_strengthen_post[rotated])
         apply (clarsimp simp: valid_sched_valid_sched_except_blocked obj_at_kh_kheap_simps schedulable_def2
                        split: if_splits)
         apply (fastforce simp: valid_sched_def runnable_eq_active
                         elim!: valid_blockedE'
                                valid_refills_budget_sufficient[OF active_sc_valid_refills_tcb_at])

        apply (wpsimp wp: sched_context_resume_valid_sched_except_blocked
                          sched_context_resume_valid_blocked_except_set
                          sched_context_resume_schedulable_imp_ready)
       apply (rule_tac Q="\<lambda>r. (valid_sched_except_blocked and
                              valid_blocked_except_set {thread}) and
                              scheduler_act_not thread and
                              not_queued thread and not_in_release_q thread and
                              (\<lambda>s. thread \<noteq> idle_thread s) and
                              (\<lambda>s. \<forall>sc_ptr. sc_opt = (Some sc_ptr)
                                            \<longrightarrow> sc_tcb_sc_at ((=) (Some thread)) sc_ptr s
                                                \<and> sc_not_in_release_q sc_ptr s) and
                              bound_sc_tcb_at (\<lambda>a. a = sc_opt) thread"
                       in hoare_strengthen_post[rotated])
        apply (rule conjI)
         apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps heap_refs_retract_at_def valid_sched_def)
        apply (fastforce dest!: no_bound_sc_not_schedulable simp: op_equal)
       apply wpsimp
      apply (rule_tac Q="\<lambda>r. (valid_sched_except_blocked and
                             valid_blocked_except_set {thread}) and
                             scheduler_act_not thread and
                             not_queued thread and
                             not_in_release_q thread and
                             (\<lambda>s. thread \<noteq> idle_thread s) and
                             (\<lambda>s. \<forall>sc_ptr. sc_opt = (Some sc_ptr)
                                           \<longrightarrow> sc_tcb_sc_at ((=) (Some thread)) sc_ptr s) and
                             bound_sc_tcb_at (\<lambda>a. a = sc_opt) thread and
                             current_time_bounded
                             and (\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s))"
                      in hoare_strengthen_post[rotated])
       apply clarsimp
       apply (intro conjI impI allI; clarsimp; drule (1) heap_refs_retractD;
              clarsimp simp: sc_at_kh_simps pred_map_simps)
      apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift set_thread_state_break_valid_sched)
     apply clarsimp
     apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift cancel_ipc_valid_sched)
    apply (wpsimp simp: get_tcb_obj_ref_def  wp: thread_get_wp )
   apply (wpsimp wp: gts_wp )
  apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  apply (rule_tac x=tcb in exI; clarsimp)
  apply (subgoal_tac "\<not>pred_map runnable (tcb_sts_of s) thread")
   apply (intro conjI; clarsimp)
     apply (subgoal_tac "st_tcb_at runnable thread s")
      apply (clarsimp simp: pred_tcb_at_def obj_at_def)
     apply (drule valid_ready_qs_in_ready_qD[rotated], simp add: valid_sched_def)
     apply (clarsimp simp: valid_sched_def valid_sched_action_def is_activatable_def
                           pred_tcb_at_def obj_at_def)
    apply (clarsimp simp: valid_release_q_def valid_sched_def in_release_q_def)
   apply (subst sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[where t=thread, symmetric];
          simp?;
          fastforce simp: pred_tcb_at_def obj_at_def)
  apply (clarsimp simp: vs_all_heap_simps)
  done

end

lemma bind_notification_valid_sched[wp]:
  "\<lbrace>valid_sched\<rbrace> bind_notification param_a param_b \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (clarsimp simp: bind_notification_def update_sk_obj_ref_def)
  apply (wpsimp simp: set_object_def set_simple_ko_def
          wp: get_simple_ko_wp hoare_drop_imp)
  done

lemma suspend_it_det_ext[wp]:
  "\<lbrace>\<lambda>s. P (idle_thread s)\<rbrace> suspend param_a \<lbrace>\<lambda>_ s. P (idle_thread s)\<rbrace>"
  by (wpsimp simp: suspend_def sched_context_cancel_yield_to_def wp: hoare_drop_imps)

crunches suspend
  for cur_time[wp]: "\<lambda>s. P (cur_time s)"
  (wp: crunch_wps)

context DetSchedSchedule_AI_det_ext begin

lemma invoke_tcb_valid_sched:
  "\<lbrace>invs
    and valid_sched and valid_machine_time  and ct_active and ct_released and ct_not_in_release_q
    and simple_sched_action and current_time_bounded
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s)
    and tcb_inv_wf ti\<rbrace>
     invoke_tcb ti
   \<lbrace>\<lambda>rv. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (cases ti, simp_all only:)
         \<comment> \<open>WriteRegisters\<close>
         apply (wpsimp wp: restart_valid_sched reschedule_valid_sched_const hoare_vcg_if_lift2
                           hoare_vcg_imp_lift' arch_post_modify_registers.valid_sched_pred)
               apply (rule_tac Q="\<lambda>rv s. invs s \<and> simple_sched_action s \<and> current_time_bounded s"
                      in hoare_strengthen_post[rotated], fastforce)
               apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' )+
              apply (rule_tac Q="\<lambda>rv s. invs s \<and> simple_sched_action s \<and> current_time_bounded s"
                     in hoare_strengthen_post[rotated], fastforce)
              apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' )+
         apply (subgoal_tac "x11 \<noteq> idle_thread s", clarsimp)
          apply (clarsimp simp: invs_valid_objs invs_valid_global_refs idle_no_ex_cap)
         \<comment> \<open>ReadRegisters\<close>
         apply (wpsimp wp: suspend_valid_sched;
               clarsimp simp: invs_valid_objs invs_valid_global_refs split: if_splits)
         \<comment> \<open>CopyRegisters\<close>
       apply (wpsimp wp: reschedule_valid_sched_const mapM_x_wp, assumption)
          apply (wpsimp wp: mapM_x_wp, assumption)
         apply (wpsimp wp: restart_valid_sched hoare_vcg_if_lift2 hoare_vcg_imp_lift')
        apply (wpsimp wp: suspend_valid_sched hoare_vcg_if_lift2 hoare_vcg_imp_lift')
          apply (rule_tac Q="\<lambda>rv s. invs s \<and> simple_sched_action s \<and> current_time_bounded s"
                 in hoare_strengthen_post[rotated], fastforce)
          apply (wpsimp wp: suspend_invs suspend_valid_sched hoare_vcg_if_lift2 hoare_vcg_imp_lift')+
          apply (rule_tac Q="\<lambda>rv s. invs s \<and> simple_sched_action s \<and> current_time_bounded s"
                 in hoare_strengthen_post[rotated], fastforce)
          apply (wpsimp wp: suspend_invs suspend_valid_sched hoare_vcg_if_lift2 hoare_vcg_imp_lift')+
         apply (rule_tac Q="\<lambda>rv s. invs s \<and> simple_sched_action s \<and> current_time_bounded s"
                in hoare_strengthen_post[rotated], fastforce)
         apply (wpsimp wp: suspend_invs suspend_valid_sched hoare_vcg_if_lift2 hoare_vcg_imp_lift')+
       apply (subgoal_tac "x31 \<noteq> idle_thread s \<and> x32 \<noteq> idle_thread s")
        apply (clarsimp simp: invs_def valid_pspace_def valid_state_def valid_idle_def split: if_splits)
        apply (fastforce simp: invs_def valid_state_def valid_idle_def dest!: idle_no_ex_cap)
         \<comment> \<open>ThreadControl\<close>
       apply (wp tcc_valid_sched)
       apply (rename_tac sc_opt_opt s, case_tac sc_opt_opt; simp)
      apply (wp tcs_valid_sched)
      apply (rename_tac sc_opt_opt s, case_tac sc_opt_opt; simp)
     apply (rename_tac sc_opt, case_tac sc_opt; simp)
        \<comment> \<open>Suspend\<close>
     apply (wpsimp wp: suspend_valid_sched ;
            clarsimp simp: invs_valid_objs invs_valid_global_refs)
         \<comment> \<open>Resume\<close>
    apply (wpsimp wp: mapM_x_wp suspend_valid_sched restart_valid_sched;
           intro conjI;
           clarsimp simp: invs_valid_objs invs_valid_global_refs idle_no_ex_cap)
         \<comment> \<open>NotificationControl\<close>
   apply (rename_tac option, case_tac option; wpsimp)
         \<comment> \<open>SetTLSBase\<close>
  apply (wpsimp wp: reschedule_valid_sched_const)
  done

end

crunch exst[wp]: set_mrs, as_user "\<lambda>s. P (exst s)"
  (simp: crunch_simps wp: crunch_wps)

lemmas gts_drop_imp = hoare_drop_imp[where f="get_thread_state p" for p]

crunch (in DetSchedSchedule_AI) not_cur_thread[wp] : do_ipc_transfer "not_cur_thread t:: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps ignore: const_on_failure)

lemma postpone_ct_not_in_q[wp]:
  "postpone sc_ptr \<lbrace>ct_not_in_q\<rbrace>"
  unfolding postpone_def
  by (wpsimp wp: get_sc_obj_ref_wp tcb_sched_dequeue_ct_not_in_q)

lemma sched_context_resume_ct_not_in_q[wp]:
  "\<lbrace> ct_not_in_q \<rbrace>
   sched_context_resume sc_ptr
   \<lbrace> \<lambda>_. ct_not_in_q\<rbrace>"
  unfolding sched_context_resume_def
  apply (wpsimp wp: thread_get_wp is_schedulable_wp)
  by (fastforce simp: obj_at_def schedulable_def is_tcb
               split: option.splits dest!: get_tcb_SomeD)

lemma maybe_donate_sc_ct_not_in_q[wp]:
  "maybe_donate_sc tcb_ptr ntfnptr \<lbrace>ct_not_in_q\<rbrace>"
  unfolding maybe_donate_sc_def
  by (wpsimp wp: get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)

crunches sched_context_donate, sched_context_resume, cancel_ipc
  for vmt[wp]: "(\<lambda>s. P (machine_state s) (cur_time s))"
  (wp: crunch_wps)

lemma maybe_donate_sc_valid_ready_qs:
  "\<lbrace>valid_ready_qs and scheduler_act_not tcb_ptr\<rbrace>
   maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext[OF _ gsc_ntfn_sp])
  apply (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  by (wpsimp wp: get_sc_obj_ref_wp hoare_drop_imp)

lemma maybe_donate_sc_released_ipc_queues:
  "\<lbrace> released_ipc_queues
     and (\<lambda>s. \<forall>scp. ntfn_at_ppred ntfn_sc ((=) (Some scp)) ntfnptr s
                 \<longrightarrow> sched_context_donate_ipc_queues_precond tcb_ptr scp s)\<rbrace>
   maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  supply if_split[split del]
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases; clarsimp)
  apply (rule hoare_seq_ext[OF _ gsc_ntfn_sp])
  apply (wpsimp wp: sched_context_donate_released_sc_released_ipc_queues
                     hoare_vcg_if_lift2 maybeM_wp hoare_drop_imp
              simp: get_sc_obj_ref_def obj_at_def)
  apply (subgoal_tac "ntfn_at_ppred ntfn_sc ((=) (Some xa)) ntfnptr s", fastforce)
  apply (clarsimp simp: sk_obj_at_pred_def obj_at_def)
  done

lemma maybe_donate_sc_released_ipc_queues':
  "\<lbrace>\<lambda>s. released_ipc_queues s
        \<and> \<not>ipc_queued_thread tcbptr s\<rbrace>
     maybe_donate_sc tcbptr ntfnptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  by (wpsimp wp: maybe_donate_sc_released_ipc_queues simp: pred_map_ipc_queued_thread_state_iff)

(* FIXME: replace this lemma with its definition *)
lemmas refill_unblock_check_ko_at_SchedContext = refill_unblock_check_sc_tcb_sc_at

lemma sched_context_donate_not_in_release_q[wp]:
  "\<lbrace>not_in_release_q t\<rbrace>
   sched_context_donate scp tcb_ptr
   \<lbrace>\<lambda>y s. not_in_release_q t s\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp simp: set_tcb_obj_ref_def
                  wp: set_object_wp update_sched_context_wp hoare_drop_imp
                      tcb_release_remove_not_in_release_q get_sc_obj_ref_wp)

(* FIXME RT: rename and split *)
lemma sched_context_donate_wp:
  "\<lbrace>\<top>\<rbrace>
   sched_context_donate scp tcb_ptr
   \<lbrace>\<lambda>y. sc_tcb_sc_at ((=) (Some tcb_ptr)) scp and bound_sc_tcb_at ((=) (Some scp)) tcb_ptr\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: ssc_bound_tcb_at' sc_tcb_update_sc_tcb_sc_at)

\<comment> \<open>lemma tcb_release_remove_sc_not_in_release_q_inv:
  "tcb_release_remove tptr \<lbrace>sc_not_in_release_q sc_ptr\<rbrace>"
  apply (wpsimp simp: tcb_release_remove_def)
  by (clarsimp simp: pred_tcb_at_def obj_at_def tcb_sched_dequeue_def not_in_release_q_def
                     in_queue_2_def)\<close>

lemma tcb_release_remove_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q sc_ptr s
        \<or> (heap_ref_eq sc_ptr tptr (tcb_scps_of s) \<and> heap_refs_inj (tcb_scps_of s))\<rbrace>
   tcb_release_remove tptr
   \<lbrace>\<lambda>_. sc_not_in_release_q sc_ptr\<rbrace>"
  apply (clarsimp simp: tcb_release_remove_def)
  apply wpsimp
  apply (fastforce simp: tcb_sched_dequeue_def in_queue_2_def heap_refs_inj_eq pred_tcb_at_def
                         obj_at_def not_in_release_q_def)
  done


lemma sched_context_donate_sc_not_in_release_q:
  "\<lbrace>sc_not_in_release_q sc_ptr and not_in_release_q tptr\<rbrace>
   sched_context_donate scp tptr
   \<lbrace>\<lambda>_. sc_not_in_release_q sc_ptr\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def)
  by (wpsimp wp: get_sc_obj_ref_wp hoare_vcg_imp_lift' tcb_release_remove_sc_not_in_release_q)

lemma maybe_donate_sc_valid_release_q:
  "\<lbrace> valid_release_q and not_in_release_q tcb_ptr\<rbrace>
     maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace> \<lambda>_. valid_release_q \<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac sc_opt; clarsimp)
   apply (rule hoare_seq_ext[OF _ gsc_ntfn_sp])
   apply (clarsimp simp: maybeM_def)
   apply (rename_tac scp; case_tac scp; clarsimp)
    apply wpsimp
   apply (rule hoare_seq_ext[OF _ gsct_sp])
   apply (rename_tac sctcb; case_tac sctcb; clarsimp)
    apply (wpsimp wp: sched_context_resume_valid_release_q refill_unblock_check_valid_release_q
                      sched_context_donate_valid_release_q hoare_drop_imp
                      sched_context_donate_sc_not_in_release_q)
  by (wpsimp wp: sched_context_donate_valid_release_q)+

lemma maybe_donate_sc_valid_sched_action_helper:
  "\<lbrace>scheduler_act_not tcb_ptr and sc_tcb_sc_at ((=) None) scp\<rbrace>
   sched_context_donate scp tcb_ptr
   \<lbrace>\<lambda>rv s. \<forall>x. sc_tcb_sc_at ((=) (Some x)) scp s \<longrightarrow> scheduler_act_not x s\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp simp: set_tcb_obj_ref_def
                  wp: set_object_wp update_sched_context_wp)
        apply (rule hoare_pre_cont)
       apply (wpsimp)+
   apply (wpsimp simp: get_sc_obj_ref_def)
  apply (clarsimp simp: obj_at_def sc_at_pred_n_def)
  done

lemma maybe_donate_sc_valid_sched_action:
  "\<lbrace> valid_sched_action and scheduler_act_not tcb_ptr\<rbrace>
     maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace> \<lambda>_. valid_sched_action \<rbrace>"
  unfolding maybe_donate_sc_def
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac sc_opt; clarsimp)
   apply (rule hoare_seq_ext[OF _ gsc_ntfn_sp])
   apply (wpsimp wp: sched_context_resume_valid_sched_action)
     apply (rule_tac Q="\<lambda>_ s. valid_sched_action s \<and>
                              (\<forall>x. sc_tcb_sc_at ((=) (Some x)) xa s \<longrightarrow>
                                   scheduler_act_not x s)"
               in hoare_strengthen_post[rotated])
      apply clarsimp
     apply (wpsimp wp: sched_context_donate_valid_sched_action
                       maybe_donate_sc_valid_sched_action_helper)
    apply (wpsimp wp: get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)
   apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  apply wpsimp
  done

lemma maybe_donate_sc_ct_in_cur_domain:
  "\<lbrace> ct_in_cur_domain \<rbrace>
     maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace> \<lambda>_. ct_in_cur_domain \<rbrace>"
  unfolding maybe_donate_sc_def
  by (wpsimp wp: get_sk_obj_ref_wp get_tcb_obj_ref_wp)

lemma not_queued_refill_unblock_check:
  "\<lbrace>\<lambda>s. \<forall>t. sc_tcb_sc_at (\<lambda>p. p = Some t) sc_ptr s \<longrightarrow> not_queued t s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>rv s. \<forall>t. sc_tcb_sc_at (\<lambda>p. p = Some t) sc_ptr s \<longrightarrow> not_queued t s\<rbrace>"
  apply (clarsimp simp: refill_unblock_check_def update_refill_hd_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: get_refills_wp hoare_vcg_all_lift hoare_vcg_imp_lift')
  apply refill_head_overlapping_loop_simple
   apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  apply simp
  done

lemma sched_context_donate_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set {tcb_ptr} and sc_tcb_sc_at ((=) None) sc_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>y. valid_blocked_except_set {tcb_ptr}\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp simp: set_tcb_obj_ref_def
                  wp: set_object_wp update_sched_context_wp)
        apply (rule hoare_pre_cont)
       apply (wpsimp)+
   apply (wpsimp simp: get_sc_obj_ref_def)
  apply (clarsimp simp: obj_at_def sc_at_pred_n_def)
  apply (safe)
   apply clarsimp
  apply (clarsimp simp: valid_blocked_except_set_2_def valid_blocked_thread_def
                 dest!: get_tcb_SomeD split: if_splits)
  apply (drule_tac x=t in spec)
  by (clarsimp simp: vs_all_heap_simps)

lemma not_queued_sched_context_donate:
  "\<lbrace>not_queued tcb_ptr and scheduler_act_not tcb_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>rv s. \<forall>t. sc_tcb_sc_at (\<lambda>p. p = Some t) sc_ptr s \<longrightarrow> not_queued t s\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def)
  apply (wpsimp wp: get_sched_context_wp hoare_vcg_all_lift set_object_wp get_object_wp)
      apply (wpsimp simp: set_tcb_obj_ref_def wp: set_object_wp)
     apply (wpsimp wp: update_sched_context_wp)
    apply (rule_tac Q="\<lambda>r. not_queued tcb_ptr" in hoare_strengthen_post)
     prefer 2
     apply (clarsimp simp: not_queued_def sc_tcb_sc_at_def obj_at_def dest!: get_tcb_SomeD)
    apply (wpsimp wp: tcb_dequeue_not_queued simp: get_sc_obj_ref_def)+
  done

lemma maybe_donate_sc_valid_blocked_except_set:
  "\<lbrace> valid_blocked_except_set {tcb_ptr} and not_queued tcb_ptr and scheduler_act_not tcb_ptr\<rbrace>
      maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace> \<lambda>_. valid_blocked_except_set {tcb_ptr} \<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (wpsimp wp: sched_context_resume_valid_blocked_except_set
                    refill_unblock_check_valid_blocked_except_set
                    not_queued_refill_unblock_check not_queued_sched_context_donate
                    sched_context_donate_valid_blocked_except_set
                    get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  done

crunches maybe_donate_sc
for not_cur_thread[wp]: "not_cur_thread t"
and etcbs[wp]: "\<lambda>s. P (etcbs_of s)"
  (wp: hoare_drop_imp crunch_wps ignore: set_tcb_obj_ref simp: crunch_simps)

crunch valid_sched[wp]: dec_domain_time valid_sched

lemmas bound_sc_tcb_at_def = pred_tcb_at_def

lemma tcb_sched_enqueue_queued[wp]:
  "\<lbrace>\<top>\<rbrace> tcb_sched_action tcb_sched_enqueue tcb_ptr \<lbrace>\<lambda>rv s. (\<not> not_queued tcb_ptr s)\<rbrace>"
  unfolding tcb_sched_action_def tcb_sched_enqueue_def
  apply (wpsimp wp: set_tcb_queue_wp simp: thread_get_def)
  apply (fastforce simp: not_queued_def obj_at_def in_queues_2_def dest!: get_tcb_SomeD)
  done

lemma restart_thread_if_no_fault_ipc_queued_thread_neq:
  "\<lbrace>\<lambda>s. pred_map P (tcb_sts_of s) t' \<and> t' \<noteq> t\<rbrace>
   restart_thread_if_no_fault t
   \<lbrace>\<lambda>_ s. pred_map P (tcb_sts_of s) t'\<rbrace>"
  unfolding restart_thread_if_no_fault_def
  by (wpsimp wp: set_thread_state_pred_map_tcb_sts_of thread_get_wp')

lemma cancel_badged_sends_filterM_valid_sched:
   "\<lbrace>(\<lambda>s. \<forall>t\<in>set xs. blocked_on_send_tcb_at t s \<and> t \<noteq> idle_thread s)
     and (valid_sched and current_time_bounded
     and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))) and K (distinct xs)\<rbrace>
    filterM (\<lambda>t. do st \<leftarrow> get_thread_state t;
                    if blocking_ipc_badge st = badge
                    then do _ \<leftarrow> restart_thread_if_no_fault t;
                            return False
                    od
                    else return True
                 od) xs
    \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  apply (rule hoare_gen_asm)
  apply (rule hoare_strengthen_post)
   apply (rule ball_filterM_scheme[rotated 2], simp)
    apply (wpsimp wp: restart_thread_if_no_fault_ipc_queued_thread_neq hoare_drop_imp)
   apply (wpsimp wp: restart_thread_if_no_fault_valid_sched hoare_drop_imp)
   apply (intro conjI)
    apply (clarsimp simp: pred_map_simps is_blocked_thread_state_defs)
   apply (frule valid_sched_released_ipc_queues, clarsimp simp: released_ipc_queues_defs)
   apply (drule_tac x=t in spec)
   apply (clarsimp simp: vs_all_heap_simps is_timeout_fault_opt_def)
  apply simp
  done

lemma cancel_badged_sends_valid_sched:
  "\<lbrace>valid_objs and valid_sched and simple_sched_action and current_time_bounded
    and (\<lambda>s. sym_refs (state_refs_of s)) and valid_idle\<rbrace>
   cancel_badged_sends epptr badge
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  apply (simp add: cancel_badged_sends_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (case_tac ep; clarsimp;
          wpsimp wp: cancel_badged_sends_filterM_valid_sched hoare_vcg_ball_lift
                     reschedule_valid_sched_const)
  apply (intro conjI, intro ballI)
   apply (subgoal_tac "st_tcb_at (\<lambda>st. \<exists>payl. st = (BlockedOnSend epptr payl)) x s")
    apply (intro conjI)
     apply (clarsimp simp: tcb_at_kh_simps pred_map_def)
    apply (clarsimp, drule (1) st_tcb_at_idle_thread, simp)
   apply (subgoal_tac "tcb_at x s")
    apply (subgoal_tac "(epptr, TCBBlockedSend) \<in> state_refs_of s x")
     apply (clarsimp simp: state_refs_of_def refs_of_def tcb_at_def is_tcb get_refs_def
                           tcb_st_refs_of_def pred_tcb_at_def obj_at_def
                    dest!: get_tcb_SomeD split: option.splits thread_state.splits if_splits)
    apply (erule sym_refsE, clarsimp)
    apply (clarsimp simp: obj_at_def state_refs_of_def refs_of_def split: option.splits)
   apply (fastforce elim: ep_list_tcb_at')
  apply (fastforce elim: valid_objs_SendEP_distinct simp: obj_at_def)
  done

context DetSchedSchedule_AI_det_ext begin

lemma cap_revoke_valid_sched[wp]:
  "\<lbrace>valid_sched and valid_machine_time and simple_sched_action and invs and current_time_bounded\<rbrace>
   cap_revoke slot
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_strengthen_post)
   apply (rule validE_valid, rule cap_revoke_preservation)
    apply (wpsimp | wpsimp wp: preemption_point_inv')+
  done

lemma cap_revoke_simple_sched_action[wp]:
  "\<lbrace>simple_sched_action\<rbrace> cap_revoke slot \<lbrace>\<lambda>rv. simple_sched_action :: det_state \<Rightarrow> _\<rbrace>"
  by (wp cap_revoke_preservation preemption_point_inv' | fastforce)+

end

lemma thread_set_state_eq_ct_in_cur_domain:
  "\<lbrakk> \<And>x. tcb_state (f x) = ts; \<And>x. etcb_of (f x) = etcb_of x \<rbrakk> \<Longrightarrow>
   \<lbrace>ct_in_cur_domain and st_tcb_at ((=) ts) tptr\<rbrace> thread_set f tptr \<lbrace>\<lambda>rv. ct_in_cur_domain\<rbrace>"
  apply (simp add: thread_set_def)
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: etcbs_of_update_unrelated dest!: get_tcb_SomeD)
  done

crunch exst[wp]: thread_set "\<lambda>s. P (exst s)"

lemma thread_set_not_idle_valid_idle:
  "\<lbrace>valid_idle and (\<lambda>s. tptr \<noteq> idle_thread s)\<rbrace>
     thread_set f tptr \<lbrace>\<lambda>_. valid_idle\<rbrace>"
  apply (simp add: thread_set_def, wp set_object_wp)
  apply (clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def get_tcb_def)
  done

crunch valid_sched[wp]: cap_move "valid_sched_pred_strong P"

context DetSchedSchedule_AI_det_ext begin

lemma invoke_cnode_valid_sched:
  "\<lbrace>valid_sched and valid_machine_time and invs and valid_cnode_inv a and simple_sched_action
    and current_time_bounded\<rbrace>
   invoke_cnode a
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: invoke_cnode_def)
  apply (rule hoare_pre)
   apply wpc
        apply (simp add: liftE_def
               | (wp cancel_badged_sends_valid_sched hoare_vcg_all_lift)+
               | wp (once) hoare_drop_imps
               | wpc)+
  apply (fastforce elim: valid_objs_SendEP_distinct dest: invs_valid_objs)
  done


end

lemma possible_switch_to_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t and K(target \<noteq> t)\<rbrace>
     possible_switch_to target
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (clarsimp simp: possible_switch_to_def)
  by (wpsimp simp: set_scheduler_action_def get_tcb_obj_ref_def thread_get_def
               wp: tcb_sched_enqueue_not_queued reschedule_required_not_queued hoare_vcg_if_lift2
        split_del: if_split)

lemma reply_push_scheduler_act_not[wp]:
  "\<lbrace>scheduler_act_not t\<rbrace>
     reply_push caller callee reply_ptr can_donate \<lbrace>\<lambda>rv. scheduler_act_not t\<rbrace>"
  apply (clarsimp simp: reply_push_def bind_sc_reply_def)
  by (wpsimp wp: hoare_drop_imp get_sched_context_wp hoare_vcg_if_lift2 hoare_vcg_all_lift
             split_del: if_split)

lemma reply_push_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace>
     reply_push caller callee reply_ptr can_donate \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  apply (clarsimp simp: reply_push_def bind_sc_reply_def)
  by (wpsimp wp: hoare_drop_imp get_sched_context_wp hoare_vcg_if_lift2 hoare_vcg_all_lift
             split_del: if_split)

lemma sched_context_donate_tcb_scps_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s) \<and> pred_map_eq None (tcb_scps_of s) t\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>"
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred update_sc_tcb_valid_sched_pred get_sc_obj_ref_wp
              simp: sched_context_donate_def obj_at_def heap_upd_def)
  by (auto simp: vs_all_heap_simps pred_map_simps elim!: heap_refs_retractE split: if_splits)

lemma reply_remove_tcb_scps_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   reply_remove caller reply
   \<lbrace>\<lambda>rv s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>"
  unfolding reply_remove_def
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, (simp only: K_bind_def)?)+
  apply (rule hoare_seq_ext_skip[rotated], wpsimp)
  apply (case_tac r_sc_opt, wpsimp, simp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext_skip, wpsimp)
  by (wpsimp wp: sched_context_donate_tcb_scps_of_retract)

lemma reply_push_tcb_scps_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  apply (wpsimp wp: hoare_vcg_if_lift2 sts_st_tcb_at_cases hoare_vcg_all_lift get_simple_ko_wp
                    sched_context_donate_tcb_scps_of_retract)
  apply (rule_tac Q= "\<lambda>_ s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s) \<and>
                   bound_sc_tcb_at ((=) sc_callee) callee s" in hoare_strengthen_post[rotated])
  apply (clarsimp simp: tcb_at_kh_simps obj_at_def pred_neg_def vs_all_heap_simps)
  apply (wpsimp wp: hoare_vcg_if_lift2 sts_st_tcb_at_cases hoare_vcg_all_lift get_simple_ko_wp hoare_drop_imp)+
  apply (wpsimp wp: get_tcb_obj_ref_wp)+
  apply (clarsimp simp: tcb_at_kh_simps obj_at_def vs_all_heap_simps)
  done

lemma sched_context_donate_sc_tcbs_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
        \<and> pred_map_eq None (tcb_scps_of s) t\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>rv s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred update_sc_tcb_valid_sched_pred
                    get_sc_obj_ref_wp)
  apply (clarsimp simp: sched_context_donate_def obj_at_def heap_upd_def)
  apply (intro conjI impI
         ; (rule heap_refs_retractE, assumption)
         ; clarsimp simp: vs_all_heap_simps pred_map_simps)
  apply (rename_tac sc scp' tcb t' n sc' tcb' n')
  apply (drule_tac p=scp and r=t' in heap_refs_retractD; clarsimp simp: vs_all_heap_simps)
  done

lemma reply_remove_sc_tcbs_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   reply_remove caller reply
   \<lbrace>\<lambda>rv s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding reply_remove_def
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, (simp only: K_bind_def)?)+
  apply (rule hoare_seq_ext_skip[rotated], wpsimp)
  apply (case_tac r_sc_opt, wpsimp, simp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext_skip, wpsimp)
  by (wpsimp wp: sched_context_donate_sc_tcbs_of_retract)

lemma reply_push_sc_tcbs_of_retract[wp]:
  "\<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  apply (wpsimp wp: hoare_vcg_if_lift2 sts_st_tcb_at_cases hoare_vcg_all_lift get_simple_ko_wp)
  apply (rule_tac Q= "\<lambda>_ s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s) \<and>
                   bound_sc_tcb_at ((=) sc_callee) callee s" in hoare_strengthen_post[rotated])
  apply (clarsimp simp: tcb_at_kh_simps obj_at_def pred_neg_def vs_all_heap_simps)
  apply (wpsimp wp: hoare_vcg_if_lift2 sts_st_tcb_at_cases hoare_vcg_all_lift get_simple_ko_wp hoare_drop_imp)+
  apply (wpsimp wp: get_tcb_obj_ref_wp)+
  apply (clarsimp simp: tcb_at_kh_simps obj_at_def vs_all_heap_simps)
  done

lemma
  shows sched_context_donate_heap_refs_inv_tcb_scps[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<and> pred_map_eq None (tcb_scps_of s) tptr\<rbrace>
   sched_context_donate scp tptr
   \<lbrace>\<lambda>_ s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<rbrace>"
  and sched_context_donate_heap_refs_inv_sc_tcbs[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s) \<and> pred_map_eq None (tcb_scps_of s) tptr\<rbrace>
   sched_context_donate scp tptr
   \<lbrace>\<lambda>_ s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  and reply_push_heap_refs_inv_tcb_scps[wp]:
  "reply_push caller callee reply_ptr can_donate \<lbrace>\<lambda> s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<rbrace>"
  and reply_push_heap_refs_inv_sc_tcbs[wp]:
  "reply_push caller callee reply_ptr can_donate \<lbrace>\<lambda> s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  and reply_remove_heap_refs_inv_tcb_scps[wp]:
  "reply_remove caller reply \<lbrace>\<lambda> s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<rbrace>"
  and reply_remove_heap_refs_inv_sc_tcbs[wp]:
  "reply_remove caller reply \<lbrace>\<lambda> s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  by (wpsimp simp: heap_refs_inv_def pred_map_eq tcb_at_kh_simps pred_map_simps)+

lemma update_sk_obj_ref_sc_tcb_sc_at[wp]:
  "\<lbrace>sc_tcb_sc_at P scp\<rbrace> update_sk_obj_ref C f ref new \<lbrace>\<lambda>_. sc_tcb_sc_at P scp\<rbrace>"
  apply (wpsimp simp: update_sk_obj_ref_def set_simple_ko_def set_object_def
                wp: get_object_wp get_simple_ko_wp)
  apply (clarsimp simp: partial_inv_def sc_tcb_sc_at_def obj_at_def)
  by (case_tac "C obj"; clarsimp simp: a_type_def)

lemma sts_obj_at_neq:
  "\<lbrace>obj_at P t and K (t\<noteq>t')\<rbrace> set_thread_state t' st \<lbrace>\<lambda>_. obj_at P t\<rbrace>"
  unfolding set_thread_state_def
  by (wpsimp wp: set_object_wp)
     (clarsimp dest!: get_tcb_SomeD simp: pred_tcb_at_def obj_at_def)

lemma set_tcb_sched_context_Some_bound_sc_obj_tcb_at:
  "\<lbrace>\<lambda>s. if t' = t
        then N (pred_map (P (cur_time s)) (sc_refill_cfgs_of s) scp)
        else N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update t (Some scp)
   \<lbrace>\<lambda>_ s. N (bound_sc_obj_tcb_at (P (cur_time s)) t' s)\<rbrace>"
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps
          elim!: rsubst[of N] cong: conj_cong)

lemma sched_context_donate_bound_sc_obj_tcb_at:
  "\<lbrace>\<lambda>s. N (pred_map (P (cur_time s)) (sc_refill_cfgs_of s) scp)\<rbrace>
   sched_context_donate scp t
   \<lbrace>\<lambda>_ s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  by (wpsimp wp: set_tcb_sched_context_Some_bound_sc_obj_tcb_at
           simp: sched_context_donate_def)

crunches reply_push
  for ct_not_in_q[wp]: "ct_not_in_q"
  and ct_in_cur_domain[wp]: "ct_in_cur_domain"
  and not_cur_thread[wp]: "not_cur_thread t"
  (wp: crunch_wps hoare_vcg_if_lift ignore: set_thread_state test_reschedule)

lemmas set_thread_state_ipc_queued_valid_blocked_except_set
  = set_thread_state_valid_blocked[where ts="BlockedOnReceive ep r_opt pl" for ep r_opt pl, simplified]
    set_thread_state_valid_blocked[where ts="BlockedOnSend ep data" for ep data, simplified]
    set_thread_state_valid_blocked[where ts="BlockedOnNotification ntfn" for ntfn, simplified]
    set_thread_state_valid_blocked[where ts="BlockedOnReply r" for r, simplified]

lemma set_sc_replies_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> (replies \<noteq> [] \<longrightarrow> pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>
   set_sc_obj_ref sc_replies_update scp replies
   \<lbrace>\<lambda>rv. active_reply_scs\<rbrace>"
  apply (wpsimp wp: update_sched_context_valid_sched_pred)
  by (auto simp: heap_upd_def vs_all_heap_simps split: if_splits elim!: active_reply_scsE)

lemma set_sc_replies_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> (replies \<noteq> [] \<longrightarrow> pred_map active_scrc (sc_refill_cfgs_of s) scp)\<rbrace>
   set_sc_obj_ref sc_replies_update scp replies
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp wp: set_sc_replies_active_reply_scs simp: valid_sched_def)

method reply_push_begin_valid_sched_proof
  = (simp add: reply_push_def bind_sc_reply_def
     , intro hoare_seq_ext[OF _ gsc_sp]
     , simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)

lemma reply_push_valid_ready_qs[wp]:
  "\<lbrace>valid_ready_qs and valid_sched_action and not_queued caller and scheduler_act_not caller\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  apply reply_push_begin_valid_sched_proof
  apply (intro hoare_seq_ext_skip hoare_when_cases
         ; wpsimp wp: set_thread_state_valid_ready_qs set_thread_state_pred_map_tcb_sts_of
                      get_simple_ko_wp set_thread_state_valid_sched_action)
  by (clarsimp simp: valid_sched_action_no_sc_sched_act_not)

lemma reply_push_valid_release_q[wp]:
  "\<lbrace>valid_release_q and not_in_release_q caller\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  apply reply_push_begin_valid_sched_proof
  by (intro hoare_seq_ext_skip hoare_when_cases
      ; wpsimp wp: set_thread_state_valid_release_q get_simple_ko_wp
             simp: valid_release_q_no_sc_not_in_release_q)

lemma reply_push_valid_sched_action[wp]:
  "\<lbrace>valid_sched_action and scheduler_act_not caller\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. valid_sched_action\<rbrace>"
  apply reply_push_begin_valid_sched_proof
  by (intro hoare_seq_ext_skip hoare_when_cases
      ; wpsimp wp: set_thread_state_valid_sched_action sched_context_donate_valid_sched_action
                   get_simple_ko_wp
             simp: pred_map_simps tcb_at_kh_simps)

lemma reply_push_valid_blocked[wp]:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert caller S) s
         \<and> (pred_map runnable (tcb_sts_of s) callee \<longrightarrow> callee \<in> S \<or> callee = cur_thread s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  apply reply_push_begin_valid_sched_proof
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?)+
  apply (rule_tac B="\<lambda>rv s. pred_map_eq sc_callee (tcb_scps_of s) callee
                            \<and> pred_map_eq sc_caller (tcb_scps_of s) caller
                            \<and> valid_blocked_except_set S s
                            \<and> (pred_map runnable (tcb_sts_of s) callee \<longrightarrow> callee \<in> S \<or> callee = cur_thread s)"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_thread_state_ipc_queued_valid_blocked_except_set
                     hoare_vcg_imp_lift' set_thread_state_pred_map_tcb_sts_of)
  apply (rule hoare_when_cases, simp)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp wp: get_simple_ko_wp\<close>, simp?)+
  by (wpsimp wp: sched_context_donate_valid_blocked set_sc_replies_valid_sched)

lemma reply_push_released_ipc_queues[wp]:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> active_if_bound_sc_tcb_at caller s
        \<and> (\<forall>scp. can_donate
                 \<longrightarrow> heap_ref_eq scp caller (tcb_scps_of s)
                 \<longrightarrow> sched_context_donate_ipc_queues_precond callee scp s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  supply if_split[split del]
  apply reply_push_begin_valid_sched_proof
  apply (intro hoare_seq_ext_skip hoare_when_cases
         ; wpsimp wp: set_thread_state_released_ipc_queues get_simple_ko_wp
                      sched_context_donate_released_sc_released_ipc_queues
                      hoare_vcg_all_lift hoare_vcg_imp_lift' set_thread_state_pred_map_tcb_sts_of)
  by (auto simp: vs_all_heap_simps)

lemma reply_push_active_reply_scs[wp]:
  "\<lbrace>active_reply_scs and active_if_bound_sc_tcb_at caller\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. active_reply_scs\<rbrace>"
  apply reply_push_begin_valid_sched_proof
  apply (intro hoare_seq_ext_skip hoare_when_cases
         ; wpsimp wp: get_simple_ko_wp set_sc_replies_active_reply_scs)
  by (clarsimp simp: vs_all_heap_simps)

crunches reply_push
  for ready_or_release[wp]: "ready_or_release"
  (wp: crunch_wps simp: crunch_simps)

lemma reply_push_valid_sched[wp]:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> valid_blocked_except caller s
         \<and> active_if_bound_sc_tcb_at caller s
         \<and> scheduler_act_not caller s
         \<and> not_queued caller s
         \<and> not_in_release_q caller s
         \<and> (pred_map runnable (tcb_sts_of s) callee \<longrightarrow> callee = cur_thread s)
         \<and> (\<forall>scp. can_donate
                  \<longrightarrow> heap_ref_eq scp caller (tcb_scps_of s)
                  \<longrightarrow> sched_context_donate_ipc_queues_precond callee scp s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp simp: valid_sched_def)

lemma set_tcb_sc_update_active_sc_tcb_at': (* this is more usable *)
  "\<lbrace>active_sc_tcb_at t and (is_sc_active scp)\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr (Some scp)
   \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: set_tcb_obj_ref_def pred_tcb_at_def obj_at_def)
  apply (rule hoare_seq_ext[OF _ assert_get_tcb_ko'])
  apply (wpsimp wp: set_object_wp)
  by (auto simp: vs_all_heap_simps obj_at_def is_sc_active_def
          split: option.splits kernel_object.splits)

lemma set_tcb_sc_update_active_sc_tcb_at_better:
   "\<lbrace>(\<lambda>s. tptr \<noteq> t \<longrightarrow> active_sc_tcb_at t s) and (\<lambda>s. (tptr = t) \<longrightarrow> is_active_sc scp s) \<rbrace>
    set_tcb_obj_ref tcb_sched_context_update tptr (Some scp)
    \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: set_tcb_obj_ref_def pred_tcb_at_def obj_at_def)
  apply (rule hoare_seq_ext[OF _ assert_get_tcb_ko'])
  apply (wpsimp wp: set_object_wp)
  by (auto simp: vs_all_heap_simps obj_at_def)

lemma set_tcb_sc_update_active_sc_tcb_at_better2:
   "\<lbrace>K (tptr \<noteq> t) and active_sc_tcb_at t\<rbrace>
    set_tcb_obj_ref tcb_sched_context_update tptr None
    \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: set_tcb_obj_ref_def pred_tcb_at_def obj_at_def)
  apply (rule hoare_seq_ext[OF _ assert_get_tcb_ko'])
  apply (wpsimp wp: set_object_wp)
  by (auto simp: vs_all_heap_simps obj_at_def)

lemma sched_context_donate_active_sc_tcb_at:
  "\<lbrace>is_sc_active sc_ptr and active_sc_tcb_at t
    and sc_tcb_sc_at (\<lambda>p. p \<noteq> Some t) sc_ptr\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. active_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def get_sc_obj_ref_def assert_opt_def)
  apply (wpsimp wp: set_tcb_sc_update_active_sc_tcb_at_better hoare_vcg_imp_lift'
                    set_tcb_sc_update_active_sc_tcb_at_better2)
  apply (clarsimp simp: is_sc_active_kh_simp)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  done

lemma tcb_sched_context_update_weak_budget_conditions:
  "\<lbrace>is_refill_ready scp and is_refill_sufficient 0 scp \<rbrace>
     set_tcb_obj_ref tcb_sched_context_update tptr (Some scp)
   \<lbrace>\<lambda>r s. budget_ready tptr s \<and> budget_sufficient tptr s\<rbrace>"
  unfolding set_tcb_obj_ref_def
  by (wpsimp wp: set_object_wp get_object_wp
           simp:  vs_all_heap_simps obj_at_kh_kheap_simps sc_at_pred_n_def)

lemma sc_tcb_update_budget_conditions:
  "\<lbrace>is_refill_ready scptr and is_refill_sufficient 0 scptr  \<rbrace>
     set_sc_obj_ref sc_tcb_update scptr (Some tcb_ptr)
   \<lbrace>\<lambda>xaa s. is_refill_ready scptr s \<and> is_refill_sufficient 0 scptr s\<rbrace>"
  apply (wpsimp wp: set_object_wp get_object_wp simp: update_sched_context_def)
  done

lemma sched_context_donate_weak_budget_conditions:
  "\<lbrace>\<lambda>s. is_refill_ready scp s \<and> is_refill_sufficient 0 scp s\<rbrace>
     sched_context_donate scp tcbptr
   \<lbrace>\<lambda>r s. budget_ready tcbptr s \<and> budget_sufficient tcbptr s\<rbrace>"
  unfolding sched_context_donate_def
  apply (wpsimp wp: set_object_wp get_object_wp tcb_sched_context_update_weak_budget_conditions sc_tcb_update_budget_conditions)
  apply (wpsimp wp: set_object_wp get_object_wp simp: test_reschedule_def get_sc_obj_ref_def)+
  done

lemma refill_unblock_check_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and active_sc_valid_refills\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding released_sc_tcb_at_def
  by (wpsimp wp: hoare_vcg_disj_lift)

lemma set_simple_ko_pred_tcb_at_state:
  "\<lbrace> \<lambda>s. P (pred_tcb_at proj (f s) t s) \<and> (\<forall>new. f s = f (s\<lparr>kheap := kheap s(ep \<mapsto> new)\<rparr>))\<rbrace>
   set_simple_ko g ep v
   \<lbrace> \<lambda>_ s. P (pred_tcb_at proj (f s) t s) \<rbrace>"
  unfolding set_simple_ko_def
  apply (wpsimp wp: get_object_wp simp: set_object_def)
  apply (safe; erule rsubst[where P=P];
         clarsimp split: option.splits simp: pred_tcb_at_def obj_at_def fun_upd_def)
  done

lemma RecvEP_queued_ipc_queued_thread:
  "\<lbrakk>kheap s epptr = Some (Endpoint (RecvEP (dest # queue_tail))); sym_refs (state_refs_of s)\<rbrakk>
    \<Longrightarrow> ipc_queued_thread dest s"
   apply (subgoal_tac "(dest, EPRecv) \<in> state_refs_of s epptr")
   apply (drule (1) sym_refsD, simp)
   apply (clarsimp simp: vs_all_heap_simps)
   apply (clarsimp simp: state_refs_of_def refs_of_def get_refs_def tcb_st_refs_of_def
                  split: option.splits kernel_object.splits thread_state.splits if_splits)
   apply (clarsimp simp: state_refs_of_def )
   done

crunches reply_push
  for valid_machine_time[wp]: valid_machine_time
  (wp: crunch_wps simp: crunch_simps)

context DetSchedSchedule_AI begin

crunch scheduler_act[wp]: do_ipc_transfer "(\<lambda>s. P (scheduler_action s)) :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps transfer_caps_loop_pres ignore: const_on_failure)

crunches do_ipc_transfer, handle_fault_reply
  for valid_sched_pred[wp]: "valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps maybeM_wp transfer_caps_loop_pres )

lemma send_ipc_not_queued_for_timeout:
  "\<lbrace>not_queued t
    and scheduler_act_not t
    and (\<lambda>s. \<forall>xb. ~ (ko_at (Endpoint (RecvEP (t # xb))) (cap_ep_ptr cap) s))\<rbrace>
      send_ipc True False (cap_ep_badge cap) True crg False tptr (cap_ep_ptr cap)
   \<lbrace>\<lambda>rv. not_queued t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: send_ipc_def)
  by (wpsimp wp: hoare_drop_imp get_simple_ko_wp maybeM_inv split_del: if_split )

lemma sched_context_donate_bound_sc_tcb_at_None:
  "\<lbrace>\<lambda>s. pred_map_eq None (tcb_scps_of s) dest \<and> caller_tcb \<noteq> dest\<rbrace>
          sched_context_donate sc_ptr caller_tcb
   \<lbrace>\<lambda>_ s. pred_map_eq None (tcb_scps_of s) dest\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def tcb_at_kh_simps[symmetric])
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (wpsimp simp: sched_context_donate_def wp: ssc_bound_tcb_at_cases hoare_vcg_imp_lift')
  done

lemma sched_context_donate_released_if_bound_callee:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at ((=) None) callee s \<and> is_sc_active sc_caller s
        \<and> is_refill_ready sc_caller s\<rbrace>
   sched_context_donate sc_caller callee
   \<lbrace>\<lambda>r. released_if_bound_sc_tcb_at callee\<rbrace>"
  apply (clarsimp simp: released_sc_tcb_at_def)
  apply (wpsimp wp: hoare_vcg_disj_lift sched_context_donate_bound_sc_tcb_at_None
                    sched_context_donate_bound_sc_obj_tcb_at
                    sched_context_donate_weak_budget_conditions)
  by (clarsimp simp: obj_at_kh_kheap_simps)

lemma reply_push_released_if_bound_callee:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at callee s
        \<and> (can_donate \<longrightarrow> released_if_bound_sc_tcb_at caller s)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>r. released_if_bound_sc_tcb_at callee\<rbrace>"
  supply if_split[split del]
  apply (simp add: reply_push_def bind_sc_reply_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])+
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)+
  apply (rule hoare_when_cases; clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp wp: hoare_drop_imps\<close>)+
  apply (wpsimp wp: sched_context_donate_released_if_bound_callee)
  by (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise vs_all_heap_simps)

\<comment> \<open>The following proofs unbundle valid_sched for send_ipc.
    These lemmas are to support existing unbundled proofs for charge_budget.
    The bundled lemma is preserved below.
    FIXME RT: Find a way to avoid duplication of the structure of the following proofs.
    Alternatively, rework charge_budget proofs to bundle valid_sched invariants.\<close>
lemma send_ipc_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> released_ipc_queues s \<and> valid_sched_action s \<and> active_sc_valid_refills s
        \<and> valid_sender_sc_tcb_at t s \<and> not_queued t s \<and> scheduler_act_not t s
        \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp wp: set_thread_state_valid_ready_qs)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_ready_qs s \<and> released_ipc_queues s \<and> valid_sched_action s
                           \<and> valid_sender_sc_tcb_at t s \<and> released_if_bound_sc_tcb_at dest s
                           \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)
                           \<and> not_queued t s \<and> scheduler_act_not t s \<and> active_sc_valid_refills s
                           \<and> \<not> pred_map runnable (tcb_sts_of s) dest"
         in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas)
   apply (clarsimp cong: conj_cong)
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) dest \<and> released_if_bound_sc_tcb_at dest s"
          ; clarsimp simp: tcb_sts.pred_map_simps is_blocked_thread_state_defs elim!: released_ipc_queues_blocked_on_recv_ntfn_D)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. valid_ready_qs s \<and> released_if_bound_sc_tcb_at dest s
                           \<and> active_sc_valid_refills s" in hoare_seq_ext)
   apply (rule_tac B="\<lambda>_ s. valid_ready_qs s \<and> released_if_bound_sc_tcb_at dest s
                            \<and> st_tcb_at runnable dest s \<and> active_sc_valid_refills s"
          in hoare_seq_ext[rotated])
    apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of set_thread_state_valid_ready_qs)
   apply (wpsimp wp: possible_switch_to_valid_ready_qs)
       apply (rule hoare_disjI2)
       apply (rule_tac Q="\<lambda>_ s. st_tcb_at runnable dest s \<and> released_sc_tcb_at dest s"
              in hoare_strengthen_post)
        apply (wpsimp wp: hoare_drop_imp)
       apply (clarsimp simp: pred_tcb_at_def obj_at_def)
      apply wpsimp
     apply wpsimp
    apply (wpsimp wp: get_tcb_obj_ref_wp)
   apply (clarsimp split: if_split)
   apply (rule conjI; clarsimp simp: obj_at_def pred_tcb_at_def tcb_at_kh_simps[symmetric])
  apply (intro hoare_if[rotated] hoare_when_cases)
     apply clarsimp
    apply (wpsimp wp: sched_context_donate_released_if_bound_callee get_tcb_obj_ref_wp)
    apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps valid_sched_action_no_sc_sched_act_not)
   apply (wpsimp wp: set_thread_state_valid_ready_qs)
  by (wpsimp wp: reply_push_released_if_bound_callee)

lemma reply_push_st_tcb_at_BlockedOnReply:
  "\<lbrace>st_tcb_at P t and K (P (BlockedOnReply reply_ptr))\<rbrace>
     reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>rv. st_tcb_at P t\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_if_lift2 sts_st_tcb_at_cases hoare_vcg_all_lift)

crunches reply_push
  for not_in_release_q[wp]: "not_in_release_q p"
  (wp: crunch_wps set_object_wp simp: crunch_simps)

lemma send_ipc_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> not_in_release_q t s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp wp: set_thread_state_valid_release_q)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_release_q s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> not_in_release_q t s \<and> \<not> pred_map runnable (tcb_sts_of s) dest"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas simp: tcb_sts.pred_map_simps)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. valid_release_q s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> not_in_release_q dest s" in hoare_seq_ext)
   apply (wpsimp wp: refill_unblock_check_valid_release_q get_tcb_obj_ref_wp)
    apply (rule_tac Q="\<lambda>_ s. valid_release_q s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                             \<and> not_in_release_q dest s" in hoare_strengthen_post[rotated])
     apply (clarsimp split: if_split)
     apply (clarsimp simp: obj_at_def heap_refs_inv_def2 pred_map_eq vs_all_heap_simps)
     apply (drule_tac x=dest and y=x in spec2, clarsimp simp: opt_map_red)
    apply (wpsimp wp: hoare_drop_imps hoare_vcg_conj_lift hoare_vcg_if_lift_strong
                      set_thread_state_valid_release_q)
   apply simp
  apply (simp add: pred_conj_def obj_at_def)
  by (wpsimp wp: set_thread_state_valid_release_q simp: in_release_q_runnable split: if_splits)
     (fastforce simp: valid_release_q_def in_queue_2_def)

lemma send_ipc_ct_not_in_q:
  "\<lbrace>\<lambda>s. ct_not_in_q s \<and> ct_in_cur_domain s \<and> idle_thread_is_idle s\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. ct_not_in_q s \<and> ct_in_cur_domain s
                           \<and> \<not> pred_map runnable (tcb_sts_of s) dest \<and> dest \<noteq> idle_thread s"
         in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas)
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) dest \<and> dest \<noteq> idle_thread s"
          ; clarsimp simp: tcb_sts.pred_map_simps)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. ct_not_in_q s \<and> ct_in_cur_domain s \<and> dest \<noteq> idle_thread s" in hoare_seq_ext)
   apply (wpsimp wp: possible_switch_to_not_it_ct_not_in_q maybeM_inv)
  by wpsimp

lemma send_ipc_valid_sched_action:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> released_ipc_queues s \<and> scheduler_act_not t s
         \<and> valid_sender_sc_tcb_at t s \<and> active_sc_valid_refills s
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp wp: set_thread_state_valid_sched_action)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_sched_action s \<and> scheduler_act_not t s
                           \<and> valid_sender_sc_tcb_at t s \<and> active_sc_valid_refills s
                           \<and> released_if_bound_sc_tcb_at dest s
                           \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)"
         in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas)
   apply (prop_tac "released_if_bound_sc_tcb_at dest s"
          ; clarsimp simp: tcb_sts.pred_map_simps is_blocked_thread_state_defs elim!: released_ipc_queues_blocked_on_recv_ntfn_D)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_. valid_sched_action and released_if_bound_sc_tcb_at dest and active_sc_valid_refills" in hoare_seq_ext)
   apply wpsimp
        apply (rule_tac Q="\<lambda>_ s. pred_map runnable (tcb_sts_of s) dest \<and>
                       released_if_bound_sc_tcb_at dest s" in hoare_strengthen_post[rotated])
         apply (clarsimp simp: pred_map_simps)
        apply (wpsimp wp: get_tcb_obj_ref_wp)+
    apply (rule_tac Q="\<lambda>_ s. valid_sched_action s \<and> pred_map runnable (tcb_sts_of s) dest
                                     \<and> active_sc_valid_refills s
                                     \<and> released_if_bound_sc_tcb_at dest s"
           in hoare_strengthen_post[rotated])
     apply (clarsimp split: if_split simp: tcb_at_kh_simps vs_all_heap_simps obj_at_def opt_map_red)
    apply (wpsimp wp: set_thread_state_valid_sched_action set_thread_state_pred_map_tcb_sts_of)
   apply clarsimp
  apply (simp add: pred_conj_def obj_at_def)
  apply (intro hoare_if[rotated] hoare_when_cases)
     apply clarsimp
    apply (wpsimp wp: sched_context_donate_valid_sched_action
                      sched_context_donate_released_if_bound_callee get_tcb_obj_ref_wp
                simp: valid_sched_action_no_sc_sched_act_not)
    apply (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise vs_all_heap_simps)
   apply (wpsimp wp: set_thread_state_valid_sched_action)
  by (wpsimp wp: reply_push_released_if_bound_callee)

lemma send_ipc_ct_in_cur_domain:
  "send_ipc block call badge can_grant can_grant_reply can_donate t epptr \<lbrace>ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. ct_in_cur_domain s \<and> \<not> pred_map runnable (tcb_sts_of s) dest"
         in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas hoare_vcg_disj_lift simp: valid_sched_def)
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) dest"; clarsimp simp: tcb_sts.pred_map_simps)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. ct_in_cur_domain s" in hoare_seq_ext)
   apply (wpsimp wp: maybeM_inv)
  by wpsimp

lemma send_ipc_valid_blocked:
  "\<lbrace>\<lambda>s. \<comment> \<open>In do_reply_transfer, valid_blocked might be broken for handle_timeout\<close>
        valid_blocked_except_set (insert t S) s
         \<comment> \<open>Timeout faults can come from threads other than the current thread
             ; see handle_timeout in do_reply_transfer\<close>
         \<and> (valid_blocked_tcb_at t s \<or> block \<and> pred_map bound (tcb_faults_of s) t)\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. valid_blocked_except_set S :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp
          ; wpsimp wp: set_thread_state_ipc_queued_valid_blocked_except_set
          ; clarsimp elim!: valid_blocked_divided_threadE)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_blocked_except_set (insert t S) s
                           \<and> (valid_blocked_tcb_at t s \<or> block \<and> pred_map bound (tcb_faults_of s) t)
                           \<and>  \<not> pred_map runnable (tcb_sts_of s) dest"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas hoare_vcg_disj_lift)
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) dest"; clarsimp simp: tcb_sts.pred_map_simps)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. valid_blocked_except_set S s" in hoare_seq_ext)
   apply (wpsimp wp: possible_switch_to_valid_blocked set_thread_state_valid_blocked maybeM_inv)
  apply (simp add: pred_conj_def obj_at_def)
  apply (intro hoare_if[rotated] hoare_when_cases)
     apply (clarsimp simp: vs_all_heap_simps elim!: valid_blocked_divided_threadE)
    apply (wpsimp wp: sched_context_donate_valid_blocked get_tcb_obj_ref_wp)
    apply (clarsimp simp: vs_all_heap_simps valid_blocked_thread_def elim!: valid_blockedE')
   apply wpsimp
  by wpsimp

(* FIXME RT: move *)
lemma maybeM_wp_weak:
  "((\<exists>a. opt = Some a) \<Longrightarrow> \<lbrace>Q\<rbrace> f (the opt) \<lbrace>\<lambda>_. P\<rbrace>) \<Longrightarrow> \<lbrace>P and Q\<rbrace> maybeM f opt \<lbrace>\<lambda>_. P\<rbrace>"
  by (wpsimp wp: maybeM_wp; fastforce)

lemma send_ipc_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> active_sc_valid_refills s
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)
         \<and> valid_sender_sc_tcb_at t s\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp wp: set_thread_state_released_ipc_queues simp: is_blocked_thread_state_defs)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. released_ipc_queues s \<and> active_sc_valid_refills s
                            \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)
                            \<and> valid_sender_sc_tcb_at t s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_. released_ipc_queues and active_sc_valid_refills" in hoare_seq_ext)
   apply (wpsimp wp: set_thread_state_released_ipc_queues maybeM_wp_weak hoare_vcg_if_lift2 hoare_drop_imp
               simp: is_blocked_thread_state_defs)
  apply (simp add: pred_conj_def obj_at_def)
  apply (intro hoare_if[rotated] hoare_when_cases)
     apply clarsimp
    apply (wpsimp wp: sched_context_donate_released_sc_released_ipc_queues get_tcb_obj_ref_wp)
    apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps)
   apply (wpsimp wp: set_thread_state_released_ipc_queues simp: is_blocked_thread_state_defs)
  apply wpsimp
  by (auto simp: vs_all_heap_simps is_blocked_thread_state_defs is_timeout_fault_opt_def
          split: if_splits option.splits)

lemma send_ipc_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> active_if_bound_sc_tcb_at t s\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. active_reply_scs s \<and> active_if_bound_sc_tcb_at t s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. active_reply_scs s" in hoare_seq_ext)
   apply (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift)
  by wpsimp

lemma send_ipc_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills and current_time_bounded\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>_. active_sc_valid_refills :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding send_ipc_def
  by (wpsimp wp: refill_unblock_check_active_sc_valid_refills hoare_drop_imp hoare_vcg_all_lift
                    hoare_vcg_if_lift2)

crunches reply_push
  for tcb_at[wp]: "tcb_at t"
  (wp: hoare_drop_imps crunch_wps simp: crunch_simps)

crunches send_ipc
  for ready_or_release[wp]: "ready_or_release :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps hoare_drop_imps)

lemmas send_ipc_valid_sched_unbundled
  = send_ipc_valid_ready_qs send_ipc_valid_release_q send_ipc_ct_not_in_q
    send_ipc_valid_sched_action send_ipc_ct_in_cur_domain send_ipc_valid_blocked
    send_ipc_released_ipc_queues send_ipc_active_reply_scs send_ipc_active_sc_valid_refills

crunches reply_push
  for not_in_release_q[wp]: "not_in_release_q p"
  (wp: crunch_wps simp: crunch_simps)

lemma send_ipc_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> idle_thread_is_idle s
         \<comment> \<open>In do_reply_transfer, valid_blocked might be broken for handle_timeout\<close>
         \<and> valid_blocked_except t s
         \<comment> \<open>Timeout faults can come from threads other than the current thread
             ; see handle_timeout in do_reply_transfer\<close>
         \<and> (valid_blocked_tcb_at t s \<or> block \<and> pred_map bound (tcb_faults_of s) t)
         \<comment> \<open>If the sender offers to donate, it must have a sched context to donate\<close>
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)
         \<and> valid_sender_sc_tcb_at t s
         \<and> scheduler_act_not t s
         \<and> not_queued t s
         \<and> not_in_release_q t s
         \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
         \<and> current_time_bounded s\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate t epptr
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  \<comment> \<open>We can prove this lemma two different ways.\<close>
  apply (rule conj_absorb[THEN iffD1, OF conjI])
  \<comment> \<open>Firstly, we simply use the lemmas above, which unbundle valid_sched for send_ipc.\<close>
   apply (wpsimp wp: send_ipc_valid_sched_unbundled simp: valid_sched_def)
   apply (clarsimp simp: vs_all_heap_simps)
  \<comment> \<open>Secondly, we can independently perform a bundled proof. Although this is redundant, this
      might be preferable to the unbundled proofs, since it avoids duplication of proof structure,
      and checks faster than the collection of unbundled proofs. However, it is currently not
      possible to drop the unbundled lemmas, since they are needed for existing unbundled
      charge_budget lemmas.\<close>
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp
          ; wpsimp wp: set_thread_state_ipc_queued_valid_blocked_except_set
                       set_thread_state_valid_sched_except_blocked
                 simp: valid_sched_valid_sched_except_blocked scheduler_act_not_def
          ; clarsimp elim!: valid_blocked_divided_threadE)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp], simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. valid_sched_except_blocked s \<and> valid_blocked_except t s
                           \<and> released_if_bound_sc_tcb_at dest s
                           \<and> (valid_blocked_tcb_at t s \<or> block \<and> pred_map bound (tcb_faults_of s) t)
                           \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> timeout_faulted_tcb_at t s)
                           \<and> valid_sender_sc_tcb_at t s
                           \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> scheduler_act_not t s \<and> not_queued t s \<and> not_in_release_q t s
                           \<and> dest \<noteq> idle_thread s
                           \<and> \<not> pred_map runnable (tcb_sts_of s) dest \<and> current_time_bounded s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas hoare_vcg_disj_lift simp: valid_sched_def)
   apply (simp flip: id_def)? \<comment> \<open>Unifier did something weird here\<close>
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) dest \<and> released_if_bound_sc_tcb_at dest s"
          , clarsimp simp: tcb_sts.pred_map_simps elim!: released_ipc_queues_blocked_on_recv_ntfn_E1)
   apply (prop_tac "dest \<noteq> idle_thread s", clarsimp simp: vs_all_heap_simps)
   apply (clarsimp elim!: released_ipc_queuesE)
   apply (clarsimp simp: vs_all_heap_simps split: if_splits)
  apply (rule hoare_seq_ext[OF _ gsc_sp], clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac B="\<lambda>_ s. valid_sched s \<and> released_if_bound_sc_tcb_at dest s \<and> dest \<noteq> idle_thread s
                           \<and> current_time_bounded s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> not_in_release_q dest s"
         in hoare_seq_ext)
   apply (wpsimp wp: possible_switch_to_valid_sched_weak
                     refill_unblock_check_valid_sched_except_blocked)
        apply (rule_tac Q="\<lambda>_ s. pred_map runnable (tcb_sts_of s) dest
                               \<and> dest \<noteq> idle_thread s \<and> released_if_bound_sc_tcb_at dest s"
               in hoare_strengthen_post[rotated])
         apply (clarsimp simp: pred_map_simps)
        apply (wpsimp wp: get_tcb_obj_ref_wp)+
    apply (rule_tac Q="\<lambda>_ s. valid_sched_except_blocked s \<and> valid_blocked_except dest s
                           \<and> pred_map runnable (tcb_sts_of s) dest \<and> current_time_bounded s
                           \<and> dest \<noteq> idle_thread s \<and> released_if_bound_sc_tcb_at dest s
                           \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> not_in_release_q dest s \<and> active_sc_valid_refills s"
           in hoare_strengthen_post[rotated])
     apply (clarsimp simp: pred_map_eq obj_at_def released_sc_tcb_at_def
                    split: if_split)
     apply (erule disjE; clarsimp simp: vs_all_heap_simps tcb_at_kh_simps opt_map_red)
     apply (clarsimp simp: heap_refs_inv_def2 tcb_at_kh_simps sc_at_kh_simps vs_all_heap_simps pred_map_eq)
     apply (rename_tac scp sc' n sc; frule_tac x=t and y=scp in spec2)
     apply (frule_tac x=dest and y=scp in spec2, fastforce simp: opt_map_red)
    apply (subst conj_assoc[symmetric])
    apply (rule hoare_vcg_conj_lift, subst pred_conj_def[symmetric])
     apply (wpsimp wp: set_thread_state_break_valid_sched)
    apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of)
   apply clarsimp
  apply (simp add: pred_conj_def obj_at_def valid_blocked_thread_def)
  apply (intro hoare_if[rotated] hoare_when_cases)
     apply clarsimp
     apply (intro conjI)
      apply (clarsimp simp: valid_sched_valid_sched_except_blocked vs_all_heap_simps
                     elim!: valid_blockedE')
     apply (clarsimp simp: valid_release_q_def valid_sched_def in_release_q_def)
    apply (wpsimp wp: sched_context_donate_valid_sched sched_context_donate_not_in_release_q
                      sched_context_donate_released_if_bound_callee get_tcb_obj_ref_wp)
    apply (prop_tac "not_in_release_q dest s")
     apply (clarsimp simp: valid_release_q_def in_release_q_def valid_sched_def)
    apply (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise vs_all_heap_simps
                          valid_sched_valid_sched_except_blocked
                   elim!: valid_blockedE')
   apply (wpsimp wp: set_thread_state_Inactive_not_queued_valid_sched simp: valid_sched_def)
   apply (clarsimp simp: valid_release_q_def in_release_q_def)
  apply (wpsimp wp: reply_push_released_if_bound_callee)
  apply (prop_tac "not_in_release_q dest s")
   apply (clarsimp simp: valid_release_q_def in_release_q_def valid_sched_def)
  apply simp
  \<comment> \<open>Focus on just the assumption we need to speed up the proof\<close>
  by (match premises in H: \<open>timeout_faulted_tcb_at t s \<and> active_sc_tcb_at t s \<or> released_if_bound_sc_tcb_at t s\<close>
                    and D: \<open>can_donate \<longrightarrow> _\<close> for s
      \<Rightarrow> \<open>insert D H, fastforce simp: vs_all_heap_simps\<close>)

lemma send_fault_ipc_valid_sched_misc[wp]:
  "send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                            (idle_thread s) (etcbs_of s)\<rbrace>"
  unfolding send_fault_ipc_def by wpsimp

lemma thread_set_fault_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s
        \<and> (timeout_faulted_tcb_at t s \<and> blocked_on_send_tcb_at t s
           \<longrightarrow> is_timeout_fault fault \<or> released_if_bound_sc_tcb_at t s)\<rbrace>
   thread_set (tcb_fault_update (\<lambda>_. Some fault)) t
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (wpsimp wp: thread_set_fault_valid_sched_pred)
  by (clarsimp simp: heap_upd_def is_timeout_fault_opt_def vs_all_heap_simps elim!: released_ipc_queuesE)

lemma thread_set_fault_tcb_at':
  "\<lbrace>\<lambda>s. if t' = t then N (P fault_opt) else N (fault_tcb_at' P t' s)\<rbrace>
   thread_set (tcb_fault_update (\<lambda>_. fault_opt)) t
   \<lbrace>\<lambda>_ s. N (fault_tcb_at' P t' s)\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  by (clarsimp simp: vs_all_heap_simps)

lemma send_fault_ipc_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> released_ipc_queues s \<and> valid_sched_action s
         \<and> active_sc_valid_refills s
         \<and> (is_timeout_fault fault \<and> active_sc_tcb_at t s \<or> released_if_bound_sc_tcb_at t s)
         \<and> not_queued t s \<and> scheduler_act_not t s
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> is_timeout_fault fault)\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: send_ipc_valid_ready_qs thread_set_fault_released_ipc_queues
                    hoare_vcg_disj_lift thread_set_fault_tcb_at' hoare_vcg_const_imp_lift)
  by (auto simp: vs_all_heap_simps is_timeout_fault_opt_def split: option.splits)

lemma send_fault_ipc_valid_release_q:
  "\<lbrace>valid_release_q and not_in_release_q t
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def by (wpsimp wp: send_ipc_valid_release_q)

lemma send_fault_ipc_ct_not_in_q:
  "\<lbrace>ct_not_in_q and ct_in_cur_domain and idle_thread_is_idle\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def by (wpsimp wp: send_ipc_ct_not_in_q)

lemma send_fault_ipc_valid_sched_action:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> released_ipc_queues s \<and> scheduler_act_not t s
         \<and> active_sc_valid_refills s
         \<and> (is_timeout_fault fault \<and> active_sc_tcb_at t s \<or> released_if_bound_sc_tcb_at t s)
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> is_timeout_fault fault)\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: send_ipc_valid_sched_action thread_set_fault_released_ipc_queues
                    hoare_vcg_disj_lift thread_set_fault_tcb_at' hoare_vcg_const_imp_lift)
  by (auto simp: vs_all_heap_simps is_timeout_fault_opt_def split: option.splits)

lemma send_fault_ipc_ct_in_cur_domain:
  "send_fault_ipc t handler_cap fault can_donate \<lbrace>ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def by (wpsimp wp: send_ipc_ct_in_cur_domain)

lemma send_fault_ipc_valid_blocked:
  "\<lbrace>\<lambda>s. \<comment> \<open>In do_reply_transfer, valid_blocked might be broken for handle_timeout\<close>
        valid_blocked_except_set (insert t S) s
         \<comment> \<open>Timeout faults can come from threads other than the current thread
             ; see handle_timeout in do_reply_transfer\<close>
         \<and> (valid_blocked_tcb_at t s \<or> is_ep_cap handler_cap)\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. valid_blocked_except_set S :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: send_ipc_valid_blocked thread_set_fault_valid_sched_pred)
  apply (intro conjI allI impI
         ; clarsimp simp: heap_upd_def elim!: valid_blocked_divided_threadE)
  by (auto simp: vs_all_heap_simps valid_blocked_thread_def)

lemma send_fault_ipc_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s
         \<and> active_sc_valid_refills s
         \<and> (is_timeout_fault fault \<and> active_sc_tcb_at t s \<or> released_if_bound_sc_tcb_at t s)
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> is_timeout_fault fault)\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: send_ipc_released_ipc_queues thread_set_fault_released_ipc_queues
                    hoare_vcg_disj_lift thread_set_fault_tcb_at' hoare_vcg_const_imp_lift)
  by (auto simp: vs_all_heap_simps is_timeout_fault_opt_def split: option.splits)

lemma send_fault_ipc_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> active_if_bound_sc_tcb_at t s\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def by (wpsimp wp: send_ipc_active_reply_scs)

lemmas send_fault_ipc_valid_sched_unbundled
  = send_fault_ipc_valid_ready_qs send_fault_ipc_valid_release_q send_fault_ipc_ct_not_in_q
    send_fault_ipc_valid_sched_action send_fault_ipc_ct_in_cur_domain
    send_fault_ipc_valid_blocked send_fault_ipc_released_ipc_queues send_fault_ipc_active_reply_scs

lemma send_fault_ipc_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> idle_thread_is_idle s
         \<comment> \<open>In do_reply_transfer, valid_blocked might be broken for handle_timeout\<close>
         \<and> valid_blocked_except t s
         \<comment> \<open>Timeout faults can come from threads other than the current thread
             ; see handle_timeout in do_reply_transfer\<close>
         \<and> (valid_blocked_tcb_at t s \<or> is_ep_cap handler_cap)
         \<comment> \<open>If the sender offers to donate, it must have a sched context to donate\<close>
         \<and> (can_donate \<longrightarrow> pred_map bound (tcb_scps_of s) t \<and> \<not> is_timeout_fault fault)
         \<and> (is_timeout_fault fault \<and> active_sc_tcb_at t s \<or> released_if_bound_sc_tcb_at t s)
         \<and> scheduler_act_not t s
         \<and> not_queued t s
         \<and> not_in_release_q t s
         \<and> active_sc_valid_refills s
         \<and> current_time_bounded s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   send_fault_ipc t handler_cap fault can_donate
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: send_ipc_valid_sched thread_set_fault_valid_sched_pred)
  by (auto simp: valid_sched_def heap_upd_def vs_all_heap_simps
                 is_timeout_fault_def is_timeout_fault_opt_def
          elim!: released_ipc_queuesE valid_blocked_divided_threadE
          split: if_splits)

lemma handle_timeout_valid_sched_misc[wp]:
  "handle_timeout t timeout
   \<lbrace>\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                            (idle_thread s) (etcbs_of s)\<rbrace>"
  unfolding handle_timeout_def by wpsimp

lemma handle_timeout_valid_ready_qs:
  "\<lbrace>\<lambda>s. valid_ready_qs s \<and> released_ipc_queues s \<and> valid_sched_action s
         \<and> active_sc_valid_refills s
         \<and> active_if_bound_sc_tcb_at t s \<and> not_queued t s \<and> scheduler_act_not t s
         \<and> is_timeout_fault timeout\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def
  by (wpsimp wp: send_fault_ipc_valid_ready_qs)

lemma handle_timeout_valid_release_q:
  "\<lbrace>valid_release_q and not_in_release_q t
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by (wpsimp wp: send_fault_ipc_valid_release_q)

lemma handle_timeout_ct_not_in_q:
  "\<lbrace>ct_not_in_q and ct_in_cur_domain and idle_thread_is_idle\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by (wpsimp wp: send_fault_ipc_ct_not_in_q)

lemma handle_timeout_valid_sched_action:
  "\<lbrace>\<lambda>s. valid_sched_action s \<and> released_ipc_queues s \<and> scheduler_act_not t s
        \<and> active_sc_valid_refills s
         \<and> active_if_bound_sc_tcb_at t s \<and> is_timeout_fault timeout\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def
  by (wpsimp wp: send_fault_ipc_valid_sched_action)

lemma handle_timeout_ct_in_cur_domain:
  "handle_timeout t timeout \<lbrace>ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by (wpsimp wp: send_fault_ipc_ct_in_cur_domain)

lemma handle_timeout_valid_blocked:
  "\<lbrace>\<lambda>s. valid_blocked_except_set (insert t S) s\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. valid_blocked_except_set S :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by (wpsimp wp: send_fault_ipc_valid_blocked)

lemma handle_timeout_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> active_sc_valid_refills s
         \<and> active_if_bound_sc_tcb_at t s \<and> is_timeout_fault timeout\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def
  by (wpsimp wp: send_fault_ipc_released_ipc_queues)

lemma handle_timeout_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> active_if_bound_sc_tcb_at t s\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by (wpsimp wp: send_fault_ipc_active_reply_scs)

lemmas handle_timeout_valid_sched_bundled
  = handle_timeout_valid_ready_qs handle_timeout_valid_release_q handle_timeout_ct_not_in_q
    handle_timeout_valid_sched_action handle_timeout_ct_in_cur_domain handle_timeout_valid_blocked
    handle_timeout_released_ipc_queues handle_timeout_active_reply_scs

lemma handle_timeout_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched_except_blocked s
         \<and> idle_thread_is_idle s
         \<and> valid_blocked_except t s
         \<and> active_if_bound_sc_tcb_at t s
         \<and> scheduler_act_not t s
         \<and> not_queued t s
         \<and> not_in_release_q t s
         \<and> is_timeout_fault timeout \<and> active_sc_valid_refills s
         \<and> current_time_bounded s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   handle_timeout t timeout
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def
  by (wpsimp wp: send_fault_ipc_valid_sched)

end

lemma thread_set_is_sc_active[wp]:
  "thread_set f t \<lbrace>\<lambda>s. Q (is_sc_active scp s)\<rbrace>"
  by (wpsimp wp: thread_set_wp, clarsimp simp: is_sc_active_def dest!: get_tcb_SomeD)

lemma send_fault_ipc_error_sched_act_not[wp]:
  "\<lbrace>scheduler_act_not t\<rbrace> send_fault_ipc tptr handler_cap fault can_donate -, \<lbrace>\<lambda>rv. scheduler_act_not t\<rbrace>"
  by (simp add: send_fault_ipc_def Let_def |
      (wp hoare_drop_imps hoare_vcg_all_lift_R)+ | wpc)+

lemma send_fault_ipc_error_cur_thread[wp]:
  "\<lbrace>\<lambda>s. P (cur_thread s)\<rbrace> send_fault_ipc tptr handler_cap fault can_donate -, \<lbrace>\<lambda>rv s. P (cur_thread s)\<rbrace>"
  by (simp add: send_fault_ipc_def Let_def |
      (wp hoare_drop_imps hoare_vcg_all_lift_R)+ | wpc)+

lemma send_fault_ipc_error_not_queued[wp]:
  "\<lbrace>not_queued t\<rbrace> send_fault_ipc tptr handler_cap fault can_donate -, \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  by (simp add: send_fault_ipc_def Let_def |
      (wp hoare_drop_imps hoare_vcg_all_lift_R)+ | wpc)+

context DetSchedSchedule_AI begin

lemma send_ipc_not_queued:
  "\<lbrace>not_queued tcb_ptr and scheduler_act_not tcb_ptr
    and (\<lambda>s. \<forall>qtail. \<not> pred_map_eq (tcb_ptr # qtail) (ep_recv_qs_of s) epptr)\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate tptr epptr
   \<lbrace>\<lambda>rv. not_queued tcb_ptr:: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: send_ipc_def)
  apply (wpsimp wp: hoare_drop_imp get_simple_ko_wp maybeM_inv
         split_del: if_split
              simp: do_ipc_transfer_def do_normal_transfer_def vs_all_heap_simps
                    obj_at_kh_kheap_simps)
  done

lemma send_ipc_not_in_release_q:
  "\<lbrace>not_in_release_q t\<rbrace>
   send_ipc True False badge can_grant can_grant_reply can_donate tptr epptr
   \<lbrace>\<lambda>rv. not_in_release_q t::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: send_ipc_def )
  by (wpsimp wp: hoare_drop_imp get_simple_ko_wp hoare_vcg_all_lift
      split_del: if_split
           simp: do_ipc_transfer_def do_normal_transfer_def)

crunches set_extra_badge, copy_mrs
  for scheduler_action[wp]: "\<lambda>s. P (scheduler_action s)"
  (wp: crunch_wps)

lemma transfer_caps_loop_scheduler_action:
  "transfer_caps_loop h x2 m xd dest_slots mi' \<lbrace>\<lambda>s::det_state. P (scheduler_action s)\<rbrace>"
  apply (induction rule: transfer_caps_loop.induct; simp)
  apply safe
  apply (wpsimp | assumption)+
  done

lemma transfer_caps_scheduler_act_not:
  "\<lbrace>scheduler_act_not t and (\<lambda>s. \<forall>xb. \<not>ko_at (Endpoint (RecvEP (t # xb))) epptr s)\<rbrace>
   send_ipc True False badge can_grant can_grant_reply can_donate tptr epptr
   \<lbrace>\<lambda>rv. scheduler_act_not t::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: send_ipc_def )
  apply (wpsimp wp: hoare_drop_imps
         split_del: if_split
              simp: do_ipc_transfer_def do_normal_transfer_def do_fault_transfer_def)
     apply (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps)
    apply clarsimp
    apply (wpsimp wp: get_simple_ko_wp)+
  done

lemma send_fault_ipc_not_queued:
  "\<lbrace>invs and not_queued t and st_tcb_at (not ipc_queued_thread_state) t and scheduler_act_not t\<rbrace>
   send_fault_ipc tptr handler_cap fault can_donate
   \<lbrace>\<lambda>rv. not_queued t::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift_R send_ipc_not_queued
              simp: obj_at_kh_kheap_simps vs_all_heap_simps)
  apply (subgoal_tac "st_tcb_at ipc_queued_thread_state t s")
   apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def)
  apply (subgoal_tac "ko_at (Endpoint (RecvEP (t # qtail))) x s")
   apply (rule ep_queued_st_tcb_at; clarsimp?)
    apply assumption
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
   apply (rule refl)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def)
  done

lemma send_fault_ipc_not_queued_not_ep_queued:
  "\<lbrace>not_queued t and scheduler_act_not t
    and (\<lambda>s. \<forall>qtail. \<not> pred_map_eq (t # qtail) (ep_recv_qs_of s) (cap_ep_ptr handler_cap))\<rbrace>
   send_fault_ipc t' handler_cap fault can_donate
   \<lbrace>\<lambda>rv. not_queued t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: thread_set_wp send_ipc_not_queued simp: obj_at_kh_kheap_simps vs_all_heap_simps)
  done

lemma send_fault_ipc_not_in_release_q:
  "\<lbrace>not_in_release_q t\<rbrace> send_fault_ipc tptr handler_cap fault can_donate \<lbrace>\<lambda>rv. not_in_release_q t::'state_ext state \<Rightarrow> _\<rbrace>"
  by (simp add: send_fault_ipc_def Let_def |
      (wp hoare_drop_imps hoare_vcg_all_lift_R send_ipc_not_in_release_q)+ | wpc)+

lemma send_fault_ipc_scheduler_act_not:
  "\<lbrace>invs and st_tcb_at active t and scheduler_act_not t\<rbrace>
   send_fault_ipc tptr handler_cap fault can_donate
   \<lbrace>\<lambda>rv. scheduler_act_not t::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  apply (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift_R transfer_caps_scheduler_act_not)
               apply (wpsimp wp: thread_set_wp)+
  apply (subgoal_tac "st_tcb_at (not active) t s")
   apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def)
  apply (subgoal_tac "ko_at (Endpoint (RecvEP (t # xba))) x s")
   apply (rule ep_queued_st_tcb_at; clarsimp?)
     apply assumption
    apply (clarsimp simp: pred_tcb_at_def obj_at_def)
    apply (rule refl)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def split: if_splits)
  done

lemma reply_push_weak_valid_sched_action_no_donation:
  "\<lbrace> weak_valid_sched_action and
     scheduler_act_not thread\<rbrace>
   reply_push thread dest ya False
   \<lbrace>\<lambda>rv. weak_valid_sched_action\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  apply clarsimp
  by (wpsimp wp: set_thread_state_weak_valid_sched_action hoare_drop_imps
                 update_sk_obj_ref_lift)

lemma reply_push_valid_blocked_no_donation:
  "\<lbrace> valid_blocked_except_set (insert thread S)\<rbrace>
   reply_push thread dest ya False
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  apply clarsimp
  by (wpsimp wp: set_thread_state_not_runnable_valid_blocked_remove hoare_drop_imps
                 update_sk_obj_ref_lift)

lemma reply_push_valid_blocked_no_donation':
  "\<lbrace> valid_blocked_except_set S\<rbrace>
   reply_push thread dest ya False
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  apply clarsimp
  by (wpsimp wp: set_thread_state_not_runnable_valid_blocked_remove hoare_drop_imps
                 update_sk_obj_ref_lift)

lemma weak_valid_sched_action_scheduler_action_not:
  "weak_valid_sched_action s \<Longrightarrow> st_tcb_at (Not \<circ> runnable) t s \<Longrightarrow> scheduler_act_not t s"
  by (clarsimp simp: weak_valid_sched_action_def scheduler_act_not_def tcb_at_kh_simps pred_map_def)

lemma valid_release_q_not_in_release_q_not_runnable:
  "valid_release_q s \<Longrightarrow> st_tcb_at (Not \<circ> runnable) t s \<Longrightarrow> not_in_release_q t s"
  by (clarsimp simp: valid_release_q_def not_in_release_q_def  tcb_at_kh_simps pred_map_def, fastforce)

lemma valid_ready_qs_not_queued_not_runnable:
  "valid_ready_qs s \<Longrightarrow> st_tcb_at (Not \<circ> runnable) t s \<Longrightarrow> not_queued t s"
  by (clarsimp simp: valid_ready_qs_def not_queued_def tcb_at_kh_simps pred_map_def, fastforce)

crunch not_in_release_q[wp]: reply_remove "\<lambda>s::('state_ext state). not_in_release_q a s"
  (wp: crunch_wps tcb_release_remove_not_in_release_q)

lemma reply_unlink_tcb_ct_in_state:
  "\<lbrace>ct_in_state test and (\<lambda>s. (\<forall>t. reply_tcb_reply_at ((=) (Some t)) r s \<longrightarrow> cur_thread s \<noteq> t \<or> test (Inactive)))\<rbrace>
   reply_unlink_tcb t r
   \<lbrace>\<lambda>_. ct_in_state test :: ('state_ext state) \<Rightarrow> _\<rbrace>"
  unfolding reply_unlink_tcb_def
  apply (wpsimp wp: sts_ctis_neq set_simple_ko_wp gts_wp get_simple_ko_wp)
  apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def reply_at_ppred_def)
  done

lemma reply_remove_valid_sched_misc[wp]:
  "reply_remove caller reply
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (etcbs_of s)
          (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: get_simple_ko_wp simp: reply_remove_def)

lemma reply_remove_ct_in_state:
  "\<lbrace>ct_in_state P and (\<lambda>s. \<forall>t. reply_tcb_reply_at ((=) (Some t)) r s \<longrightarrow> cur_thread s \<noteq> t \<or> P Inactive)\<rbrace>
     reply_remove t r
   \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding reply_remove_def
  apply (wpsimp wp: reply_unlink_tcb_ct_in_state)
  apply (wpsimp wp: ct_in_state_thread_state_lift sched_context_donate_cur_thread
                    hoare_vcg_imp_lift' hoare_vcg_all_lift get_simple_ko_wp | wps)+
  apply (auto simp: ct_in_state_def pred_tcb_at_def obj_at_def)
  done

lemma reply_at_ppred_eq_commute:
  "reply_at_ppred proj ((=) v) = reply_at_ppred proj (\<lambda>x. x = v)"
  by (intro ext) (auto simp: reply_at_ppred_def obj_at_def)

lemmas reply_unlink_tcb_inactive'[wp]
  = reply_unlink_tcb_inactive[unfolded pred_map_eq_normalise obj_at_kh_kheap_simps]

lemma reply_remove_inactive[wp]:
  "\<lbrace>\<top>\<rbrace> reply_remove t r \<lbrace>\<lambda>_. st_tcb_at ((=) Inactive) t\<rbrace>"
  by (wpsimp simp: reply_remove_def)

lemmas reply_remove_inactive'[wp]
  = reply_remove_inactive[unfolded pred_map_eq_normalise obj_at_kh_kheap_simps]

lemma reply_remove_active_if_bound_sc_tcb_at:
  "\<lbrace>\<lambda>s. active_if_bound_sc_tcb_at t s \<and> active_reply_scs s\<rbrace>
   reply_remove t r
   \<lbrace>\<lambda>rv s. active_if_bound_sc_tcb_at t s\<rbrace>"
  unfolding reply_remove_def
  apply (wpsimp wp: sched_context_donate_bound_sc_obj_tcb_at
                    hoare_vcg_if_lift2 hoare_vcg_const_imp_lift
                    hoare_vcg_disj_lift sched_context_donate_bound_sc_tcb_at_None
                    get_tcb_obj_ref_wp get_simple_ko_wp
              simp: reply_remove_def)
  by (elim disjE; clarsimp simp: obj_at_def cong: conj_cong
      ; fastforce dest!: sc_with_reply_SomeD simp: active_reply_scs_defs vs_all_heap_simps)

lemma set_thread_state_idle_thread_is_idle[wp]:
  "\<lbrace>\<lambda>s. if t = idle_thread s then idle st else idle_thread_is_idle s\<rbrace>
   set_thread_state t st
   \<lbrace>\<lambda>rv s. idle_thread_is_idle s\<rbrace>"
  apply (wpsimp wp: set_thread_state_valid_sched_pred)
  by (auto simp: vs_all_heap_simps)

lemma reply_remove_idle_thread_is_idle[wp]:
  "\<lbrace>\<lambda>s.  idle_thread_is_idle s \<and> t \<noteq> idle_thread s\<rbrace> reply_remove t reply \<lbrace>\<lambda>rv s. idle_thread_is_idle s\<rbrace>"
  unfolding reply_remove_def reply_unlink_tcb_def
  by (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?)+ wpsimp

abbreviation (input)
  "do_reply_transfer_pred receiver s
   \<equiv> not_in_release_q receiver s \<and> not_queued receiver s \<and> scheduler_act_not receiver s
      \<and> valid_blocked_except receiver s \<and> valid_sched_except_blocked s
      \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
      \<and> idle_thread_is_idle s
      \<and> receiver \<noteq> idle_thread s
      \<and> active_if_bound_sc_tcb_at receiver s
      \<and> current_time_bounded s"

lemma valid_sched_active_reply_scs[simp,elim!]:
  "valid_sched_2 wk_vsa vbl riq ctime cdom ct it queues rlq sa etcbs tcb_sts tcb_scps tcb_faults sc_refill_cfgs sc_repls
   \<Longrightarrow> active_reply_scs_2 sc_repls sc_refill_cfgs"
  by (simp add: valid_sched_def)

lemma refill_unblock_check_active_if_bound_sc_tcb_at[wp]:
  "refill_unblock_check scp \<lbrace>active_if_bound_sc_tcb_at t\<rbrace>"
  unfolding refill_unblock_check_def refill_head_overlapping_loop_def
  apply (wpsimp wp: whileLoop_wp' set_refills_wp get_refills_wp
              simp: merge_refills_def update_refill_hd_rewrite refill_pop_head_def
                    update_sched_context_set_refills_rewrite)
        apply (erule disjE)
         apply (clarsimp simp: vs_all_heap_simps obj_at_def split: if_split_asm)+
       apply (wpsimp simp: update_refill_hd_rewrite
                       wp: set_refills_wp get_refills_wp gets_wp is_round_robin_wp)+
  apply (erule disjE; fastforce simp: obj_at_def pred_map_eq vs_all_heap_simps)
  done

lemma do_reply_transfer_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> valid_objs s \<and> valid_replies s \<and> valid_idle s \<and> sym_refs (state_refs_of s)
         \<and> current_time_bounded s\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>rv. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: do_reply_transfer_def maybeM_def)
  apply (rule hoare_seq_ext[OF _ grt_sp])
  apply (case_tac recv_opt, wpsimp, clarsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rename_tac receiver state)
  apply (case_tac "\<forall>r'. state \<noteq> BlockedOnReply r'", solves \<open>wpsimp\<close>, clarsimp)
  apply (rule hoare_seq_ext[OF _ assert_sp])
  apply (rule_tac S="r'=reply" in hoare_gen_asm''; clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule_tac B="\<lambda>_ s. valid_sched s
                            \<and> pred_map_eq Inactive (tcb_sts_of s) receiver
                            \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                            \<and> idle_thread_is_idle s
                            \<and> receiver \<noteq> idle_thread s
                            \<and> active_if_bound_sc_tcb_at receiver s
                            \<and> current_time_bounded s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_remove_valid_sched reply_remove_tcb_scps_of_retract
                     reply_remove_active_if_bound_sc_tcb_at)
   apply (apply_conjunct \<open>rule released_ipc_queues_blocked_on_reply_E1[OF valid_sched_released_ipc_queues]\<close>
          ; fastforce simp: vs_all_heap_simps valid_idle_def pred_tcb_at_def obj_at_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext_skip)
   apply (case_tac sc_opt; clarsimp simp: maybeM_def if_cond_refill_unblock_check_def)
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (rule hoare_seq_ext[OF _ gets_sp])
   apply (rule hoare_pre)
    apply (rule hoare_when_weak_wp)
    apply (wpsimp wp: refill_unblock_check_valid_sched)
    apply (erule disjE; clarsimp simp: tcb_at_kh_simps)
     apply (clarsimp simp: pred_map_simps)
    apply (simp add: pred_map_eq_def[symmetric] heap_refs_inv_def2)
    apply (clarsimp simp: pred_map_eq dest!: valid_sched_valid_release_q)
    apply (drule_tac t=t in valid_release_q_not_in_release_q_not_runnable)
     apply (clarsimp simp: tcb_at_kh_simps pred_map_def)
    apply fastforce
   apply clarsimp
  apply (rule hoare_seq_ext[OF _ thread_get_inv])
  \<comment> \<open>valid_blocked might be broken here for receiver\<close>
  apply (rule_tac B="\<lambda>_ s. do_reply_transfer_pred receiver s" in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_thread_state_not_runnable_valid_sched_except_blocked
                     set_thread_state_valid_blocked_const
                     thread_set_fault_valid_sched_pred
               simp: if_distrib)
   apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) receiver", clarsimp simp: vs_all_heap_simps)
   apply (prop_tac "not_queued receiver s"
          , erule valid_ready_qs_contrap[OF valid_sched_valid_ready_qs], simp)
   apply (prop_tac "not_in_release_q receiver s"
          , clarsimp simp: valid_release_q_def in_release_q_def dest!: valid_sched_valid_release_q)
   apply (prop_tac "scheduler_act_not receiver s", clarsimp simp: valid_sched_not_runnable_scheduler_act_not)
   apply (clarsimp simp: valid_sched_def elim!: released_ipc_queuesE)
   apply (clarsimp simp: vs_all_heap_simps heap_upd_def split: if_splits)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rename_tac sc_opt')
  apply (case_tac "runnable state \<longrightarrow> sc_opt' = None"
         ; clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
   apply (wpsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise valid_sched_def)
   apply (fastforce elim!: valid_blockedE' simp: vs_all_heap_simps)
  apply (intro hoare_seq_ext[OF _ get_sched_context_sp]
               hoare_seq_ext[OF _ gets_sp]
               hoare_seq_ext[OF _ gets_the_sp]
               hoare_if)
    apply (wpsimp wp: possible_switch_to_valid_sched_strong)
    apply (clarsimp simp: valid_sched_valid_sched_except_blocked vs_all_heap_simps refill_ready_def obj_at_def)
   apply (wpsimp wp: handle_timeout_valid_sched simp: is_timeout_fault_def)
   apply (simp add: valid_sched_def)
  apply (wpsimp wp: postpone_valid_sched)
  apply (clarsimp simp: heap_refs_inv_def)
  apply (prop_tac "tp = receiver", frule (1) heap_refs_retractD, clarsimp simp: sc_tcbs.pred_map_simps)
  by (clarsimp simp: active_bound_sc_tcb_at vs_all_heap_simps)

lemma handle_no_fault_valid_sched:
  "\<lbrace>valid_sched and not_queued thread and not_in_release_q thread and scheduler_act_not thread\<rbrace>
   handle_no_fault thread
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  unfolding handle_no_fault_def
  by (wpsimp wp: set_thread_state_valid_sched, simp add: valid_sched_def)

lemma handle_fault_valid_sched:
  "\<lbrace>valid_sched and invs and st_tcb_at active thread and scheduler_act_not thread
      and not_queued thread and not_in_release_q thread and released_if_bound_sc_tcb_at thread
      and K (\<not> is_timeout_fault ex)
      and current_time_bounded
      and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))\<rbrace>
   handle_fault thread ex
   \<lbrace>\<lambda>rv. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: handle_fault_def unless_def)
  apply (rule hoare_seq_ext[OF _ gets_the_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule_tac B="\<lambda>_. valid_sched and not_queued thread and not_in_release_q thread and scheduler_act_not thread" in hoare_seq_ext
         , wpsimp wp: handle_no_fault_valid_sched)
  apply (wpsimp wp: send_fault_ipc_valid_sched
                    send_fault_ipc_not_queued send_fault_ipc_not_in_release_q
                    send_fault_ipc_scheduler_act_not
              simp: valid_idle_idle_thread_is_idle[OF invs_valid_idle]
              cong: conj_cong)
  by (auto simp: valid_sched_def obj_at_kh_kheap_simps vs_all_heap_simps
                 pred_neg_def valid_blockedD)

end

lemma idle_not_queued'':
  "\<lbrakk>valid_idle s; sym_refs (state_refs_of s); queue \<times> {rt} \<subseteq> state_refs_of s ptr\<rbrakk> \<Longrightarrow>
     idle_thread s \<in> queue \<longrightarrow> ptr = idle_sc_ptr"
  by (frule idle_only_sc_refs)
     (fastforce simp: valid_idle_def sym_refs_def pred_tcb_at_def obj_at_def state_refs_of_def
                split: option.splits)


context DetSchedSchedule_AI begin

crunches cancel_ipc
  for active_sc_tcb_at: "active_sc_tcb_at t::('state_ext state) \<Rightarrow> _"
  (wp: hoare_drop_imp crunch_wps)

end

lemma set_thread_state_st_tcb_at:
  " P ts \<Longrightarrow>
    \<lbrace>st_tcb_at \<top> tcbptr\<rbrace>
      set_thread_state tcbptr ts
    \<lbrace>\<lambda>rv s. st_tcb_at P tcbptr s\<rbrace>"
  unfolding set_thread_state_def set_thread_state_act_def
  apply (wpsimp wp: is_schedulable_wp set_object_wp)
  apply (auto simp: st_tcb_at_def obj_at_def)
  done

lemma tcb_sched_context_update_active_sc_tcb_at:
  "\<lbrace>is_sc_active sc_ptr\<rbrace>
     set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr)
   \<lbrace>\<lambda>r. active_sc_tcb_at tcb_ptr\<rbrace>"
  unfolding set_tcb_obj_ref_def
  apply (wpsimp wp: set_object_wp)
  by (clarsimp simp: vs_all_heap_simps is_sc_active_kh_simp dest!: get_tcb_SomeD)

lemma sched_context_donate_bound_sc_tcb_at[wp]:
  "\<lbrace>\<top>\<rbrace> sched_context_donate scp tptr \<lbrace>\<lambda>rv. bound_sc_tcb_at ((=) (Some scp)) tptr\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: ssc_bound_tcb_at')

lemma sched_context_donate_sc_tcb_sc_at[wp]:
  "\<lbrace>\<top>\<rbrace> sched_context_donate scp tptr \<lbrace>\<lambda>rv. sc_tcb_sc_at ((=) (Some tptr)) scp\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: sc_tcb_update_sc_tcb_sc_at)

lemma st_in_waitingntfn':
  "kheap s ntfnptr = Some (Notification ntfn) \<Longrightarrow> ntfn_obj ntfn = WaitingNtfn q \<Longrightarrow> valid_objs s
   \<Longrightarrow> sym_refs (state_refs_of s) \<Longrightarrow> t\<in>set q
   \<Longrightarrow> st_tcb_at (\<lambda>x. x = BlockedOnNotification ntfnptr) t s"
  apply (erule (1) valid_objsE)
  apply (clarsimp simp: valid_obj_def valid_ntfn_def)
  apply (erule_tac x = t in ballE)
   apply (clarsimp simp: sym_refs_def)
   apply (erule_tac x = ntfnptr in allE)
   apply (erule_tac x = "(t, NTFNSignal)" in ballE)
    apply (auto simp: state_refs_of_def is_tcb obj_at_def pred_tcb_at_def tcb_st_refs_of_def
                      get_refs_def2
               split: thread_state.splits if_splits)
  done

lemma maybe_donate_sc_valid_sched_misc[wp]:
  "maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace> \<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s) (cur_domain s)
           (cur_thread s) (idle_thread s) (etcbs_of s) (tcb_sts_of s)
           (sc_replies_of s)\<rbrace>"
  unfolding maybe_donate_sc_def
  by (wpsimp wp: hoare_drop_imp)

lemma sched_context_resume_cond_released_sc_tcb_at:
  "\<lbrace>bound_sc_tcb_at ((=) (Some sc_ptr)) tcbptr and sc_tcb_sc_at ((=) (Some tcbptr)) sc_ptr
    and (\<lambda>s. pred_map runnable (tcb_sts_of s) tcbptr)\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>rv s. active_sc_tcb_at tcbptr s \<longrightarrow> not_in_release_q tcbptr s \<longrightarrow> released_sc_tcb_at tcbptr s\<rbrace>"
  unfolding sched_context_resume_def
  apply wpsimp
              apply (rule_tac Q="\<lambda>r. DetSchedInvs_AI.in_release_q tcbptr" in hoare_strengthen_post[rotated])
               apply (clarsimp simp: pred_neg_def not_in_release_q_def in_release_q_def)
              apply (wpsimp wp: postpone_in_release_q is_schedulable_wp
                          simp: thread_get_def)+
  apply (intro conjI; intro allI impI; clarsimp)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def schedulable_def2 vs_all_heap_simps
                  dest!: get_tcb_SomeD)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def schedulable_def2 vs_all_heap_simps
                        sc_at_pred_n_def
                 dest!: get_tcb_SomeD)
  done

lemma maybe_donate_sc_cond_released_sc_tcb_at:
  "\<lbrace>released_if_bound_sc_tcb_at tcbptr and st_tcb_at runnable tcbptr\<rbrace>
     maybe_donate_sc tcbptr ntfnptr
   \<lbrace>\<lambda>rv s. active_sc_tcb_at tcbptr s \<longrightarrow> not_in_release_q tcbptr s \<longrightarrow> released_sc_tcb_at tcbptr s\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac sc_opt; clarsimp)
   apply (rule hoare_seq_ext[OF _ gsc_ntfn_sp])
   apply (wpsimp wp_del: hoare_when_wp)
        apply (wpsimp wp: sched_context_resume_cond_released_sc_tcb_at)
       apply (wpsimp wp: refill_unblock_check_ko_at_SchedContext
                         sched_context_donate_sc_tcb_sc_at sched_context_donate_bound_sc_tcb_at
                    simp: get_sc_obj_ref_def)+
   apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
  apply wpsimp
  apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
  done

lemma maybe_donate_sc_cond_released_if_bound_sc_tcb_at:
  "\<lbrace>released_if_bound_sc_tcb_at tcbptr and st_tcb_at runnable tcbptr\<rbrace>
   maybe_donate_sc tcbptr ntfnptr
   \<lbrace>\<lambda>rv s. active_sc_tcb_at tcbptr s \<longrightarrow> not_in_release_q tcbptr s
            \<longrightarrow> released_if_bound_sc_tcb_at tcbptr s\<rbrace>"
  apply (rule hoare_strengthen_post)
  apply (rule maybe_donate_sc_cond_released_sc_tcb_at)
  by simp

lemma maybe_donate_sc_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills\<rbrace>
   maybe_donate_sc tcbptr ntfnptr
   \<lbrace>\<lambda>rv s. active_sc_valid_refills s\<rbrace>"
  unfolding maybe_donate_sc_def
  by (wpsimp wp: refill_unblock_check_active_sc_valid_refills hoare_drop_imp
                 hoare_vcg_if_lift2)

lemma postpone_ready_or_release[wp]:
  "\<lbrace>ready_qs_etcb_eq and ready_or_release\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  unfolding postpone_def get_sc_obj_ref_def
  by (wpsimp wp: tcb_dequeue_not_queued)+

lemma sched_context_resume_ready_or_release[wp]:
  "\<lbrace>ready_qs_etcb_eq and ready_or_release\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  unfolding sched_context_resume_def
  by (wpsimp wp: thread_get_wp is_schedulable_wp)
     (clarsimp simp: obj_at_def schedulable_def2 pred_tcb_at_def is_tcb)

lemma tcb_sched_enqueue_ready_queues_etcb_eq[wp]:
  "tcb_sched_action tcb_sched_enqueue tp \<lbrace>ready_qs_etcb_eq\<rbrace>"
  unfolding tcb_sched_action_def tcb_sched_enqueue_def get_tcb_queue_def bind_assoc
  by (wpsimp wp: set_tcb_queue_wp thread_get_wp' simp: obj_at_def vs_all_heap_simps)

lemma tcb_sched_dequeue_ready_queues_etcb_eq[wp]:
  "tcb_sched_action tcb_sched_dequeue tp \<lbrace>ready_qs_etcb_eq\<rbrace>"
  unfolding tcb_sched_action_def tcb_sched_dequeue_def get_tcb_queue_def bind_assoc
  by (wpsimp wp: set_tcb_queue_wp thread_get_wp' simp: obj_at_def vs_all_heap_simps)

lemma tcb_sched_append_ready_queues_etcb_eq[wp]:
  "tcb_sched_action tcb_sched_append tp \<lbrace>ready_qs_etcb_eq\<rbrace>"
  unfolding tcb_sched_action_def tcb_sched_append_def get_tcb_queue_def bind_assoc
  by (wpsimp wp: set_tcb_queue_wp thread_get_wp' simp: obj_at_def vs_all_heap_simps)

crunches test_reschedule
  for ready_queues_etcb_eq[wp]: ready_qs_etcb_eq
  (wp: crunch_wps simp: crunch_simps ignore: tcb_sched_action)

lemma sched_context_donate_ready_queues_etcb_eq[wp]:
  "sched_context_donate scp tp \<lbrace>ready_qs_etcb_eq\<rbrace>"
  unfolding sched_context_donate_def by (wpsimp wp: thread_get_wp)

lemma maybe_donate_sc_ready_or_release[wp]:
  "\<lbrace>ready_or_release and ready_qs_etcb_eq\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_. ready_or_release\<rbrace>"
  unfolding maybe_donate_sc_def when_def maybeM_def
  by (wpsimp wp: get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)

lemma maybe_donate_sc_active_reply_scs[wp]:
  "maybe_donate_sc t n \<lbrace>active_reply_scs\<rbrace>"
  unfolding maybe_donate_sc_def
  by (wpsimp wp: get_sk_obj_ref_wp get_tcb_obj_ref_wp)

lemma heap_refs_inv_sc_tcb_sc_at_iff_bound_sc_tcb_at:
  "heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<Longrightarrow>
     sc_tcb_sc_at ((=) (Some t)) scp s \<longleftrightarrow> bound_sc_tcb_at ((=) (Some scp)) t s"
  by (clarsimp simp: sc_at_kh_simps tcb_at_kh_simps heap_refs_inv_def2 pred_map_eq_def)

lemma postpone_not_in_release_q_other:
  "\<lbrace>not_in_release_q t and sc_tcb_sc_at (\<lambda>sc_tcb. sc_tcb \<noteq> Some t) sc_ptr\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  apply (simp add: postpone_def)
  apply (wpsimp wp: get_sc_obj_ref_wp)
  by (simp add: sc_at_ppred_def obj_at_def)

lemma sched_context_resume_in_release_q_not_ready:
  "\<lbrace>not_in_release_q t and active_sc_valid_refills and bound_sc_tcb_at ((=) (Some scp)) t
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))\<rbrace>
    sched_context_resume scp
   \<lbrace>\<lambda>_ s. in_release_q t s
          \<longrightarrow> active_sc_tcb_at t s \<longrightarrow> \<not> budget_ready t s\<rbrace>"
  unfolding sched_context_resume_def assert_opt_def get_sc_refill_sufficient_def bind_assoc
  apply (wpsimp wp: postpone_not_in_release_q_other hoare_vcg_all_lift hoare_vcg_imp_lift'
                    hoare_vcg_disj_lift thread_get_wp' is_schedulable_wp)
  apply (intro conjI impI; clarsimp simp: obj_at_def schedulable_def2)
  apply (prop_tac "is_refill_sufficient 0 scp s")
   apply (erule valid_refills_refill_sufficient[OF active_sc_valid_refillsE[rotated]])
   apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  apply (rename_tac sc n tcb)
  apply (drule_tac scp1=scp in heap_refs_inv_sc_tcb_sc_at_iff_bound_sc_tcb_at[THEN iffD1])
   apply (fastforce simp: sc_tcb_sc_at_def obj_at_def)
  apply (clarsimp simp: vs_all_heap_simps pred_tcb_at_def obj_at_def)
  done

lemma maybe_donate_sc_in_release_q_imp_not_ready:
  "\<lbrace>not_in_release_q tcb_ptr
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and active_sc_valid_refills\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_ s. in_release_q tcb_ptr s
                \<longrightarrow> active_sc_tcb_at tcb_ptr s
                \<longrightarrow> \<not> budget_ready tcb_ptr s\<rbrace>"
  unfolding maybe_donate_sc_def
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rename_tac scopt; case_tac scopt; simp; (wpsimp; fail)?)
  apply (rule hoare_seq_ext[OF _ get_sk_obj_ref_sp])
  apply (rename_tac nsc; case_tac nsc; simp add: maybeM_def)
   apply wpsimp
  apply (rename_tac scp)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (rename_tac tpopt; case_tac tpopt; simp; (wpsimp; fail)?)
  apply (clarsimp cong: conj_cong)
  apply (rule_tac Q="\<lambda>_ s. bound_sc_tcb_at ((=) (Some scp)) tcb_ptr s
                                   \<and> (in_release_q tcb_ptr s
                                              \<longrightarrow> active_sc_tcb_at tcb_ptr s
                                                 \<longrightarrow> \<not> budget_ready tcb_ptr s)"
         in hoare_strengthen_post[rotated], clarsimp)
  apply (wpsimp wp: sched_context_resume_in_release_q_not_ready)
  apply (clarsimp simp: tcb_at_kh_simps pred_map_eq_def)
  done

lemma maybe_donate_sc_schedulable_imp_released:
  "\<lbrace>(\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and active_sc_valid_refills
    and released_if_bound_sc_tcb_at tptr\<rbrace>
    maybe_donate_sc tptr ntfnptr
   \<lbrace>\<lambda>_ s. schedulable tptr s \<longrightarrow> released_sc_tcb_at tptr s\<rbrace>"
  unfolding maybe_donate_sc_def
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rename_tac scopt; case_tac scopt; simp)
   apply (rule hoare_seq_ext[OF _ get_sk_obj_ref_sp])
   apply (rename_tac nsc; case_tac nsc; simp add: maybeM_def)
    apply wpsimp
    apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps schedulable_def2)
   apply (rename_tac scp)
   apply (rule hoare_seq_ext[OF _ gsct_sp])
   apply (rename_tac tpopt; case_tac tpopt; simp; (wpsimp; fail)?)
    apply (clarsimp cong: conj_cong)
    apply (rule_tac Q="\<lambda>_ s. bound_sc_tcb_at ((=) (Some scp)) tptr s
                                     \<and> (schedulable tptr s
                                                \<longrightarrow> budget_ready tptr s)"
           in hoare_strengthen_post[rotated])
     apply (clarsimp simp: schedulable_def2 released_sc_tcb_at_def)
    apply (wpsimp wp: sched_context_resume_schedulable_imp_ready)
   apply wpsimp
   apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps schedulable_def2)
  apply wpsimp
  apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
  done

lemma maybe_donate_sc_heap_refs_retract_sc_tcbs[wp]:
  "maybe_donate_sc tcb_ptr nftn_ptr \<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (wpsimp wp: get_simple_ko_wp
              simp: get_sc_obj_ref_def get_sk_obj_ref_def)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def pred_tcb_at_def)
  done

lemma maybe_donate_sc_heap_refs_retract_tcb_scps[wp]:
  "maybe_donate_sc tcb_pr ntfn_ptr \<lbrace>\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (wpsimp wp: get_simple_ko_wp
              simp: get_sc_obj_ref_def get_sk_obj_ref_def)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def pred_tcb_at_def)
  done

lemma
  shows maybe_donate_sc_heap_refs_inv_tcb_scps[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   maybe_donate_sc tcb_pr ntfn_ptr
   \<lbrace>\<lambda>_ s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<rbrace>"
  and maybe_donate_sc_heap_refs_inv_sc_tcbs[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   maybe_donate_sc tcb_pr ntfn_ptr
   \<lbrace>\<lambda>_ s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  by (wpsimp simp: heap_refs_inv_def pred_map_eq tcb_at_kh_simps pred_map_simps)+

context DetSchedSchedule_AI begin

lemma send_signal_WN_sym_refs_helper:
  "sym_refs (\<lambda>a. if a = tptr
                 then tcb_non_st_state_refs_of s tptr
                 else state_refs_of s a)
   \<Longrightarrow> heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)"
  apply (clarsimp simp: heap_refs_retract_def heap_refs_retract_at_def)
  apply (clarsimp simp: sym_refs_def)
  apply (drule_tac x=p in spec)
  apply (subgoal_tac "(p, symreftype TCBSchedContext) \<in> (if r = tptr then tcb_non_st_state_refs_of s tptr
              else state_refs_of s r)")
   apply (clarsimp split: if_split)
   apply (thin_tac "\<forall>x\<in>if p = tptr then tcb_non_st_state_refs_of s tptr else state_refs_of s p.
                    case x of (y, tp) \<Rightarrow> (p, symreftype tp) \<in> (if y = tptr then
                    tcb_non_st_state_refs_of s tptr else state_refs_of s y)")
   apply (clarsimp split: if_splits option.splits simp: state_refs_of_def refs_of_def vs_all_heap_simps)
   apply (case_tac x2; clarsimp simp: get_refs_def split: option.splits)
  apply (subgoal_tac "(r, TCBSchedContext) \<in> (if p = tptr
                       then tcb_non_st_state_refs_of s tptr
                       else state_refs_of s p)")
   apply fastforce
  apply (fastforce split: if_split option.split simp: state_refs_of_def refs_of_def vs_all_heap_simps)
  done

lemma send_signal_WaitingNtfn_helper:
  "ntfn_obj ntfn = WaitingNtfn wnlist \<Longrightarrow>
   \<lbrace>ko_at (Notification ntfn) ntfnptr and
    st_tcb_at ((=) (BlockedOnNotification ntfnptr)) (hd wnlist) and
    valid_sched and invs and
    current_time_bounded\<rbrace>
   update_waiting_ntfn ntfnptr wnlist (ntfn_bound_tcb ntfn) (ntfn_sc ntfn) badge
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding update_waiting_ntfn_def if_cond_refill_unblock_check_def
  apply (wpsimp wp: refill_unblock_check_valid_sched get_tcb_obj_ref_wp)
          apply (rename_tac tcbptr x2 sched)
          apply (rule_tac Q="\<lambda>_ s. (valid_sched s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                                    \<and> current_time_bounded s
                                    \<and> pred_map bound (tcb_scps_of s) tcbptr
                                    \<and> st_tcb_at runnable tcbptr s
                                    \<and> schedulable tcbptr s)"
                 in hoare_strengthen_post[rotated])
           apply clarsimp
           apply (rename_tac scp sc n tp)
           apply (prop_tac "heap_ref_eq scp tcbptr (tcb_scps_of s)")
            apply (clarsimp simp: obj_at_def tcb_at_kh_simps vs_all_heap_simps)
           apply (clarsimp simp: heap_refs_inv_def2 tcb_at_kh_simps obj_at_def vs_all_heap_simps)
           apply (clarsimp simp: schedulable_def2)
          apply (wpsimp wp: possible_switch_to_valid_sched_strong
                      simp: schedulable_def2)
         apply (wpsimp wp: is_schedulable_wp)+
        apply (rename_tac tcbptr x)
        apply (rule_tac Q="\<lambda>_ s. current_time_bounded s \<and>
                                 (in_release_q tcbptr s
                                  \<longrightarrow> active_sc_tcb_at tcbptr s \<longrightarrow> \<not> budget_ready tcbptr s) \<and>
                                 (active_sc_tcb_at tcbptr s
                                  \<longrightarrow> not_in_release_q tcbptr s \<longrightarrow> released_sc_tcb_at tcbptr s) \<and>
                                 heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<and> tcbptr \<noteq> idle_thread s \<and>
                                 valid_sched_except_blocked s \<and> valid_blocked_except tcbptr s"
               in hoare_strengthen_post[rotated])
         apply (case_tac "schedulable tcbptr s"; clarsimp; rule conjI;
                clarsimp simp: tcb_at_kh_simps valid_sched_valid_sched_except_blocked cong: conj_cong)
            apply (clarsimp simp: schedulable_def2 tcb_at_kh_simps)
           apply (clarsimp simp: schedulable_def2 vs_all_heap_simps obj_at_def)
          apply (clarsimp dest!: valid_blocked_except_set_not_schedulable)
          apply (rename_tac scp sc n t)
          apply (prop_tac "heap_ref_eq scp tcbptr (tcb_scps_of s)")
           apply (clarsimp simp: vs_all_heap_simps obj_at_def)
          apply (clarsimp simp: vs_all_heap_simps obj_at_def heap_refs_inv_def2)
         apply (intro conjI impI; clarsimp?)
          apply (clarsimp dest!: valid_blocked_except_set_not_schedulable)
          apply (clarsimp simp: vs_all_heap_simps obj_at_def schedulable_def2)
         apply (clarsimp simp: vs_all_heap_simps obj_at_def tcb_at_kh_simps
                        dest!: valid_blocked_except_set_no_sc_bound_sum)
        apply (wpsimp wp: maybe_donate_sc_in_release_q_imp_not_ready
                          maybe_donate_sc_cond_released_sc_tcb_at maybe_donate_sc_schedulable_imp_released
                          maybe_donate_sc_valid_ready_qs maybe_donate_sc_valid_release_q
                          maybe_donate_sc_valid_sched_action maybe_donate_sc_released_ipc_queues
                          maybe_donate_sc_valid_blocked_except_set maybe_donate_sc_ct_in_cur_domain
                    simp: valid_sched_def)
       apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
      apply (rename_tac x xa t x2 xb)
      apply (rule_tac Q="\<lambda>_ s. (valid_sched_except_blocked s \<and> valid_blocked_except_set {t} s)
                                \<and> not_queued t s \<and> t \<noteq> idle_thread s
                                \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                                \<and> valid_objs s \<and> current_time_bounded s
                                \<and> pred_map runnable (tcb_sts_of s) t \<and> scheduler_act_not t s
                                \<and> not_in_release_q t s \<and> ready_qs_etcb_eq s
                                \<and> released_if_bound_sc_tcb_at t s"
             in hoare_strengthen_post[rotated])
       apply (clarsimp simp: valid_sched_def tcb_at_kh_simps pred_map_def)
       apply (case_tac y; simp)
      apply (rule hoare_vcg_conj_lift)
       apply (rule set_thread_state_break_valid_sched[simplified pred_conj_def])
      apply (wpsimp wp: set_thread_state_pred_map_tcb_sts_of)
     apply simp
     apply wpsimp
    apply wpsimp
   apply (wpsimp wp: assert_inv)
  apply (clarsimp simp: valid_sched_def invs_valid_objs)
  apply (intro conjI; simp add: pred_tcb_at_eq_commute)
       apply (clarsimp simp: pred_tcb_at_def obj_at_def
                      elim!: valid_ready_qs_not_queued_not_runnable)
      apply (fastforce dest: st_tcb_at_idle_thread)
     apply (subgoal_tac "valid_ntfn ntfn s")
      apply (clarsimp simp: valid_ntfn_def split: list.splits option.splits)
      apply (case_tac wnlist; simp)
     apply (frule invs_valid_objs, fastforce simp: pred_tcb_at_def valid_objs_def dom_def obj_at_def valid_obj_def)
    apply (rule valid_sched_not_runnable_scheduler_act_not; clarsimp simp: valid_sched_def tcb_at_kh_simps pred_map_def)
   apply (rule valid_sched_not_runnable_not_in_release_q; clarsimp simp: valid_sched_def tcb_at_kh_simps pred_map_def)
  apply (prop_tac "ipc_queued_thread (hd wnlist) s", simp add: tcb_at_kh_simps pred_map_def)
  apply (rule released_ipc_queues_blocked_on_recv_ntfn_D, simp)
  by (fastforce elim: pred_map_weakenE simp: tcb_at_kh_simps is_blocked_thread_state_defs)

lemma cancel_signal_valid_sched:
  "\<lbrace>valid_sched and st_tcb_at (Not \<circ> runnable) tcbptr\<rbrace>
      cancel_signal tcbptr ntfnptr
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  unfolding cancel_signal_def
  apply (wpsimp wp: set_thread_state_valid_sched
                    set_object_wp get_simple_ko_wp)
  apply (strengthen valid_sched_not_runnable_scheduler_act_not
                    valid_sched_not_runnable_not_in_release_q
                    valid_sched_not_runnable_not_queued)
  by (clarsimp simp: valid_sched_def tcb_at_kh_simps pred_map_def)

lemma blocked_cancel_ipc_BOR_valid_sched':
  "\<lbrace>valid_sched and st_tcb_at (\<lambda>ts. \<not> runnable ts) tcbptr\<rbrace>
      blocked_cancel_ipc (BlockedOnReceive ep r pl) tcbptr r
   \<lbrace>\<lambda>rv s. valid_sched (s :: ('state_ext state))\<rbrace>"
  unfolding blocked_cancel_ipc_def
  apply (wpsimp simp: get_thread_state_def get_blocking_object_def thread_get_def
                  wp: set_thread_state_valid_sched
                      reply_unlink_tcb_valid_sched get_simple_ko_wp)
           apply (rule_tac Q="\<lambda>r s. valid_sched s \<and> scheduler_act_not tcbptr s
                                    \<and> st_tcb_at (\<lambda>ts. \<not> runnable ts) tcbptr s"
                        in hoare_strengthen_post[rotated])
            apply (clarsimp simp: valid_sched_def)
            apply (intro conjI)
             apply (erule valid_ready_qs_not_queued_not_runnable)
             apply (clarsimp simp: st_tcb_at_def obj_at_def)
            apply (erule valid_release_q_not_in_release_q_not_runnable)
            apply (simp add: vs_all_heap_simps obj_at_kh_kheap_simps)
           apply (wpsimp simp: get_blocking_object_def
                           wp: get_simple_ko_wp reply_unlink_tcb_valid_sched)+
        apply (wpsimp wp: hoare_vcg_const_imp_lift hoare_vcg_all_lift hoare_drop_imp set_object_wp
                    simp: set_simple_ko_def get_blocking_object_def)+
  apply (clarsimp simp: scheduler_act_not_def valid_sched_def valid_sched_action_def
                        weak_valid_sched_action_2_def st_tcb_at_def obj_at_def)
  apply (intro conjI impI)
     apply (erule valid_ready_qs_not_queued_not_runnable)
     apply (clarsimp simp: st_tcb_at_def obj_at_def)
    apply (erule valid_release_q_not_in_release_q_not_runnable)
    apply (simp add: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply (clarsimp simp: scheduler_act_not_def valid_sched_def valid_sched_action_def
                         weak_valid_sched_action_2_def st_tcb_at_def obj_at_def vs_all_heap_simps)+
  done

lemma blocked_cancel_ipc_BOR_st_tcb_at_not_runnable[wp]:
  "\<lbrace>tcb_at tcbptr\<rbrace>
      blocked_cancel_ipc (BlockedOnReceive ep r pl) tcbptr r
   \<lbrace>\<lambda>rv s. st_tcb_at (\<lambda>ts. \<not> runnable ts) tcbptr s\<rbrace>"
  unfolding blocked_cancel_ipc_def
  by (wpsimp wp: hoare_drop_imps)

lemma valid_ep_remove1_SendEP:
  "valid_ep (SendEP q) s \<Longrightarrow> valid_ep (case remove1 tp q of
                                              [] \<Rightarrow> IdleEP
                                      | a # list \<Rightarrow> update_ep_queue (SendEP q) (remove1 tp q)) s"
  apply (clarsimp simp: valid_ep_def)
  apply (case_tac "remove1 tp q"; simp)
  apply (subgoal_tac "set (remove1 tp q) \<subseteq> set q")
   apply (subgoal_tac "distinct (remove1 tp q)")
    apply (intro allI impI conjI; clarsimp?)
    apply fastforce
   apply (rule distinct_remove1, clarsimp)
  apply (rule set_remove1_subset)
  done

lemma valid_ep_remove1_RecvEP:
  "valid_ep (RecvEP q) s \<Longrightarrow> valid_ep (case remove1 tp q of
                                              [] \<Rightarrow> IdleEP
                                      | a # list \<Rightarrow> update_ep_queue (RecvEP q) (remove1 tp q)) s"
  apply (clarsimp simp: valid_ep_def)
  apply (case_tac "remove1 tp q"; simp)
  apply (subgoal_tac "set (remove1 tp q) \<subseteq> set q")
   apply (subgoal_tac "distinct (remove1 tp q)")
    apply (intro allI impI conjI; clarsimp?)
    apply fastforce
   apply (rule distinct_remove1, clarsimp)
  apply (rule set_remove1_subset)
  done

lemma valid_objs_ep_update:
  "\<lbrakk>ep_at epptr s; valid_ep ep s; valid_objs s\<rbrakk> \<Longrightarrow> valid_objs (s\<lparr>kheap := kheap s(epptr \<mapsto> Endpoint ep)\<rparr>)"
  apply (clarsimp simp: valid_objs_def dom_def
                 elim!: obj_atE)
  apply (intro conjI impI)
   apply (rule valid_obj_same_type)
      apply (simp add: valid_obj_def)+
   apply (clarsimp simp: a_type_def is_ep)
  apply clarsimp
  apply (rule valid_obj_same_type)
     apply (drule_tac x=ptr in spec, simp)
    apply (simp add: valid_obj_def)
   apply assumption
  apply (clarsimp simp add: a_type_def is_ep)
  done

lemma cancel_ipc_valid_sched_misc[wp]:
  "cancel_ipc t
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s)
                            (idle_thread s) (ready_queues s) (release_queue s)
          (etcbs_of s) (tcb_scps_of s) (sc_refill_cfgs_of s)\<rbrace>"
  by (wpsimp wp: gts_wp' simp: cancel_ipc_def)

lemma suspend_valid_sched_misc[wp]:
  "suspend t
   \<lbrace>\<lambda>s. P (cur_domain s) (cur_thread s) (idle_thread s) (etcbs_of s) (tcb_scps_of s)
          (sc_refill_cfgs_of s) (cur_time s) (cur_sc s) (consumed_time s) (cur_sc s)\<rbrace>"
  apply (clarsimp simp: suspend_def sched_context_cancel_yield_to_def)
  apply (rule hoare_seq_ext_skip, wpsimp simp: update_restart_pc_def)+
  by wpsimp

end

lemma sts_cancel_ipc_Running_invs:
  "\<lbrace>st_tcb_at ((=) Running or (=) Inactive or (=) Restart or (=) IdleThreadState) t
        and invs and ex_nonz_cap_to t and fault_tcb_at ((=) None) t\<rbrace>
    set_thread_state t Running
   \<lbrace>\<lambda>rv. invs\<rbrace>"
  apply (wp sts_invs_minor2)
  apply clarsimp
  apply (auto elim!: pred_tcb_weakenE
           notE [rotated, OF _ idle_no_ex_cap]
           simp: invs_def valid_state_def valid_pspace_def)
  done

lemma cancel_ipc_invs_st_tcb_at:
  "\<lbrace>invs\<rbrace> cancel_ipc t
   \<lbrace>\<lambda>rv. invs and st_tcb_at ((=) Running or (=) Inactive or (=) Restart or
                             (=) IdleThreadState) t
              and fault_tcb_at ((=) None) t\<rbrace>"
  by (wpsimp simp: invs_def valid_state_def valid_pspace_def
               wp: cancel_ipc_simple_except_awaiting_reply)

lemma set_thread_state_running_not_ipc_queued_thread:
  "\<lbrace> \<top> \<rbrace>
   set_thread_state tcbptr Running
   \<lbrace>\<lambda>_. not_ipc_queued_thread tcbptr\<rbrace>"
  by (wpsimp simp: vs_all_heap_simps set_thread_state_def wp: set_object_wp)

lemma set_thread_state_pred_map_eq[wp]:
  "\<lbrace>\<top>\<rbrace> set_thread_state t st \<lbrace>\<lambda>_ s. pred_map_eq st (tcb_sts_of s) t\<rbrace>"
  by (wpsimp wp: valid_sched_wp simp: vs_all_heap_simps)

crunches schedule_tcb
  for valid_sched[wp]: valid_sched
  (wp: reschedule_valid_sched_const)

crunches maybe_return_sc
  for etcbs_of[wp]: "\<lambda>s. P (etcbs_of s)"
  (simp: wp: hoare_drop_imp hoare_vcg_if_lift2 ignore: set_tcb_obj_ref)

(* FIXME RT: move somewhere appropriate *)
lemma tcb_sc_refill_cfgs_upd:
  "tcb_sc_refill_cfgs_2 (\<lambda>a. if a = tptr then Some None else tcb_scps_of s a) (sc_refill_cfgs_of s)
   = (\<lambda>a. if a = tptr then None else tcb_sc_refill_cfgs_2 (tcb_scps_of s) (sc_refill_cfgs_of s) a)"
  unfolding tcb_sc_refill_cfgs_2_def
  by (fastforce simp: map_join_def vs_all_heap_simps opt_map_def)

(* FIXME RT: move somewhere appropriate *)
lemma sc_ready_times_upd:
  "sc_ready_times_2 (\<lambda>a. if a = tptr then None else tcb_sc_refill_cfgs_of s a)
   = (\<lambda>a. if a = tptr then None else sc_ready_times_2 (tcb_sc_refill_cfgs_of s) a)"
  unfolding sc_ready_times_2_def
  by (clarsimp simp: map_project_upd)

(* FIXME RT: move somewhere appropriate, maybe rename *)
lemma sorted_release_q_heap_upd_idem:
  "not_in_release_q tptr s \<Longrightarrow>
   sorted_release_q_2 (\<lambda>a. if a = tptr then None else tcb_sc_refill_cfgs_of s a) (release_queue s)
   = sorted_release_q_2 (tcb_sc_refill_cfgs_of s) (release_queue s)"
  by (rule sorted_release_q_2_eq_lift, clarsimp simp: in_release_q_def sc_ready_times_upd)

lemma maybe_return_sc_valid_sched[wp]:
  "\<lbrace> valid_sched and scheduler_act_not tptr and not_queued tptr and not_in_release_q tptr\<rbrace>
   maybe_return_sc ntfnptr tptr
   \<lbrace> \<lambda>_. valid_sched\<rbrace>"
  apply (simp add: maybe_return_sc_def assert_opt_def)
  apply (wpsimp wp: reschedule_valid_sched_const valid_sched_wp get_tcb_obj_ref_wp
                    get_sk_obj_ref_wp)
  apply (clarsimp simp: valid_sched_def)
  apply (intro conjI)
      apply (clarsimp simp: valid_ready_qs_def vs_all_heap_simps not_queued_def)
     apply (clarsimp simp: valid_release_q_def vs_all_heap_simps not_in_release_q_def)
     apply (intro conjI)
      apply clarsimp
     apply (clarsimp simp: tcb_sc_refill_cfgs_upd
            , subst sorted_release_q_heap_upd_idem
            , clarsimp simp: not_in_release_q_def
            , simp)
    apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                          scheduler_act_not_def)
   apply (fastforce simp: valid_blocked_defs vs_all_heap_simps)
  apply (clarsimp simp: released_ipc_queues_defs vs_all_heap_simps)
  done

lemma maybe_return_sc_released_if_bound_sc_tcb_at[wp]:
  "maybe_return_sc a b \<lbrace>released_if_bound_sc_tcb_at thread\<rbrace>"
  unfolding maybe_return_sc_def
  apply (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
  by (fastforce simp: pred_map_def pred_map_eq_def vs_all_heap_simps obj_at_def)

lemma maybe_donate_sc_valid_blocked:
  "\<lbrace>valid_blocked and not_queued tcb_ptr and scheduler_act_not tcb_ptr
    and (\<lambda>s. tcb_ptr = cur_thread s)\<rbrace>
   maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace>\<lambda>_. valid_blocked\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  by (wpsimp wp: sched_context_donate_valid_blocked
                 get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)

lemma maybe_donate_sc_valid_sched:
  "\<lbrace>valid_sched and not_queued tcb_ptr
    and scheduler_act_not tcb_ptr
    and not_in_release_q tcb_ptr and st_tcb_at runnable tcb_ptr
    and (\<lambda>s. tcb_ptr = cur_thread s)\<rbrace>
   maybe_donate_sc tcb_ptr ntfnptr
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  by (wpsimp wp: maybe_donate_sc_valid_ready_qs maybe_donate_sc_valid_release_q
                 maybe_donate_sc_valid_sched_action
                 maybe_donate_sc_ct_in_cur_domain maybe_donate_sc_valid_blocked
                 maybe_donate_sc_released_ipc_queues'
                 maybe_donate_sc_active_reply_scs
           simp: valid_sched_def)
     (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps,
      rename_tac tcb; case_tac "tcb_state tcb"; simp)

crunches do_nbrecv_failed_transfer
  for valid_sched[wp]: "valid_sched"

crunches sched_context_resume
  for sc_tcb_sc_at[wp]: "\<lambda>s. Q (sc_tcb_sc_at P p s)"
    (wp: crunch_wps simp: crunch_simps)

lemma complete_signal_valid_sched:
  "\<lbrace>valid_sched and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and not_queued tcb_ptr
    and scheduler_act_not tcb_ptr and current_time_bounded
    and not_in_release_q tcb_ptr and st_tcb_at runnable tcb_ptr
    and (\<lambda>s. tcb_ptr = cur_thread s)\<rbrace>
   complete_signal ntfn_ptr tcb_ptr
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding complete_signal_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac "ntfn_obj ntfn"; (solves wpsimp)?, clarsimp?)
  apply (subst bind_assoc[symmetric])
  apply (subst bind_assoc[symmetric])
  apply (rule_tac B="\<lambda>_ s. valid_sched s  \<and> current_time_bounded s
                           \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> (in_release_q tcb_ptr s
                                \<longrightarrow> active_sc_tcb_at tcb_ptr s
                                   \<longrightarrow> \<not> budget_ready tcb_ptr s)"
         in hoare_seq_ext)
   apply (rule hoare_seq_ext[OF _ gsc_sp])
   apply (rename_tac tcbsc)
   apply (case_tac tcbsc; simp add: maybeM_def)
    apply wpsimp
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (wpsimp wp: refill_unblock_check_valid_sched get_sk_obj_ref_wp)
   apply (drule sym[of "Some _"], simp)
   apply (prop_tac "heap_ref_eq a tcb_ptr (tcb_scps_of s)")
    apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
   apply (fastforce simp: heap_refs_inv_def2 vs_all_heap_simps opt_map_red tcb_at_kh_simps obj_at_def)
  apply (wpsimp wp: maybe_donate_sc_valid_sched maybe_donate_sc_in_release_q_imp_not_ready)
  done

lemma refill_unblock_check_ko_at_endoint[wp]:
  "refill_unblock_check sc_ptr \<lbrace>\<lambda>s. ko_at (Endpoint ep) ep_ptr s\<rbrace>"
  apply (clarsimp simp: refill_unblock_check_def refill_head_overlapping_loop_def)
  by (wpsimp wp: get_refills_wp set_refills_wp is_round_robin_wp whileLoop_wp'
           simp: merge_refills_def update_refill_hd_rewrite refill_pop_head_def
                 update_sched_context_set_refills_rewrite obj_at_def)

context DetSchedSchedule_AI begin

lemma send_signal_BOR_helper:
  "ntfn_obj ntfn = IdleNtfn
   \<Longrightarrow> ntfn_bound_tcb ntfn = Some tcbptr
   \<Longrightarrow> \<lbrace>st_tcb_at ((=) (BlockedOnReceive ep r_opt pl)) tcbptr and
        valid_sched and (\<lambda>s. tcbptr \<noteq> idle_thread s) and invs
        and current_time_bounded\<rbrace>
         do y <- cancel_ipc tcbptr;
            y <- set_thread_state tcbptr Running;
            y <- as_user tcbptr (setRegister badge_register badge);
            y <- maybe_donate_sc tcbptr ntfnptr;
            schedulable <- is_schedulable tcbptr;
            y \<leftarrow> when schedulable (possible_switch_to tcbptr);
            get_tcb_obj_ref tcb_sched_context tcbptr >>=
            if_sporadic_active_cur_sc_assert_refill_unblock_check
         od
       \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding if_cond_refill_unblock_check_def
  apply (rule_tac B="\<lambda>_. released_if_bound_sc_tcb_at tcbptr
                          and scheduler_act_not tcbptr
                          and not_queued tcbptr
                          and not_in_release_q tcbptr
                          and valid_sched
                          and (\<lambda>s. tcbptr \<noteq> idle_thread s)
                          and st_tcb_at (\<lambda>st'. tcb_st_refs_of st' = {}) tcbptr
                          and invs
                          and current_time_bounded"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: hoare_vcg_ex_lift cancel_ipc_no_refs)
   apply (clarsimp simp: valid_sched_def invs_sym_refs invs_valid_objs)
   apply (intro conjI)
      apply (rule released_ipc_queues_blocked_on_recv_ntfn_D, simp)
      apply (fastforce elim: pred_map_weakenE simp: tcb_at_kh_simps is_blocked_thread_state_defs)
     apply (rule weak_valid_sched_action_scheduler_action_not)
      apply (erule valid_sched_action_weak_valid_sched_action)
     apply (simp add: pred_tcb_at_def obj_at_def)
     using runnable.simps apply metis
    apply (erule valid_ready_qs_not_queued_not_runnable)
    apply (simp add: pred_tcb_at_def obj_at_def)
    using runnable.simps apply metis
   apply (erule valid_release_q_not_in_release_q_not_runnable)
   apply (simp add: pred_tcb_at_def obj_at_def)
   using runnable.simps apply metis
  apply (rule_tac B="\<lambda>_. released_if_bound_sc_tcb_at tcbptr
                          and scheduler_act_not tcbptr
                          and not_queued tcbptr
                          and not_in_release_q tcbptr
                          and valid_sched_except_blocked
                          and valid_blocked_except tcbptr
                          and (\<lambda>s. tcbptr \<noteq> idle_thread s)
                          and valid_objs and (\<lambda>s. sym_refs (state_refs_of s))
                          and (\<lambda>s. pred_map_eq Running (tcb_sts_of s) tcbptr)
                          and current_time_bounded"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_thread_state_runnable_valid_sched_except_blocked
                     set_thread_state_valid_blocked)
    apply (clarsimp simp: valid_sched_def invs_valid_objs obj_at_kh_kheap_simps vs_all_heap_simps
                          tcb_non_st_state_refs_of_state_refs_of[rotated] if_fun_simp)
   apply (wpsimp wp: refill_unblock_check_valid_sched get_tcb_obj_ref_wp)
       apply (rename_tac sched)
       apply (rule_tac Q="\<lambda>_ s. (valid_sched s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                                   \<and> current_time_bounded s
                                   \<and> pred_map bound (tcb_scps_of s) tcbptr
                                   \<and> st_tcb_at runnable tcbptr s
                                   \<and> schedulable tcbptr s)"
              in hoare_strengthen_post[rotated])
        apply clarsimp
        apply (rename_tac scp sc n t)
        apply (prop_tac "heap_ref_eq scp tcbptr (tcb_scps_of s)")
         apply (clarsimp simp: obj_at_def vs_all_heap_simps)
        apply (clarsimp simp: heap_refs_inv_def2 vs_all_heap_simps schedulable_def2)
       apply (wpsimp wp: possible_switch_to_valid_sched_strong
                   simp: schedulable_def2)
      apply (wpsimp wp: is_schedulable_wp')+
     apply (rule_tac Q="\<lambda>r s. tcbptr \<noteq> idle_thread s
                              \<and> valid_sched_except_blocked s \<and> valid_blocked_except_set {tcbptr} s
                              \<and> (schedulable tcbptr s \<longrightarrow> released_sc_tcb_at tcbptr s)
                              \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s) \<and> current_time_bounded s
                              \<and> (in_release_q tcbptr s \<longrightarrow> active_sc_tcb_at tcbptr s \<longrightarrow> \<not> budget_ready tcbptr s)"
                  in hoare_strengthen_post[rotated])
      apply (clarsimp simp: schedulable_def2 tcb_at_kh_simps)
      apply (intro conjI; clarsimp simp: valid_sched_valid_sched_except_blocked)
       apply (intro conjI impI allI; clarsimp elim!: valid_blocked_except_set_not_schedulable simp: schedulable_def2 tcb_at_kh_simps)
       apply (prop_tac "active_sc_tcb_at tcbptr s")
        apply (clarsimp simp: obj_at_def vs_all_heap_simps)
       apply clarsimp
       apply (prop_tac "heap_ref_eq x tcbptr (tcb_scps_of s)", clarsimp simp: vs_all_heap_simps obj_at_def)
       apply (clarsimp simp: heap_refs_inv_def2 vs_all_heap_simps obj_at_def)
       apply (rotate_tac 6)
       apply (drule_tac x=x in spec, clarsimp)
      apply (intro conjI; clarsimp)
       apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
      apply (prop_tac "valid_blocked s")
       apply (clarsimp elim!: valid_blocked_except_set_no_sc_bound_sum
                        simp: vs_all_heap_simps tcb_at_kh_simps obj_at_def)
      apply (clarsimp simp: vs_all_heap_simps obj_at_def)
     apply (wpsimp wp: maybe_donate_sc_in_release_q_imp_not_ready
                       maybe_donate_sc_cond_released_sc_tcb_at maybe_donate_sc_schedulable_imp_released
                       maybe_donate_sc_valid_ready_qs maybe_donate_sc_valid_release_q
                       maybe_donate_sc_valid_sched_action maybe_donate_sc_released_ipc_queues
                       maybe_donate_sc_valid_blocked_except_set maybe_donate_sc_ct_in_cur_domain
                 simp: valid_sched_def)
    apply wpsimp
    apply (wpsimp cong: conj_cong simp: obj_at_kh_kheap_simps
                    wp: hoare_vcg_all_lift hoare_vcg_conj_lift hoare_vcg_imp_lift')
   apply (clarsimp simp: valid_sched_def)
   apply (clarsimp simp: valid_sched_def obj_at_kh_kheap_simps vs_all_heap_simps
                  dest!: valid_ready_qs_etcb_eq)
   done

(* what can we say about ntfn_bound_tcb? can we say it is not equal to idle_thread or cur_thread? *)
lemma send_signal_valid_sched:
  "\<lbrace>valid_sched and invs and current_time_bounded\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_signal_def
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (case_tac "ntfn_obj ntfn"; clarsimp)
    apply (case_tac "ntfn_bound_tcb ntfn"; clarsimp)
     apply wpsimp
    apply (rule hoare_seq_ext[OF _ gts_sp])
    apply (case_tac st; clarsimp simp: receive_blocked_def)
           prefer 4
           apply (rename_tac ep r_opt pl)
           apply (rule hoare_weaken_pre)
           apply (rule_tac ep = ep and r_opt = r_opt in send_signal_BOR_helper; simp)
           apply (clarsimp simp: pred_conj_def pred_tcb_at_def pred_tcb_at_eq_commute obj_at_def
                          split: option.splits)
           apply (drule invs_valid_idle, clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def)
           apply fastforce
          prefer 8
           apply (rename_tac queue)
          apply (wpsimp wp: send_signal_WaitingNtfn_helper)
          apply (subgoal_tac "queue \<noteq> [] \<and> tcb_at (hd queue) s")
             apply (subgoal_tac "(ntfnptr, TCBSignal) \<in> state_refs_of s (hd queue)")
              apply (clarsimp simp: pred_tcb_at_eq_commute st_tcb_at_refs_of_rev(4)[symmetric] obj_at_def
                                    state_refs_of_def)
             apply (rule sym_refsE)
              apply (rule invs_sym_refs, simp)
             apply (clarsimp simp: state_refs_of_def obj_at_def)
          apply (subgoal_tac "valid_ntfn ntfn s")
           apply (clarsimp simp: valid_ntfn_def)
          apply (fastforce simp: invs_def valid_state_def valid_pspace_def valid_objs_def valid_obj_def
                                dom_def obj_at_def)
         apply (wpsimp+)[8]
  done

lemma receive_ipc_preamble_valid_sched:
  "\<lbrace>valid_sched and invs\<rbrace>
    receive_ipc_preamble reply_cap thread
   \<lbrace>\<lambda>rv. valid_sched\<rbrace>"
  by (wpsimp simp: receive_ipc_preamble_def invs_valid_objs
               wp: cancel_ipc_valid_sched weak_if_wp get_sk_obj_ref_inv)

(* FIXME: Move to Finalise_AI *)
lemma cancel_ipc_st_tcb_at_not_blocked:
  assumes "\<And>r. \<not> P (P' (BlockedOnReply r))"
  assumes "\<And>ep r pl. \<not> P (P' (BlockedOnReceive ep r pl))"
  assumes "\<And>ep data. \<not> P (P' (BlockedOnSend ep data))"
  assumes "\<And>ntfn. \<not> P (P' (BlockedOnNotification ntfn))"
  shows "cancel_ipc t \<lbrace>\<lambda>s. P (st_tcb_at P' t' s)\<rbrace>"
  apply (wpsimp wp: cancel_ipc_st_tcb_at)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  by (case_tac "tcb_state tcb"; clarsimp simp: assms)

(* FIXME: Move to Finalise_AI *)
lemmas cancel_ipc_st_tcb_at_active[wp]
  = cancel_ipc_st_tcb_at_not_blocked[of id active, simplified]

(* FIXME: move to IpcDet_AI *)
lemma receive_ipc_preamble_lift:
  assumes "\<And>t. cancel_ipc t \<lbrace>P\<rbrace>"
  shows "receive_ipc_preamble reply_cap thread \<lbrace>P\<rbrace>"
  by (wpsimp simp: receive_ipc_preamble_def wp: assms)

crunches receive_ipc_preamble
  for cur_thread[wp]: "(\<lambda>s. P (cur_thread s))"
  and not_queued[wp]: "not_queued thread "
  and not_in_release_q[wp]: "not_in_release_q thread"
  and scheduler_act_not[wp]: "scheduler_act_not thread"
  (wp: hoare_drop_imps)

crunches receive_ipc_preamble
  for released_if_bound[wp]: "released_if_bound_sc_tcb_at t"
  (ignore: thread_set update_sched_context wp: crunch_wps)

(* Preconditions for the guts of receive_ipc, after the reply preamble *)
abbreviation (input) receive_ipc_valid_sched_preconds ::
  "obj_ref \<Rightarrow> obj_ref \<Rightarrow> cap \<Rightarrow> obj_ref option \<Rightarrow> endpoint \<Rightarrow> ('state_ext state \<Rightarrow> bool) \<Rightarrow> 'state_ext state \<Rightarrow> bool"
  where
  "receive_ipc_valid_sched_preconds t ep_ptr reply reply_opt ep ex_invs \<equiv>
    \<lambda>s. valid_sched s
         \<and> st_tcb_at active t s
         \<and> cur_thread s = t
         \<and> not_queued t s
         \<and> not_in_release_q t s
         \<and> scheduler_act_not t s
         \<and> released_if_bound_sc_tcb_at t s
         \<and> receive_ipc_preamble_rv reply reply_opt s
         \<and> ko_at (Endpoint ep) ep_ptr s
         \<and> ex_invs s"

lemma receive_ipc_blocked_valid_sched':
  assumes ep: "case ep of IdleEP \<Rightarrow> queue = [] | RecvEP q \<Rightarrow> queue = q | SendEP _ \<Rightarrow> False"
  shows "\<lbrace> receive_ipc_valid_sched_preconds t ep_ptr reply reply_opt ep invs \<rbrace>
          receive_ipc_blocked is_blocking t ep_ptr reply_opt pl queue
         \<lbrace> \<lambda>rv. valid_sched \<rbrace>"
  apply (cases reply_opt; clarsimp simp: receive_ipc_blocked_def)
   apply (wpsimp wp: set_thread_state_valid_sched)
   apply (clarsimp simp: valid_sched_def)
  apply (wpsimp wp: set_thread_state_valid_sched)
  apply (clarsimp simp: valid_sched_def)
  done

lemma receive_ipc_idle_valid_sched:
  "\<lbrace> receive_ipc_valid_sched_preconds t ep_ptr reply reply_opt IdleEP invs \<rbrace>
    receive_ipc_idle is_blocking t ep_ptr reply_opt pl
   \<lbrace> \<lambda>rv. valid_sched \<rbrace>"
  apply (rule hoare_weaken_pre, rule monadic_rewrite_refine_valid[where P''=\<top>])
  apply (rule monadic_rewrite_receive_ipc_idle)
  apply (rule receive_ipc_blocked_valid_sched'[where ep=IdleEP and reply=reply])
  by (auto simp: st_tcb_at_tcb_at)

lemmas receive_ipc_blocked_valid_sched =
  receive_ipc_blocked_valid_sched'[where ep="RecvEP queue" and queue=queue for queue, simplified]
  receive_ipc_idle_valid_sched

crunches receive_ipc_preamble, refill_unblock_check
  for valid_machine_time[wp]: valid_machine_time
  and cur_time[wp]: "\<lambda>s. P (cur_time s)"
  (wp: crunch_wps)

lemma maybe_return_sc_not_queued[wp]:
  "\<lbrace>not_queued thread and scheduler_act_sane\<rbrace>
   maybe_return_sc ntfnptr thread
   \<lbrace>\<lambda>rv. not_queued thread\<rbrace>"
  unfolding maybe_return_sc_def
  by (wpsimp wp: reschedule_required_not_queued get_tcb_obj_ref_wp get_sk_obj_ref_wp)

crunches maybe_return_sc
  for scheduler_act_not[wp]: "scheduler_act_not t"
  and cur_time[wp]: "\<lambda>s. P (cur_time s)"
  (wp: crunch_wps simp: crunch_simps)

lemma receive_ipc_preamble_rv_reprogram_timer[wp]:
  "receive_ipc_preamble_rv a b s \<Longrightarrow> receive_ipc_preamble_rv a b (s\<lparr>reprogram_timer := True\<rparr>)"
  apply (cases b; fastforce)
  done

crunches refill_unblock_check
  for receive_ipc_preamble_rv[wp]: "receive_ipc_preamble_rv a b"
  (wp: crunch_wps hoare_vcg_if_lift2 simp: is_round_robin_def)

lemma receive_ipc_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s
        \<and> st_tcb_at active thread s
        \<and> thread = cur_thread s
        \<and> not_queued thread s
        \<and> not_in_release_q thread s
        \<and> scheduler_act_not thread s
        \<and> released_if_bound_sc_tcb_at thread s
        \<and> invs s
        \<and> current_time_bounded s\<rbrace>
    receive_ipc thread ep_cap is_blocking reply_cap
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>" (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>")
  supply if_split[split del]
  apply (cases ep_cap
         ; simp add: receive_ipc_def split_def receive_ipc_preamble_def[symmetric]
                     receive_ipc_blocked_def[symmetric] receive_ipc_idle_def[symmetric]
                     if_cond_refill_unblock_check_def
               cong: endpoint.case_cong bool.case_cong)
  apply (rename_tac ep_ptr ep_badge ep_rights)
  apply (rule hoare_seq_ext[where B="\<lambda>rv s. receive_ipc_preamble_rv reply_cap rv s \<and> ?pre s", rotated]
         , wpsimp wp: receive_ipc_preamble_valid_sched receive_ipc_preamble_st_tcb_at
                      ct_in_state_thread_state_lift receive_ipc_preamble_invs
                      receive_ipc_preamble_lift[OF cancel_ipc_st_tcb_at_active]
                      receive_ipc_preamble_rv)
  apply (rename_tac reply_opt)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp[simplified pred_conj_comm]])
  apply (rule hoare_seq_ext[OF _ gbn_sp[simplified pred_conj_comm]])
  apply (rule hoare_seq_ext[OF _ get_notification_default_sp])
  apply (rule hoare_weaken_pre)
   apply (rule_tac R="receive_ipc_valid_sched_preconds thread ep_ptr reply_cap reply_opt ep
                             (invs and current_time_bounded)"
            in hoare_vcg_if_split, wp complete_signal_valid_sched)
   prefer 2 apply (clarsimp simp: runnable_eq_active)
  apply (thin_tac "\<not> (_ \<and> _)", clarsimp)
  apply (rule_tac B="\<lambda>r s. valid_sched s \<and>
             st_tcb_at active thread s \<and>
             cur_thread s = thread \<and>
             not_queued thread s \<and>
             not_in_release_q thread s \<and>
             scheduler_act_not thread s \<and>
             (pred_map_eq None (tcb_scps_of s) thread \<or> released_sc_tcb_at thread s) \<and>
             receive_ipc_preamble_rv reply_cap reply_opt s \<and>
             ko_at (Endpoint ep) ep_ptr s \<and> invs s \<and> current_time_bounded s"
           in hoare_seq_ext[rotated])
  apply (wpsimp split: if_split)
  apply (frule (1) not_idle_thread[OF invs_valid_idle], simp)
  apply (case_tac ep; simp)
  \<comment> \<open>IdleEP, RecvEP\<close>
  apply (wpsimp wp: receive_ipc_blocked_valid_sched[where reply=reply_cap])
  prefer 2
  apply (wpsimp wp: receive_ipc_blocked_valid_sched[where reply=reply_cap])
  \<comment> \<open>SendEP\<close>
  apply (rename_tac queue)
  apply (rule hoare_seq_ext[OF _ assert_sp], simp)
  apply (rule_tac S="ep_ptr \<notin> set queue \<and> distinct queue" in hoare_gen_asm'')
   apply (clarsimp simp: obj_at_def)
   apply (erule (1) pspace_valid_objsE[OF _ invs_valid_objs])
   apply (clarsimp simp: valid_obj_def valid_ep_def)
   apply (drule (1) bspec)
   apply (clarsimp simp: obj_at_def is_tcb)
  apply (case_tac queue; clarsimp cong: if_cong list.case_cong)
  apply (rename_tac sender queue)
  apply (rule_tac s="mk_ep SendEP queue" in subst[where P="\<lambda>c. \<lbrace>P\<rbrace> set_endpoint p c >>= r \<lbrace>Q\<rbrace>" for P p r Q]
         , simp add: mk_ep_def split: list.splits)
  apply (rule_tac B="\<lambda>r. receive_ipc_valid_sched_preconds thread ep_ptr reply_cap reply_opt
                           (mk_ep SendEP queue)
                           (\<lambda>s. sym_refs (\<lambda>p. if p = ep_ptr then set (sender # queue) \<times> {EPSend}
                                                            else state_refs_of s p)
                                \<and> all_invs_but_sym_refs s
                                \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                                \<and> current_time_bounded s)"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: hoare_vcg_ball_lift set_simple_ko_at valid_ioports_lift)
   apply (frule invs_sym_refs, frule sym_refs_inj_tcb_scps)
   apply (clarsimp simp: invs_def valid_state_def valid_pspace_def)
   apply (apply_conjunct \<open>erule delta_sym_refs; fastforce simp: ko_at_state_refs_ofD
                                                         split: if_splits\<close>)
   apply (fastforce elim!: obj_at_valid_objsE if_live_then_nonz_capD2 heap_refs_injD
                     simp: valid_obj_def valid_ep_def mk_ep_def live_def
                    split: endpoint.splits if_splits)
  \<comment> \<open>get_thread_state\<close>
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rename_tac sender_state)
  apply (case_tac sender_state; clarsimp)
  apply (rename_tac ep_ptr' sender_data)
  \<comment> \<open>do_ipc_transfer, and stash some knowledge for later\<close>
  apply (rule_tac B="\<lambda>r. receive_ipc_valid_sched_preconds thread ep_ptr reply_cap reply_opt
                           (mk_ep SendEP queue)
                           (\<lambda>s. st_tcb_at ((=) (BlockedOnSend ep_ptr sender_data)) sender s
                                \<and> state_refs_of s ep_ptr = set queue \<times> {EPSend}
                                \<and> all_invs_but_sym_refs s
                                \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                                \<and> current_time_bounded s)"
           in hoare_seq_ext[rotated])
   apply (wpsimp simp: st_tcb_at_tcb_at)
   apply (rule_tac V="ep_ptr' = ep_ptr" in revcut_rl
          , (drule_tac x=ep_ptr and y=sender and tp=TCBBlockedSend in sym_refsE
             ; fastforce simp: in_state_refs_of_iff refs_of_rev pred_tcb_at_def obj_at_def)
          , clarsimp)
   apply (frule ko_at_state_refs_ofD, simp)
  \<comment> \<open>refill_unblock_check\<close>
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext_skip)
   apply (rename_tac scpopt, case_tac scpopt; clarsimp simp: maybeM_def, (solves wpsimp)?)
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (rule hoare_seq_ext[OF _ gets_sp])
   apply (rule hoare_pre)
    apply (rule hoare_when_weak_wp)
    apply (rule hoare_when_weak_wp)
    apply (wpsimp wp: refill_unblock_check_valid_sched)
    apply (frule valid_sched_active_sc_valid_refills, clarsimp)
    apply (prop_tac "heap_ref_eq a sender (tcb_scps_of s)")
     apply (clarsimp simp: tcb_at_kh_simps pred_map_simps)
    apply (clarsimp simp: pred_map_eq heap_refs_inv_def2 valid_sched_def)
    apply (drule_tac t=sender in valid_release_q_not_in_release_q_not_runnable)
     apply (clarsimp dest!: sym[where t="tcb_state _"] simp: pred_tcb_at_def obj_at_def)
    apply clarsimp+
  \<comment> \<open>thread_get tcb_fault\<close>
  apply (rule hoare_seq_ext[OF _ thread_get_sp])
  apply (rule hoare_if[rotated])
   \<comment> \<open>if not call and no fault: sender \<rightarrow> Running\<close>
   apply (wpsimp wp: set_thread_state_possible_switch_to_valid_sched)
   apply (intro conjI)
    apply (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
    apply (frule valid_sched_released_ipc_queues, drule_tac t=sender in released_ipc_queues_blocked_on_send_E1)
     apply (clarsimp simp: pred_map_simps)
    apply (fastforce simp: vs_all_heap_simps is_timeout_fault_opt_def)
   apply (erule (1) not_idle_thread', clarsimp)
  apply (rule hoare_if[rotated])
   \<comment> \<open>if not grant or no reply: sender \<longrightarrow> Inactive\<close>
   apply (wpsimp wp: set_thread_state_Inactive_not_queued_valid_sched cong: if_cong)
   apply (intro conjI;
          clarsimp simp: pred_tcb_at_eq_commute st_tcb_at_def obj_at_def
                 intro!: valid_sched_scheduler_act_not_better
                  elim!: valid_ready_qs_not_queued_not_runnable[OF valid_sched_valid_ready_qs]
                         valid_release_q_not_in_release_q_not_runnable[OF valid_sched_valid_release_q])
  \<comment> \<open>otherwise (grant and reply and (call or fault)): reply_push\<close>
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (wpsimp wp: reply_push_valid_sched)
  apply (clarsimp simp: valid_sched_valid_sched_except_blocked[THEN iffD1]
                        obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (prop_tac "\<not> pred_map runnable (tcb_sts_of s) sender", clarsimp simp: vs_all_heap_simps)
  apply (clarsimp simp: valid_sched_not_runnable_scheduler_act_not
                        valid_sched_not_runnable_not_queued
                        valid_sched_not_runnable_not_in_release_q)
  apply (prop_tac "active_if_bound_sc_tcb_at sender s")
   apply (frule valid_sched_released_ipc_queues, drule_tac t=sender in released_ipc_queues_blocked_on_send_E1
          ; fastforce simp: vs_all_heap_simps)
  apply simp
  by (match premises in H: \<open>ct_in_state' active s\<close> for s \<Rightarrow> \<open>insert H, fastforce simp: vs_all_heap_simps\<close>)

end


crunches do_nbrecv_failed_transfer
for valid_sched[wp]: valid_sched

lemma as_user_is_sc_active[wp]:
  "\<lbrace>is_sc_active scp\<rbrace> as_user tptr f \<lbrace>\<lambda>_. is_sc_active scp\<rbrace>"
  apply (wpsimp simp: as_user_def wp: set_object_wp)
  by (clarsimp simp: is_sc_active_def dest!: get_tcb_SomeD split: option.splits)

lemma maybe_donate_sc_bound_sc_trivial:
  "\<lbrace>bound_sc_tcb_at bound thread and P\<rbrace>
   maybe_donate_sc thread ntfn_ptr
   \<lbrace>\<lambda>_. P\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (wpsimp)
  apply (rule hoare_pre_cont)
  apply (wpsimp simp: get_sc_obj_ref_def get_sk_obj_ref_def get_tcb_obj_ref_def
                  wp: thread_get_wp get_simple_ko_wp)+
  apply (fastforce simp: obj_at_def pred_tcb_at_def)
  done

lemmas as_user_bound_tcb[wp] = as_user_bound_obj_typ_at[where T=ATCB, folded tcb_at_typ]

lemma receive_signal_valid_sched:
  "\<lbrace>valid_sched and valid_objs and (\<lambda>s. sym_refs (state_refs_of s))
    and current_time_bounded and scheduler_act_not thread and not_queued thread
    and not_in_release_q thread and (\<lambda>s. thread = cur_thread s)
    and released_if_bound_sc_tcb_at thread and st_tcb_at runnable thread\<rbrace>
   receive_signal thread cap is_blocking
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  apply (clarsimp simp: receive_signal_def)
  apply (cases cap; clarsimp)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ntfn)
  apply (case_tac "ntfn_obj ntfn"; clarsimp simp: if_cond_refill_unblock_check_def)
    apply (wpsimp wp: set_thread_state_valid_sched)
    apply (clarsimp simp: valid_sched_def)
   apply (wpsimp wp: set_thread_state_valid_sched)
   apply (clarsimp simp: valid_sched_def)
  apply (wpsimp wp: maybe_donate_sc_valid_sched hoare_vcg_if_lift2
                    refill_unblock_check_valid_sched get_tcb_obj_ref_wp
              simp: valid_ntfn_def)
     apply (rule_tac Q="\<lambda>_ s. valid_sched s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                              \<and> current_time_bounded s
                              \<and> (in_release_q thread s
                                  \<longrightarrow> active_sc_tcb_at thread s \<longrightarrow> (\<not> budget_ready thread s))"
            in hoare_strengthen_post[rotated])
      apply (clarsimp simp: pred_neg_def obj_at_def tcb_at_kh_simps)
      apply (rename_tac tcb scp sc n t)
      apply (prop_tac "heap_ref_eq scp thread (tcb_scps_of s)")
       apply (clarsimp simp: obj_at_def vs_all_heap_simps)
      apply (clarsimp simp: heap_refs_inv_def2 pred_map_eq)
      apply (prop_tac "pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) thread")
       apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
      apply (fastforce simp: budget_ready_def2 tcb_at_kh_simps vs_all_heap_simps)
     apply (wpsimp wp: maybe_donate_sc_valid_sched maybe_donate_sc_in_release_q_imp_not_ready)+
  done

crunches restart_thread_if_no_fault
  for not_queued[wp]: "not_queued t"
  (wp: crunch_wps)

lemma cancel_all_ipc_not_queued:
  "\<lbrace>st_tcb_at active t and valid_objs and not_queued t and scheduler_act_not t
        and sym_refs \<circ> state_refs_of\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  apply (simp add: cancel_all_ipc_def)
  apply (wp reschedule_required_not_queued  | wpc | simp)+
      apply (rule hoare_gen_asm)
      apply (rule_tac S="set queue - {t}" in mapM_x_wp)
       apply (wp tcb_sched_enqueue_not_queued gts_wp| clarsimp | wpc)+
      apply (erule notE, assumption)
     apply (wp reschedule_required_not_queued | simp add: get_ep_queue_def)+
     apply (rule hoare_gen_asm)
     apply (rule_tac S="set queue - {t}" in mapM_x_wp)
      apply (wp tcb_sched_enqueue_not_queued gts_wp | wpc | clarsimp)+
     apply (erule notE, assumption)
    apply (wp hoare_vcg_imp_lift
         | simp add: get_ep_queue_def get_simple_ko_def a_type_def get_object_def
              split: kernel_object.splits
         | wpc | wp (once) hoare_vcg_all_lift)+
   apply safe
   apply (rename_tac xa)
   apply (drule_tac P="\<lambda>ts. \<not> active ts" and ep="SendEP xa" in
          ep_queued_st_tcb_at[rotated, rotated])
       apply (simp_all only: st_tcb_at_not)
      apply (simp add: obj_at_def)+
  apply (rename_tac xa)
  apply (drule_tac P="\<lambda>ts. \<not> active ts" and ep="RecvEP xa" in ep_queued_st_tcb_at[rotated, rotated])
      apply (simp_all only: st_tcb_at_not)
     apply (fastforce simp: obj_at_def)+
  done

lemma cancel_all_signals_not_queued:
  "\<lbrace>st_tcb_at active t and valid_objs and not_queued t and scheduler_act_not t
         and sym_refs \<circ> state_refs_of\<rbrace>
    cancel_all_signals epptr
   \<lbrace>\<lambda>rv. not_queued t\<rbrace>"
  apply (simp add: cancel_all_signals_def)
  apply (wp reschedule_required_not_queued | wpc | simp)+
      apply (rename_tac list)
      apply (rule_tac P="(t \<notin> set list)" in hoare_gen_asm)
      apply (rule_tac S="set list - {t}" in mapM_x_wp)
       apply (wp tcb_sched_enqueue_not_queued | clarsimp)+
       apply blast+
     apply (wp hoare_vcg_imp_lift
      | simp add: get_simple_ko_def get_object_def a_type_def split: kernel_object.splits
      | wpc | wp (once) hoare_vcg_all_lift)+
  apply safe
  apply (rename_tac ep x y)
  apply (drule_tac P="\<lambda>ts. \<not> active ts" and ep=ep in
      ntfn_queued_st_tcb_at[rotated, rotated])
      apply (simp_all only: st_tcb_at_not)
     apply (fastforce simp: obj_at_def)+
  done

lemma unbind_maybe_notification_sym_refs[wp]:
  "\<lbrace>\<lambda>s. sym_refs (state_refs_of s) \<and> valid_objs s\<rbrace>
     unbind_maybe_notification a
   \<lbrace>\<lambda>rv s. sym_refs (state_refs_of s)\<rbrace>"
  apply (simp add: unbind_maybe_notification_def get_sk_obj_ref_def maybeM_def)
  apply (rule hoare_seq_ext [OF _ get_simple_ko_sp])
  apply (wpsimp simp: update_sk_obj_ref_def wp: get_simple_ko_wp)
  apply (rule conjI)
   apply (clarsimp simp: obj_at_def, frule (4) ntfn_bound_tcb_at)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def is_tcb)
  apply clarsimp
  apply (rule delta_sym_refs, assumption)
   apply (clarsimp split: if_split_asm, frule ko_at_state_refs_ofD, simp)+
   apply (frule_tac P="(=) (Some a)" in ntfn_bound_tcb_at, simp_all add: obj_at_def)[1]
  apply (clarsimp simp: obj_at_def, frule (4) ntfn_bound_tcb_at, clarsimp simp: pred_tcb_at_def obj_at_def is_tcb)
  apply (frule (1) sym_refs_ko_atD[simplified obj_at_def, simplified])
  apply (frule ko_at_state_refs_ofD[where ko="TCB _", simplified obj_at_def, simplified])
  apply (fastforce split: if_split_asm split del: if_split simp: get_refs_def2 obj_at_def)
  done

lemma sched_context_unbind_ntfn_sym_refs[wp]:
  "\<lbrace>\<lambda>s. sym_refs (state_refs_of s) \<and> valid_objs s\<rbrace>
     sched_context_unbind_ntfn sc_ptr
   \<lbrace>\<lambda>rv s. sym_refs (state_refs_of s)\<rbrace>"
  apply (clarsimp simp: sched_context_unbind_ntfn_def get_sc_obj_ref_def maybeM_def)
  apply (rule hoare_seq_ext [OF _ get_sched_context_sp])
  apply (wpsimp simp: update_sk_obj_ref_def wp: get_simple_ko_wp)
  apply (rule conjI)
   apply (erule (1) obj_at_valid_objsE)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  apply clarsimp
  apply (rule delta_sym_refs, assumption)
   apply (clarsimp split: if_split_asm)
   apply (frule ko_at_state_refs_ofD)
   apply (frule ko_at_state_refs_ofD[where ko="Notification _"], simp)
  apply (frule (1) sym_refs_ko_atD)
  apply (frule ko_at_state_refs_ofD[where ko="Notification _"])
  apply (fastforce split: if_split_asm split del: if_split simp: image_iff get_refs_def2 obj_at_def)+
  done

lemma sched_context_maybe_unbind_ntfn_sym_refs[wp]:
  "\<lbrace>\<lambda>s. sym_refs (state_refs_of s) \<and> valid_objs s\<rbrace>
     sched_context_maybe_unbind_ntfn a
   \<lbrace>\<lambda>rv s. sym_refs (state_refs_of s)\<rbrace>"
  apply (wpsimp simp: update_sk_obj_ref_def sched_context_maybe_unbind_ntfn_def get_sk_obj_ref_def
                  wp: get_simple_ko_wp get_sched_context_wp)
  apply (clarsimp simp: obj_at_def)
  apply (rule conjI, clarsimp)
   apply (erule (1) valid_objsE)
   apply (clarsimp simp: valid_obj_def valid_ntfn_def valid_bound_obj_def obj_at_def
                  dest!: is_sc_objD)
  apply clarsimp
  apply (rule delta_sym_refs, assumption)
   apply (fastforce dest: refs_in_ntfn_q_refs refs_in_get_refs
                    simp: state_refs_of_def valid_ntfn_def obj_at_def is_sc_obj_def
                   split: if_split_asm option.split_asm ntfn.splits kernel_object.split_asm)[1]
  apply (clarsimp split: if_splits)
   apply (fastforce simp: obj_at_def
                       dest!: refs_in_get_refs SCNtfn_in_state_refsD ntfn_sc_sym_refsD)
  apply (clarsimp simp: state_refs_of_def)
  done

lemma sched_context_unbind_tcb_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace> sched_context_unbind_tcb scptr \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  unfolding sched_context_unbind_tcb_def
  by (wpsimp wp: tcb_dequeue_not_queued reschedule_required_not_queued hoare_vcg_disj_lift)

lemma sched_context_unbind_all_tcbs_not_queued[wp]:
  "\<lbrace>not_queued t and scheduler_act_not t\<rbrace> sched_context_unbind_all_tcbs scptr \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  by (wpsimp simp: sched_context_unbind_all_tcbs_def wp: get_sched_context_wp)

lemma fast_finalise_not_queued:
  "\<lbrace>valid_objs and sym_refs \<circ> state_refs_of and st_tcb_at active t and scheduler_act_not t
    and not_queued t\<rbrace>
   fast_finalise cap final
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (cases cap; simp)
     apply wpsimp
    apply (wpsimp wp: cancel_all_ipc_not_queued)
   apply (wpsimp wp: cancel_all_signals_not_queued unbind_maybe_notification_valid_objs)
  apply (wpsimp wp: gts_wp get_simple_ko_wp)
  done

lemma cap_insert_check_cap_ext_valid[wp]:"
  \<lbrace>valid_list\<rbrace>
   check_cap_at new_cap src_slot (check_cap_at t slot (cap_insert new_cap src_slot x))
  \<lbrace>\<lambda>rv. valid_list\<rbrace>"
  apply (simp add: check_cap_at_def)
  apply (wp get_cap_wp | simp)+
  done

crunches lookup_cap, lookup_reply
  for valid_sched[wp]: "valid_sched_pred_strong P"
  and ct_in_state[wp]: "ct_in_state P"

context DetSchedSchedule_AI begin

lemma budget_sufficient_bound_sc:
  "budget_sufficient t s \<Longrightarrow> bound_sc_tcb_at bound t s"
  by (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)

lemma st_tcb_at_strengthen_pred:
  "st_tcb_at P t s \<Longrightarrow> (\<forall>st. P st \<longrightarrow> Q st) \<Longrightarrow> st_tcb_at Q t s"
  by (clarsimp simp: tcb_at_kh_simps ct_in_state_def vs_all_heap_simps runnable_eq)

(* FIXME RT: move *)
lemma is_timeout_fault_simp[simp]:
  "is_timeout_fault (CapFault ref b f) = False"
  by (clarsimp simp: is_timeout_fault_def)

lemma lookup_reply_not_timeout[wp]:
  "\<lbrace>invs\<rbrace> lookup_reply -, \<lbrace>\<lambda>rv s. \<not> is_timeout_fault rv\<rbrace>"
  apply (simp add: lookup_reply_def, wpsimp)
  done

lemma handle_recv_valid_sched:
  "\<lbrace>valid_sched and invs and ct_active and ct_not_in_release_q
    and ct_not_queued and scheduler_act_sane and current_time_bounded
    and (\<lambda>s. released_if_bound_sc_tcb_at (cur_thread s) s)\<rbrace>
   handle_recv is_blocking can_reply
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (simp add: handle_recv_def Let_def ep_ntfn_cap_case_helper
             cong: if_cong)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (intro hoare_seq_ext_skip hoare_seq_ext_skipE
               catch_wp[OF handle_fault_valid_sched]
               weaker_hoare_ifE[where P=P and P'=P for P, simplified pred_conj_def, simplified];
         wpsimp wp: receive_ipc_valid_sched receive_signal_valid_sched;
         clarsimp simp: ct_in_state_def elim!: invs_retract_tcb_scps)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps current_time_bounded_def)

crunches reply_from_kernel
  for valid_sched_pred[wp]: "valid_sched_pred_strong P"

end

context DetSchedSchedule_AI begin

crunches invoke_irq_control
  for valid_sched_pred_strong[wp]: "valid_sched_pred_strong P :: 'state_ext state \<Rightarrow> _"

lemma invoke_irq_handler_valid_sched[wp]:
  "\<lbrace> valid_sched and invs and simple_sched_action and current_time_bounded\<rbrace>
   invoke_irq_handler i
   \<lbrace> \<lambda>_. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  by (cases i; wpsimp wp: cap_delete_one_valid_sched)

end

declare valid_idle_etcb_lift[wp del]

lemma thread_set_domain_not_idle_valid_idle_etcb:
  "\<lbrace>valid_idle_etcb and valid_idle and (\<lambda>s. tptr \<noteq> idle_thread s)\<rbrace>
     thread_set_domain tptr d \<lbrace>\<lambda>_. valid_idle_etcb\<rbrace>"
  unfolding thread_set_domain_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: valid_idle_etcb_def etcb_at'_def vs_all_heap_simps valid_idle_def
                        pred_tcb_at_def obj_at_def)
  done


lemma thread_set_domain_not_switch_switch_in_cur_domain:
  "\<lbrace>switch_in_cur_domain and (\<lambda>s. scheduler_action s \<noteq> switch_thread tptr)\<rbrace>
     thread_set_domain tptr d \<lbrace>\<lambda>_. switch_in_cur_domain\<rbrace>"
  unfolding thread_set_domain_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: switch_in_cur_domain_def in_cur_domain_def etcb_at'_def vs_all_heap_simps
                 dest!:get_tcb_SomeD)
  done

lemma thread_set_domain_ssa_valid_sched_action:
  "\<lbrace>valid_sched_action and simple_sched_action\<rbrace>
     thread_set_domain tptr d \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  unfolding valid_sched_action_def
  apply (wpsimp wp: thread_set_domain_not_switch_switch_in_cur_domain)
  apply (force simp: simple_sched_action_def)
  done

lemma thread_set_domain_act_not_valid_sched_action:
  "\<lbrace>valid_sched_action and scheduler_act_not tptr\<rbrace>
     thread_set_domain tptr d \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  unfolding valid_sched_action_def
  apply (wpsimp wp: thread_set_domain_not_switch_switch_in_cur_domain)
  apply (force simp: scheduler_act_not_def)
  done

lemma thread_set_domain_ct_in_cur_domain:
  "\<lbrace>ct_in_cur_domain and not_cur_thread t\<rbrace> thread_set_domain t d \<lbrace>\<lambda>_. ct_in_cur_domain\<rbrace>"
  unfolding thread_set_domain_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: ct_in_cur_domain_def in_cur_domain_2_def etcb_at'_def vs_all_heap_simps
                        not_cur_thread_def)
  done

lemma thread_set_domain_valid_ready_qs_not_q:
  "\<lbrace>valid_ready_qs and not_queued t\<rbrace> thread_set_domain t d \<lbrace>\<lambda>_. valid_ready_qs\<rbrace>"
  unfolding thread_set_domain_def thread_set_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp simp: valid_ready_qs_def vs_all_heap_simps  not_queued_def
                  dest!: get_tcb_SomeD split: option.splits)
  apply (intro conjI; clarsimp)
  apply (drule_tac x=d and y =p in spec2, clarsimp, drule_tac x=ta in bspec, simp)
  apply clarsimp
  apply (rule_tac x=ref' in exI, clarsimp)
  done

lemma thread_set_domain_not_idle_valid_sched:
  "\<lbrace>valid_sched and scheduler_act_not tptr and not_queued tptr
     and (\<lambda>s. tptr \<noteq> cur_thread s) and (\<lambda>s. tptr \<noteq> idle_thread s) and valid_idle\<rbrace>
     thread_set_domain tptr d \<lbrace>\<lambda>_. valid_sched\<rbrace>"
  unfolding valid_sched_def valid_sched_action_def
  apply (wpsimp wp: thread_set_domain_valid_ready_qs_not_q thread_set_domain_ct_in_cur_domain
                    thread_set_domain_not_switch_switch_in_cur_domain valid_blocked_lift
                    thread_set_domain_not_idle_valid_idle_etcb)
  apply (clarsimp simp: scheduler_act_not_def not_cur_thread_def)
  done

lemma thread_set_domain_schedulable_bool_not[wp]:
  "\<lbrace>\<lambda>s. \<not> schedulable t s\<rbrace>
   thread_set_domain t d
   \<lbrace>\<lambda>rv s. \<not> schedulable t s\<rbrace>"
  apply (wpsimp simp: thread_set_domain_def thread_set_def wp: set_object_wp)
  by (clarsimp simp: get_tcb_rev schedulable_def is_sc_active_def in_release_queue_def
        dest!: get_tcb_SomeD split: option.splits if_split_asm)

lemma thread_set_domain_schedulable_bool[wp]:
  "\<lbrace>\<lambda>s. schedulable t s\<rbrace>
   thread_set_domain t d
   \<lbrace>\<lambda>rv s. schedulable t s\<rbrace>"
  apply (wpsimp simp: thread_set_domain_def thread_set_def wp: set_object_wp)
  by (fastforce simp: get_tcb_rev schedulable_def is_sc_active_def in_release_queue_def
        dest!: get_tcb_SomeD split: option.splits)

lemma tcb_sched_action_schedulable_bool[wp]:
  "\<lbrace>\<lambda>s. schedulable t s\<rbrace>
   tcb_sched_action f t
   \<lbrace>\<lambda>rv s. schedulable t s\<rbrace>"
  apply (wpsimp simp: tcb_sched_action_def thread_set_def thread_get_def get_tcb_queue_def
                  wp: set_object_wp set_tcb_queue_wp)
  by (fastforce simp: schedulable_def' get_tcb_rev obj_at_def
               dest!: get_tcb_SomeD split: option.splits)

(* move *)
lemma valid_sched_action_switch_thread_is_schedulable:
  "\<lbrakk>valid_sched_action s; scheduler_action s = switch_thread thread\<rbrakk> \<Longrightarrow>
     is_schedulable_opt thread  s = Some True"
  by (clarsimp simp: valid_sched_def valid_sched_action_def weak_valid_sched_action_def
       is_schedulable_opt_def pred_tcb_at_def  obj_at_def get_tcb_rev
       in_release_queue_def released_sc_tcb_at_def vs_all_heap_simps is_sc_active_kh_simp)

lemma thread_set_domain_is_schedulable_opt[wp]:
  "\<lbrace>\<lambda>s. Q (is_schedulable_opt t s)\<rbrace>
   thread_set_domain t d
   \<lbrace>\<lambda>rv s. Q (is_schedulable_opt t s)\<rbrace>"
  unfolding thread_set_domain_def
  apply (wpsimp wp: thread_set_wp)
  by (auto simp: is_schedulable_opt_def get_tcb_def is_sc_active_def in_release_queue_def
          split: option.splits kernel_object.splits cong: conj_cong)

lemma tcb_sched_dequeue_is_schedulable_opt[wp]:
  "\<lbrace>\<lambda>s. Q (is_schedulable_opt t s)\<rbrace>
   tcb_sched_action tcb_sched_dequeue t
   \<lbrace>\<lambda>rv s. Q (is_schedulable_opt t s)\<rbrace>"
  unfolding tcb_sched_action_def
  apply (wpsimp wp: thread_set_wp set_tcb_queue_wp)
  done

lemma valid_blocked_valid_ready_qs_ready_and_sufficient:
  "\<lbrakk>t \<noteq> cur_thread s; valid_ready_qs s; valid_blocked s;
          scheduler_act_not t s;
          st_tcb_at runnable t s; active_sc_tcb_at t s; not_in_release_q t s\<rbrakk>
         \<Longrightarrow> budget_ready t s"
  apply (clarsimp simp: valid_blocked_defs scheduler_act_not_def valid_ready_qs_def
                        vs_all_heap_simps pred_tcb_at_def obj_at_def in_ready_q_def)
  apply (drule_tac x=t in spec)
  apply (case_tac "tcb_state tcb"; simp)
   apply fastforce
  by fastforce

context DetSchedSchedule_AI begin

lemma invoke_domain_valid_sched:
  notes tcb_sched_enqueue_valid_sched[wp del]
  shows
  "\<lbrace>valid_sched and tcb_at t and (\<lambda>s. t \<noteq> idle_thread s) and ct_not_queued
                and scheduler_act_not t and valid_idle
                and (\<lambda>s. budget_ready (cur_thread s) s)\<rbrace>
   invoke_domain t d
   \<lbrace>\<lambda>_. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (simp add: invoke_domain_def)
  including no_pre
  apply wp
  apply (simp add: set_domain_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac "t=cur"; simp)
    (* first case *)
   apply (wpsimp wp_del: reschedule_valid_sched_const
                     wp: reschedule_required_valid_sched'
                         tcb_sched_enqueue_valid_blocked_except_set_const is_schedulable_wp)
    apply (clarsimp simp: schedulable_def2 split: if_split)
    apply (wpsimp wp: thread_set_domain_valid_ready_qs_not_q hoare_vcg_if_lift hoare_vcg_imp_lift' hoare_vcg_all_lift
                      thread_set_domain_not_idle_valid_idle_etcb)
   apply (wpsimp wp: tcb_sched_dequeue_valid_ready_qs tcb_dequeue_not_queued hoare_vcg_imp_lift' hoare_vcg_all_lift
                     tcb_sched_dequeue_valid_blocked_except_set_remove hoare_vcg_conj_lift)
   apply (clarsimp simp: valid_sched_def valid_blocked_defs released_sc_tcb_at_def)
    (* second case *)
  apply (wpsimp wp: tcb_sched_enqueue_valid_sched)
     apply (wpsimp wp: is_schedulable_wp')+
   apply (clarsimp split: if_split)
   apply (wpsimp wp: hoare_vcg_imp_lift')
    apply (simp add: valid_sched_def)
    apply (wpsimp wp: thread_set_domain_valid_ready_qs_not_q
                      thread_set_domain_act_not_valid_sched_action
                      thread_set_domain_ct_in_cur_domain
                      thread_set_domain_not_idle_valid_idle_etcb)
   apply (wpsimp wp: hoare_vcg_imp_lift' thread_set_domain_not_idle_valid_sched)
  apply (clarsimp simp: tcb_at_kh_simps[symmetric] valid_sched_def)
  apply (wpsimp wp: tcb_sched_dequeue_valid_ready_qs tcb_dequeue_not_queued
                    tcb_sched_action_valid_sched_misc
                    tcb_sched_dequeue_valid_blocked_except_set_const
                    hoare_vcg_conj_lift hoare_vcg_imp_lift' tcb_sched_dequeue_ct_not_in_q)
  apply (clarsimp simp: valid_blocked_thread_def)
  apply (intro conjI)
   using valid_blocked_valid_ready_qs_ready_and_sufficient apply blast
  apply (clarsimp simp: runnable_eq_active tcb_at_kh_simps)
  done

lemma sched_context_bind_ntfn_valid_sched[wp]:
  "\<lbrace>valid_sched\<rbrace>
     sched_context_bind_ntfn x21 x41
   \<lbrace>\<lambda>_. valid_sched\<rbrace>"
 unfolding sched_context_bind_ntfn_def
 by wpsimp

lemma refill_unblock_check_budget_ready_ct[wp]:
  "\<lbrace>\<lambda>s. budget_ready (cur_thread s) s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>xc s. budget_ready (cur_thread s) s\<rbrace>"
  by (wp_pre, rule hoare_lift_Pf2[where f=cur_thread]) wpsimp+

lemma refill_unblock_check_budget_sufficient_ct[wp]:
  "\<lbrace>\<lambda>s. budget_sufficient (cur_thread s) s \<and> active_sc_tcb_at (cur_thread s) s \<and> active_sc_valid_refills s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>xc s. budget_sufficient (cur_thread s) s\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<forall>t. t = cur_thread s \<longrightarrow> budget_sufficient t s" in hoare_strengthen_post[rotated],
         clarsimp)
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift) (fastforce elim!: active_sc_tcb_at_valid_refills)

lemma refill_unblock_check_active_sc_tcb_at_ct[wp]:
  "\<lbrace>\<lambda>s. active_sc_tcb_at (cur_thread s) s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace> \<lambda>r s. active_sc_tcb_at (cur_thread s) s\<rbrace>"
  by (rule hoare_lift_Pf[where f=cur_thread]) wpsimp+

lemma sched_context_update_consumed_sc_tcb_sc_at[wp]:
  "sched_context_update_consumed e \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  unfolding sched_context_update_consumed_def
  apply (wpsimp simp: update_sched_context_def wp: set_object_wp get_object_wp)
  by (clarsimp simp: obj_at_def sc_tcb_sc_at_def)

crunch sc_tcb_sc_at_inv[wp]: do_machine_op "\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s
                \<and> budget_ready t s \<and> budget_sufficient t s) scp s"
  (simp: crunch_simps split_def sc_tcb_sc_at_def wp: crunch_wps hoare_drop_imps)

crunch sc_tcb_sc_at_inv[wp]: store_word_offs "\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s
                \<and> budget_ready t s \<and> budget_sufficient t s) scp s"
  (simp: crunch_simps split_def wp: crunch_wps hoare_drop_imps ignore: do_machine_op)

lemma sched_context_yield_to_valid_sched_helper:
  "\<lbrace>sc_yf_sc_at ((=) sc_yf_opt) sc_ptr and
       (valid_sched and simple_sched_action and (\<lambda>s. sym_refs (state_refs_of s)) and
        (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) sc_ptr s) and
        ct_active and ct_released and invs and ct_not_in_release_q
        and current_time_bounded)\<rbrace>
     when (sc_yf_opt \<noteq> None) $
       do complete_yield_to (the sc_yf_opt);
          sc_yf_opt <- get_sc_obj_ref sc_yield_from sc_ptr;
          assert (sc_yf_opt = None)
       od
   \<lbrace>\<lambda>_. valid_sched and simple_sched_action and
     (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) sc_ptr s) and
     ct_active and ct_released and invs and current_time_bounded and ct_not_in_release_q\<rbrace>"
  by (wpsimp wp: get_sc_obj_ref_wp complete_yield_to_invs
                 hoare_vcg_all_lift hoare_drop_imp is_schedulable_wp
      | wps)+

lemma schedulable_not_in_release_q:
  "schedulable tp s \<Longrightarrow> not_in_release_q tp s"
  by (clarsimp simp: schedulable_def not_in_release_q_def
               split: option.splits)

lemma refill_unblock_check_ct_released:
  "\<lbrace>ct_released and active_sc_valid_refills\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_. ct_released\<rbrace>"
  apply (wp_pre, rule hoare_lift_Pf2[where f=cur_thread])
    by wpsimp+

crunches sched_context_resume
  for pred_tcb_at_ct[wp]: "\<lambda>s. pred_tcb_at P proj (cur_thread s) s"
    (wp: crunch_wps simp: crunch_simps)

lemma schedulable_sc_not_in_release_q:
  "\<lbrakk>\<forall>tp. bound_sc_tcb_at ((=) (Some scp)) tp s \<and> schedulable tp s\<rbrakk>
       \<Longrightarrow> sc_not_in_release_q scp s"
  by (fastforce simp: schedulable_def split: option.splits)

crunches tcb_sched_action
  for sc_ko_at[wp]: "\<lambda>s. (\<exists>n. ko_at (SchedContext sc n) sc_ptr s)"

lemma postpone_not_in_release_q:
  "\<lbrace>not_in_release_q t and (\<lambda>s. \<forall>tptr. pred_map_eq (Some tptr) (sc_tcbs_of s) scp \<longrightarrow> tptr \<noteq> t)\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: get_sc_obj_ref_wp)
  by (clarsimp simp: obj_at_def pred_map_def vs_all_heap_simps)

lemma sched_context_resume_not_in_release_q:
  "\<lbrace>not_in_release_q t
    and (\<lambda>s. sc_tcb_sc_at ((=) (Some t)) scp s \<longrightarrow> st_tcb_at runnable t s \<longrightarrow> is_active_sc scp s \<longrightarrow>
            (is_refill_ready scp s \<and> is_refill_sufficient 0 scp s))\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  unfolding sched_context_resume_def
  apply (wpsimp wp: postpone_not_in_release_q thread_get_wp' is_schedulable_wp)
  by (clarsimp simp: obj_at_def pred_tcb_at_def sc_at_pred_n_def pred_map_def vs_all_heap_simps)

lemma sched_context_resume_schedulable_imp_sc_ready:
  "\<lbrace>sc_tcb_sc_at bound scp and (\<lambda>s. sym_refs (state_refs_of s)) and active_sc_valid_refills\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_ s. is_active_sc scp s \<and> sc_not_in_release_q scp s
          \<and> (runnable |< (kheap s |> sc_of |> sc_tcb |> tcb_sts_of s)) scp
             \<longrightarrow> is_refill_ready scp s\<rbrace>"
  unfolding sched_context_resume_def assert_opt_def when_def get_sc_refill_sufficient_def
            bind_assoc get_tcb_queue_def
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rename_tac sc; case_tac "sc_tcb sc"; simp)
  apply (rename_tac tp)
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (rule hoare_if)
   apply (rule hoare_seq_ext[OF _ thread_get_sp])
   apply (rule hoare_seq_ext[OF _ get_sc_refill_ready_sp])
   apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
   apply (rule hoare_if)
    apply (rule_tac R="\<lambda>_. in_release_q tp" in hoare_post_add)
    apply (wpsimp wp: postpone_in_release_q)
         apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_disj_lift
                           hoare_vcg_ex_lift postpone_in_release_q)
        apply (wpsimp wp: thread_get_wp')+
    apply (fastforce simp: obj_at_def opt_map_red sc_tcb_sc_at_def vs_all_heap_simps schedulable_def
                    dest!: opt_predD sym_ref_sc_tcb
                           valid_refills_refill_sufficient[OF active_sc_valid_refillsE[rotated]])
   apply wpsimp
   apply (clarsimp simp: vs_all_heap_simps obj_at_def dest!: opt_predD)
  apply wpsimp
  apply (fastforce simp: schedulable_def2 vs_all_heap_simps pred_tcb_at_def obj_at_def
                  dest!: opt_predD sym_ref_sc_tcb)
  done

(* use valid blocked to argue that the thread must be in the ready qs *)
lemma sched_context_yield_to_valid_sched:
  "\<lbrace>valid_sched and simple_sched_action and (\<lambda>s. sym_refs (state_refs_of s))
    and (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) sc_ptr s)
    and ct_active and ct_released and invs and ct_not_in_release_q
    and current_time_bounded\<rbrace>
   sched_context_yield_to sc_ptr args
   \<lbrace>\<lambda>y. valid_sched\<rbrace>"
  supply if_split[split del]
  unfolding sched_context_yield_to_def assert_opt_def
  apply (rule hoare_seq_ext[OF _ gscyf_sp])
  apply (rule hoare_seq_ext[OF _ sched_context_yield_to_valid_sched_helper], simp)
  apply (rule_tac A=A
              and B="\<lambda>_. A and (\<lambda>s. is_active_sc sc_ptr s \<and> sc_not_in_release_q sc_ptr s
                         \<and> (runnable |< (kheap s |> sc_of |> sc_tcb |> tcb_sts_of s)) sc_ptr
                         \<longrightarrow> is_refill_ready sc_ptr s)"
         for A in hoare_seq_ext[rotated])
   apply ((wpsimp wp: sched_context_resume_schedulable_imp_sc_ready
                      sched_context_resume_valid_sched hoare_vcg_conj_lift
                      sched_context_resume_not_in_release_q
                      sched_context_resume_ct_in_state[simplified ct_in_state_def]
           | wps)+)[1]
   apply (intro conjI; clarsimp?)
    apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
   apply (clarsimp simp: sc_tcb_sc_at_def elim!: obj_at_weakenE)
  apply (rule_tac B="\<lambda>_. valid_sched" in hoare_seq_ext[rotated]; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (case_tac sc_tcb_opt; clarsimp)
  apply (rename_tac tcb_ptr)
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (clarsimp simp: schedulable_def2)
  apply (case_tac schedulable; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (intro hoare_seq_ext[OF _ gets_sp]
               hoare_seq_ext[OF _ thread_get_sp])
  apply (rule_tac Q="\<lambda>s. valid_sched s \<and> ct_active s \<and> ct_released s
                              \<and> invs s \<and> cur_thread s = ct_ptr
                              \<and> st_tcb_at runnable tcb_ptr s
                              \<and> active_sc_tcb_at tcb_ptr s
                              \<and> not_in_release_q tcb_ptr s
                              \<and> sc_tcb_sc_at ((=) (Some tcb_ptr)) sc_ptr s
                              \<and> sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) sc_ptr s
                              \<and> ct_not_in_release_q s
                              \<and> is_refill_ready sc_ptr s"
         in hoare_weaken_pre[rotated])
   apply (prop_tac "bound_sc_tcb_at (\<lambda>p. p = Some sc_ptr) tcb_ptr s")
    apply (subst sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[OF _ _ invs_sym_refs])
       apply simp+
    apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
   apply (clarsimp simp: released_sc_tcb_at_def budget_ready_def2 valid_sched_def)
   apply (prop_tac "is_active_sc sc_ptr s \<and> sc_not_in_release_q sc_ptr s
           \<and> (runnable |< (kheap s |> sc_of |> sc_tcb |> tcb_sts_of s)) sc_ptr")
    apply (clarsimp simp: active_sc_tcb_at_def2 vs_all_heap_simps sc_tcb_sc_at_def obj_at_def)
    apply (frule (2) sym_ref_sc_tcb[OF invs_sym_refs])
    apply clarsimp
    apply (clarsimp simp: active_sc_tcb_at_def2 pred_tcb_at_def obj_at_def)
    apply (rule conjI)
     apply (clarsimp simp: vs_all_heap_simps)
     apply (frule_tac tp=ta in sym_ref_tcb_sc[OF invs_sym_refs], simp, simp)
     apply clarsimp
    apply (clarsimp simp: vs_all_heap_simps opt_map_def)
    apply (metis case_map_def pred_map_def tcb_sts.simps(2))
   apply fastforce
  apply (rule hoare_if)
   apply (rule_tac B="\<lambda>_ s. valid_sched_except_blocked s
                            \<and> valid_blocked_except tcb_ptr s
                            \<and> invs s
                            \<and> st_tcb_at runnable tcb_ptr s
                            \<and> active_sc_tcb_at tcb_ptr s
                            \<and> not_in_release_q tcb_ptr s
                            \<and> sc_tcb_sc_at ((=) (Some tcb_ptr)) sc_ptr s
                            \<and> sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) sc_ptr s
                            \<and> ct_not_in_release_q s
                            \<and> is_refill_ready sc_ptr s"
          in hoare_seq_ext[rotated])
    apply ((wpsimp wp: tcb_sched_dequeue_valid_blocked_except_set'
                       tcb_sched_dequeue_valid_sched_except_blocked tcb_sched_action_sc_tcb_sc_at
            | wps)+)[1]
    apply (clarsimp simp: valid_sched_def)
   apply (rule_tac B="\<lambda>_. valid_sched" in hoare_seq_ext[rotated]; (solves \<open>wpsimp\<close>)?)
   apply (wpsimp wp: tcb_sched_enqueue_valid_sched)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps)
   apply (frule invs_sym_refs)
   apply (frule_tac scp=sc_ptr in sym_ref_sc_tcb, blast, blast, force)
  apply (wpsimp wp: reschedule_required_valid_sched' tcb_sched_enqueue_valid_blocked_except_set
                    tcb_sched_dequeue_valid_blocked_except_set' tcb_sched_dequeue_valid_ready_qs)
  apply (clarsimp simp: valid_sched_def released_sc_tcb_at_def budget_ready_def2)
  apply (intro conjI)
   apply (clarsimp simp: ct_in_state_def runnable_eq_active)
  apply (rule_tac x=sc_ptr in exI)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def)
  apply (fastforce simp: obj_at_def pred_tcb_at_def dest!: sym_ref_sc_tcb[OF invs_sym_refs])
  done

lemma invoke_sched_context_valid_sched:
  "\<lbrace>invs and valid_sched and valid_sched_context_inv iv and invs and simple_sched_action
    and ct_not_in_release_q and ct_active and ct_released and current_time_bounded\<rbrace>
   invoke_sched_context iv
   \<lbrace>\<lambda>_. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (cases iv; simp)
      apply (wpsimp simp: invoke_sched_context_def
                  wp: sched_context_bind_tcb_valid_sched
                      sched_context_unbind_tcb_valid_sched sched_context_yield_to_valid_sched)+
     apply (rename_tac ref s cap)
     apply (prop_tac "sched_context_donate_ipc_queues_precond cap ref s")
      apply (simp add: obj_at_kh_kheap_simps pred_map_ipc_queued_thread_state_iff;
             fastforce simp: pred_map_def pred_map_weakenE)
     apply (prop_tac "sc_not_in_release_q ref s", clarsimp)
      apply (drule invs_heap_refs_inv_tcb_scps)
      apply (clarsimp simp: heap_refs_inv_def2 sc_at_kh_simps vs_all_heap_simps)
     apply (clarsimp simp: not_cur_thread_def vs_all_heap_simps obj_at_kh_kheap_simps)
    apply (wpsimp simp: invoke_sched_context_def
                wp: sched_context_bind_tcb_valid_sched
                    sched_context_unbind_tcb_valid_sched sched_context_yield_to_valid_sched)+
  done

(* FIXME RT: move *)
lemma update_sched_context_known_sc:
  assumes "kheap s sc_ptr = Some (SchedContext sc n)"
  shows "update_sched_context sc_ptr (\<lambda>_. f sc) s = update_sched_context sc_ptr f s"
  using assms
  by (auto simp: obj_at_def update_sched_context_def get_object_def set_object_def gets_the_def
                 gets_def get_def assert_def return_def put_def fail_def bind_def)

lemma sc_ready_times_cong:
  assumes "tcbs = tcbs'"
  assumes "sc_ready_times_2 scs = sc_ready_times_2 scs'"
  shows "sc_ready_times_2 (tcb_sc_refill_cfgs_2 tcbs scs) = sc_ready_times_2 (tcb_sc_refill_cfgs_2 tcbs' scs')"
  by (clarsimp simp: sc_ready_times_2_def tcb_sc_refill_cfgs_2_def map_project_opt_map
                     assms[unfolded sc_ready_times_2_def])

crunches maybe_add_empty_tail
  for sc_tcb_sc_at[wp]: "\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)"

lemma refill_update_sc_tcb_sc_at[wp]:
  "refill_update sc_ptr mrefills budget period \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
   unfolding refill_update_def refill_add_tail_def update_refill_tl_def update_refill_hd_def
              bind_assoc update_sched_context_set_refills_rewrite
   apply (wpsimp wp: update_sched_context_wp set_refills_wp get_refills_wp)
   by (clarsimp simp: sc_tcb_sc_at_def obj_at_def)

lemma refill_new_sc_tcb_sc_at[wp]:
  "refill_new sc_ptr mrefills budget period \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  unfolding refill_new_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (fastforce simp: sc_tcb_sc_at_def obj_at_def)
  done

lemma set_refills_ep_at_pred[wp]:
  "set_refills sc_ptr refills \<lbrace>\<lambda>s. Q (ep_at_pred P p s)\<rbrace>"
  unfolding set_refills_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: obj_at_def simple_obj_at_def split: if_splits)
  done

lemma refill_update_valid_blocked:
  "\<lbrace>valid_blocked and K (0 < mrefills) and is_sc_active sc_ptr\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. valid_blocked\<rbrace>"
  unfolding valid_blocked_defs
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' simp: active_sc_tcb_at_def2)
  by (auto simp: is_sc_active_kh_simp)

lemma refill_new_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and current_time_bounded
    and K (period \<noteq> 0 \<longrightarrow> MIN_REFILLS \<le> max_refills \<and> budget \<le> period \<and> MIN_BUDGET \<le> budget
                          \<and> period \<le> MAX_PERIOD)
    and K (period = 0 \<longrightarrow> MIN_REFILLS = max_refills \<and> MIN_BUDGET \<le> budget \<and> budget \<le> MAX_PERIOD)
    and (\<lambda>s. \<exists>sc n. kheap s p = Some (SchedContext sc n)) \<rbrace>
   refill_new p max_refills budget period
   \<lbrace>\<lambda>rv. active_sc_valid_refills\<rbrace>"
  unfolding active_sc_valid_refills_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_new_not_active_sc)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps current_time_bounded_def
                        word_le_nat_alt)
  done

lemma refill_update_not_active_sc:
  "\<lbrace>\<lambda>s. if (scp = sc_ptr) then mrefills = 0 else \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv s.  \<not> pred_map active_scrc (sc_refill_cfgs_of s) scp\<rbrace>"
  unfolding refill_update_def refill_add_tail_def update_refill_tl_def
            update_refill_hd_def update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_wp get_refills_wp update_sched_context_wp)
  by (clarsimp simp: obj_at_def vs_all_heap_simps active_sc_def)

lemma refill_update_bounded_release_time:
  "\<lbrace>bounded_release_time scp and current_time_bounded
    and K (MIN_BUDGET \<le> budget)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. bounded_release_time scp\<rbrace>"
  unfolding refill_update_def set_refills_def maybe_add_empty_tail_def refill_add_tail_def
            update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp hoare_vcg_all_lift get_refills_wp)
  apply (clarsimp simp: pred_map_simps vs_all_heap_simps cfg_bounded_release_time_def obj_at_def
                        current_time_bounded_def)
  done

lemma refill_update_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and current_time_bounded
    and K (period \<noteq> 0 \<longrightarrow> MIN_REFILLS \<le> max_refills \<and> budget \<le> period \<and> MIN_BUDGET \<le> budget
                          \<and> period \<le> MAX_PERIOD)
    and K (period = 0 \<longrightarrow> MIN_REFILLS = max_refills \<and> MIN_BUDGET \<le> budget \<and> budget \<le> MAX_PERIOD)
    and is_active_sc p\<rbrace>
   refill_update p period budget max_refills
   \<lbrace>\<lambda>rv. active_sc_valid_refills\<rbrace>"
  unfolding active_sc_valid_refills_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_update_not_active_sc
                    refill_update_bounded_release_time refill_update_valid_refills)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps word_le_nat_alt
                        current_time_bounded_def bounded_release_time_def)
  apply (drule_tac x=p in spec; clarsimp)
  done

lemma update_sched_context_bound_sc_obj_tcb_at:
  "\<lbrace>\<lambda>s. if bound_sc_tcb_at ((=) (Some scp)) t s
        then Q (P (cur_time s) (sc_refill_cfg_of sc))
        else Q (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>
   update_sched_context scp (\<lambda>_. sc)
   \<lbrace>\<lambda>rv s. Q (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  unfolding refill_update_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps split: if_splits)
   apply (rule conjI; clarsimp)
   apply (erule back_subst; fastforce)
  apply (rule conjI; clarsimp)
  apply (erule back_subst; fastforce)
  done

lemma refill_update_active_sc_tcb_at':
  "\<lbrace>\<lambda>s. if bound_sc_tcb_at ((=) (Some sc_ptr)) t s then active_sc mrefills
       else active_sc_tcb_at t s\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  unfolding active_sc_tcb_at_def2
  apply (wpsimp wp: hoare_vcg_ex_lift)
  by (fastforce split: if_splits simp: tcb_at_kh_simps pred_map_def)

lemma refill_update_active_sc_tcb_at:
  "\<lbrace>\<lambda>s. active_sc_tcb_at t s \<and> active_sc mrefills\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. active_sc_tcb_at t\<rbrace>"
  unfolding active_sc_tcb_at_def2
  apply (wpsimp wp: hoare_vcg_ex_lift)
  by (fastforce split: if_splits simp: tcb_at_kh_simps pred_map_def)

lemma refill_update_budget_sufficient:
  "\<lbrace>budget_sufficient t and K (MIN_BUDGET \<le> budget)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. budget_sufficient t\<rbrace>"
  unfolding budget_sufficient_def2
  by (wpsimp wp: hoare_vcg_ex_lift)

lemma refill_update_bound_sc_obj_tcb_at_indep:
  "\<lbrace>(\<lambda>s. Q (bound_sc_obj_tcb_at (P (cur_time s)) t s))
    and (Not \<circ> bound_sc_tcb_at (\<lambda>p. p = Some sc_ptr) t)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv s. Q (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  unfolding refill_update_def set_refills_def maybe_add_empty_tail_def refill_add_tail_def
            update_refill_tl_def update_refill_hd_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp get_refills_wp)
  apply (intro impI conjI allI; erule back_subst[where P=Q])
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma refill_update_valid_ready_qs:
  "\<lbrace>valid_ready_qs and (\<lambda>s. \<forall>t. (bound_sc_tcb_at (\<lambda>p. p = Some sc_ptr) t) s \<longrightarrow> not_queued t s)\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  unfolding valid_ready_qs_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_update_bound_sc_obj_tcb_at_indep
           simp: Ball_def not_queued_def)

lemma set_sc_obj_ref_tcb_ready_times_other:
 "\<lbrace>\<lambda>s. P (tcb_ready_times_of s t) \<and> sc_with_tcb_prop sc_ptr (\<lambda>t s. \<not> Q t) s \<and> Q t\<rbrace>
  set_sc_obj_ref f sc_ptr x
  \<lbrace>\<lambda>_ s. P (tcb_ready_times_of s t)\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (fastforce simp: heap_upd_def tcb_ready_times_defs obj_at_def
                      map_project_simps opt_map_simps map_join_simps vs_all_heap_simps
               split: if_splits
               elim!: rsubst[of P]
              intro!: option_eqI[where opt'="map_project _ _ _"])

lemma maybe_add_empty_tail_tcb_ready_times_other:
 "\<lbrace>\<lambda>s. P (tcb_ready_times_of s t)
       \<and> pred_map (\<lambda>cfg. scrc_refills cfg \<noteq> []) (sc_refill_cfgs_of s) scp\<rbrace>
  maybe_add_empty_tail scp
  \<lbrace>\<lambda>_ s. P (tcb_ready_times_of s t)\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp set_refills_wp)
  apply (erule rsubst[of P])
  apply (clarsimp simp: tcb_ready_times_defs map_project_simps map_join_simps map_project_def map_join_def
                        vs_all_heap_simps opt_map_simps
                 split: if_splits)
  apply (case_tac "(tcb_scps_of s |> id |> sc_refill_cfgs_of s) t"; simp)
   apply (clarsimp simp: tcb_ready_times_defs map_project_simps map_join_simps map_project_def map_join_def
                         vs_all_heap_simps opt_map_simps obj_at_def
                  split: if_splits)
   apply (rename_tac scp')
   apply (frule_tac x=scp' in spec, fastforce)
  apply (rule sym)
  apply (clarsimp simp: tcb_ready_times_defs map_project_simps map_join_simps map_project_def map_join_def
                        vs_all_heap_simps opt_map_simps obj_at_def
                 split: if_splits)
  apply (rename_tac sc n scp' tcb sc' n')
  apply (case_tac "t = scp"; simp)
  apply (case_tac "scp' = scp"; simp)
  apply (rule_tac x="sc_refill_cfg_of sc'" in exI, simp)
  apply (rule_tac x=scp' in exI, clarsimp)
  done

lemma refill_update_sorted_release_q:
  "\<lbrace>\<lambda>s. sorted_release_q s \<and> sc_not_in_release_q sc_ptr s\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. sorted_release_q\<rbrace>"
  unfolding set_refills_def
  supply if_split[split del]
  apply (rule hoare_lift_Pf2[where f=release_queue, rotated], wpsimp)
  apply (rule sorted_release_q_2_valid_lift)
  apply (clarsimp simp: in_queue_2_def refill_update_def set_refills_def update_refill_tl_def
                        update_refill_hd_def)
  apply (rule hoare_seq_ext_skip
         , wpsimp wp: set_sc_obj_ref_tcb_ready_times_other[where Q="\<lambda>t. t \<in> set x" for x], simp?)+
   apply (fastforce simp: vs_all_heap_simps split: if_splits)
  apply (wpsimp wp: set_sc_obj_ref_tcb_ready_times_other[where Q="\<lambda>t. t \<in> set x" for x]
                    maybe_add_empty_tail_tcb_ready_times_other
              simp: set_refills_def refill_add_tail_def
         | wp update_sched_context_wp get_refills_wp)+
  apply (auto simp: vs_all_heap_simps split: if_splits)
  done

lemma refill_update_valid_release_q:
  "\<lbrace>valid_release_q and sc_not_in_release_q sc_ptr\<rbrace>
    refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  unfolding valid_release_q_def
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_update_sorted_release_q
                    refill_update_bound_sc_obj_tcb_at_indep
              simp: Ball_def)
  by (clarsimp simp: tcb_at_kh_simps pred_map_simps not_in_release_q_def)

lemma refill_update_released_ipc_queues:
  "\<lbrace>released_ipc_queues and sc_with_tcb_prop sc_ptr not_ipc_queued_thread\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  unfolding released_ipc_queues_defs
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_disj_lift
                    refill_update_bound_sc_obj_tcb_at_indep
              simp: Ball_def pred_tcb_at_eq_commute[symmetric])
  by (fastforce simp: pred_map_ipc_queued_thread_state_iff tcb_at_kh_simps pred_map_eq_def)

lemma refill_update_valid_sched_action:
  "\<lbrace>valid_sched_action and simple_sched_action\<rbrace>
   refill_update sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_sched_action\<rbrace>"
  unfolding valid_sched_action_def weak_valid_sched_action_def
  apply (wpsimp wp: hoare_vcg_conj_lift hoare_vcg_all_lift hoare_vcg_imp_lift'
                    refill_update_bound_sc_obj_tcb_at_indep
              simp: released_sc_tcb_at_def)
  by (clarsimp simp: simple_sched_action_def)

lemma refill_update_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set S and
    (\<lambda>s. \<forall>tcb_ptr.  bound_sc_tcb_at (\<lambda>t. t = (Some sc_ptr)) tcb_ptr s \<longrightarrow> tcb_ptr \<in> S)\<rbrace>
   refill_update sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding valid_blocked_defs
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_update_bound_sc_obj_tcb_at_indep)

lemma refill_new_budget_sufficient:
  "\<lbrace>\<lambda>s. if (pred_map_eq (Some sc_ptr) (tcb_scps_of s) t)
        then MIN_BUDGET \<le> budget
        else budget_sufficient t s\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. budget_sufficient t\<rbrace>"
  unfolding budget_sufficient_def2 refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: hoare_vcg_imp_lift' update_sched_context_wp set_refills_wp is_round_robin_wp)
  apply (auto simp: vs_all_heap_simps obj_at_kh_kheap_simps refill_sufficient_defs pred_map_def
             split: if_splits)
  done

lemma refill_new_valid_ready_qs:
  "\<lbrace>valid_ready_qs and K (MIN_BUDGET \<le> budget) and K (active_sc mrefills) and current_time_bounded\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_ready_qs\<rbrace>"
  apply (rule_tac hoare_weaken_pre)
  apply (rule_tac hoare_lift_Pf3[where f=ready_queues, rotated], wpsimp)
  unfolding valid_ready_qs_def
  apply (wpsimp wp: hoare_vcg_ball_lift hoare_vcg_all_lift hoare_vcg_conj_lift
                    refill_new_active_sc_tcb_at
                    refill_new_budget_ready
                    refill_new_budget_sufficient
              simp: released_sc_tcb_at_def)
  by (clarsimp simp: active_sc_def pred_map2_conj)

lemma refill_new_released_sc_tcb_at:
  "\<lbrace>(\<lambda>s. if (pred_map_eq (Some sc_ptr) (tcb_scps_of s) t)
         then active_sc mrefills \<and> MIN_BUDGET \<le> budget
         else released_sc_tcb_at t s)
    and current_time_bounded\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. released_sc_tcb_at t\<rbrace>"
  unfolding released_sc_tcb_at_def
  apply (wpsimp wp: refill_new_budget_sufficient refill_new_budget_ready
                 refill_new_active_sc_tcb_at
           simp: active_sc_def)
  done

lemma refill_new_schedulable_if_bound_sc_tcb_at:
  "\<lbrace>(\<lambda>s. if pred_map_eq (Some sc_ptr) (tcb_scps_of s) t
         then 0 < mrefills \<and> MIN_BUDGET \<le> budget
         else released_if_bound_sc_tcb_at t s)
    and current_time_bounded\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding  pred_conj_def
  apply (wpsimp wp: refill_new_budget_sufficient refill_new_budget_ready refill_new_released_sc_tcb_at
                 refill_new_active_sc_tcb_at hoare_vcg_disj_lift hoare_vcg_conj_lift
           simp: active_sc_def)
  done

lemma refill_new_schedulable_ipc_queues:
  "\<lbrace>released_ipc_queues and current_time_bounded and K(0 < mrefills) and K(MIN_BUDGET \<le> budget)\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. released_ipc_queues\<rbrace>"
  unfolding released_ipc_queues_defs
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_disj_lift
                    refill_new_active_sc_tcb_at refill_new_released_sc_tcb_at
              simp: Ball_def pred_tcb_at_eq_commute[symmetric])
  apply (clarsimp simp: active_sc_def)
  done

lemma refill_new_sorted_release_q:
  "\<lbrace>\<lambda>s. sorted_release_q s \<and> sc_not_in_release_q sc_ptr s\<rbrace>
   refill_new sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. sorted_release_q\<rbrace>"
  supply if_split[split del]
  apply (rule hoare_lift_Pf2[where f=release_queue, rotated], wpsimp)
  apply (rule sorted_release_q_2_valid_lift)
  apply (clarsimp simp: in_queue_2_def refill_new_def)
  apply (wpsimp wp: set_sc_obj_ref_tcb_ready_times_other[where Q="\<lambda>t. t \<in> set x" for x]
                    maybe_add_empty_tail_tcb_ready_times_other
         | wp update_sched_context_wp)+
  by (fastforce simp: vs_all_heap_simps)

lemma refill_new_valid_release_q:
  "\<lbrace>valid_release_q and sc_not_in_release_q sc_ptr\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_release_q\<rbrace>"
  unfolding valid_release_q_def
  apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift refill_new_active_sc_tcb_at
                    refill_new_sorted_release_q
              simp: Ball_def)
  by (clarsimp simp: tcb_at_kh_simps pred_map_eq_def not_in_release_q_def)

lemma refill_new_valid_sched_action:
  "\<lbrace>valid_sched_action and simple_sched_action\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_sched_action\<rbrace>"
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: is_round_robin_wp update_sched_context_wp set_refills_valid_sched_action)
  apply (auto simp: valid_sched_action_def is_activatable_def weak_valid_sched_action_def
                    simple_sched_action_def switch_in_cur_domain_def vs_all_heap_simps
                    obj_at_kh_kheap_simps)
  done

lemma refill_new_valid_blocked_except_set:
  "\<lbrace>valid_blocked_except_set S and
    (\<lambda>s. \<forall>tcb_ptr. bound_sc_tcb_at (\<lambda>t. t = Some sc_ptr) tcb_ptr s \<longrightarrow> tcb_ptr \<in> S)\<rbrace>
   refill_new sc_ptr mrefills budget period
   \<lbrace>\<lambda>rv. valid_blocked_except_set S\<rbrace>"
  unfolding valid_blocked_defs
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' simp: active_sc_tcb_at_def2)
  by auto

lemma refill_new_is_sc_active:
  "\<lbrace>K (P (active_sc max_refills))\<rbrace>
     refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>rv s. P (is_sc_active sc_ptr s)\<rbrace>"
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: update_sched_context_wp is_round_robin_wp set_refills_wp)
  apply (clarsimp simp: sc_tcb_sc_at_def obj_at_def is_sc_active_def)
  done

lemma reply_push_sc_tcb_sc_at:
  "reply_push caller callee reply_ptr False \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  apply clarsimp
  by (wpsimp wp: hoare_drop_imps)

lemma make_arch_fault_msg_obj_at_sc_tcb_sc_at[wp]:
  "make_arch_fault_msg a b \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P p s)\<rbrace>"
  by (wpsimp simp: sc_tcb_sc_at_def wp: make_arch_fault_msg_obj_at)

crunches possible_switch_to, do_ipc_transfer, postpone
  for sc_tcb_sc_at[wp]: "\<lambda>s. Q (sc_tcb_sc_at P p s)"
  (wp: crunch_wps)

lemma send_ipc_sc_tcb_sc_at:
  "send_ipc block call badge can_grant can_grant_reply False thread epptr \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  unfolding send_ipc_def
  by (wpsimp wp: hoare_drop_imps reply_push_sc_tcb_sc_at get_simple_ko_wp hoare_vcg_all_lift)

lemma send_fault_ipc_sc_tcb_sc_at:
  "send_fault_ipc tptr handler_cap fault False \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  unfolding send_fault_ipc_def
  by (wpsimp wp: hoare_drop_imps reply_push_sc_tcb_sc_at send_ipc_sc_tcb_sc_at)

lemma sc_refills_update_sc_tcb_sc_at[wp]:
  "update_sched_context csc_ptr (sc_refills_update a) \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  by (wpsimp wp: update_sched_context_sc_at_pred_n_indep)

lemma refill_reset_rr_valid_sched_misc[wp]:
  "refill_reset_rr scp
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s)
          (sc_tcbs_of s) (sc_replies_of s) (cur_time s) (cur_domain s) (cur_thread s)
          (idle_thread s) (ready_queues s) (release_queue s) (scheduler_action s) (tcbs_of s)\<rbrace>"
  unfolding refill_reset_rr_def update_refill_tl_def update_refill_hd_def
            update_sched_context_set_refills_rewrite
  by wpsimp

lemma check_budget_sc_tcb_sc_at[wp]:
  "check_budget \<lbrace>sc_tcb_sc_at P sc_ptr\<rbrace>"
  supply if_split [split del]
  unfolding check_budget_def charge_budget_def end_timeslice_def
            handle_timeout_def refill_budget_check_defs refill_reset_rr_def update_refill_tl_def
            update_sched_context_set_refills_rewrite schedule_used_defs
  apply clarsimp
  apply (wpsimp wp: hoare_drop_imps send_fault_ipc_sc_tcb_sc_at hoare_vcg_if_lift2  whileLoop_wp'
              simp: Let_def)
  done

lemma check_budget_simple_sched_action[wp]:
  "check_budget \<lbrace>simple_sched_action\<rbrace>"
  unfolding check_budget_def charge_budget_def
  apply (wpsimp wp: hoare_drop_imps hoare_vcg_if_lift2)
  done

lemma tcb_fault_update_sym_refs[wp]:
  "thread_set (tcb_fault_update f) tptr
   \<lbrace>\<lambda>s. sym_refs (state_refs_of s)\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  apply (erule_tac P="sym_refs" in back_subst)
  apply (rule ext)
  by (clarsimp simp: state_refs_of_def dest!: get_tcb_SomeD)

crunches end_timeslice
  for valid_sched_misc[wp]:
    "\<lambda>s::'state_ext state. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s)
                             (cur_thread s) (idle_thread s) (etcbs_of s)"
  (wp: crunch_wps ignore: thread_set)

lemma end_timeslice_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> ct_not_in_release_q s \<and> ct_active s \<and> cur_sc_chargeable s
         \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
         \<and> active_sc_tcb_at (cur_thread s) s\<rbrace>
   end_timeslice canTimeout
   \<lbrace>\<lambda>_. (valid_release_q)::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  apply (wpsimp wp: handle_timeout_valid_release_q thread_get_wp' postpone_valid_release_q)
  apply (prop_tac "cur_sc_tcb_are_bound s", clarsimp simp: cur_sc_chargeable_def vs_all_heap_simps)
  apply (clarsimp simp: heap_refs_inv_def)
  apply (prop_tac "heap_refs_retract_at (tcb_scps_of s) (sc_tcbs_of s) (cur_thread s)", clarsimp)
  apply (frule (1) heap_refs_retract_atD)
  by (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise ct_in_state_kh_simp vs_all_heap_simps runnable_eq)

lemma end_timeslice_valid_ready_qs:
  "\<lbrace>valid_ready_qs and valid_sched_action and released_ipc_queues and
    ct_not_queued and ct_active and scheduler_act_sane
    and cur_sc_chargeable and active_sc_valid_refills
    and (\<lambda>s. active_sc_tcb_at (cur_thread s) s)\<rbrace>
   end_timeslice canTimeout
   \<lbrace>\<lambda>_. valid_ready_qs ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  apply (wpsimp wp: handle_timeout_valid_ready_qs thread_get_wp' postpone_valid_ready_qs)
  apply (subgoal_tac "bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) (cur_thread s) s")
   apply (clarsimp dest!: get_tcb_SomeD
                    simp: obj_at_kh_kheap_simps vs_all_heap_simps pred_map_simps
                          ct_in_state_def runnable_eq_active is_timeout_fault_def)
  apply (clarsimp simp: cur_sc_chargeable_def vs_all_heap_simps tcb_at_kh_simps
                 dest!: get_tcb_SomeD)
  done

crunches handle_timeout
  for ready_or_release[wp]: "ready_or_release :: 'state_ext state \<Rightarrow> _"

lemma end_timeslice_ready_or_release[wp]:
  "\<lbrace>ready_or_release and ready_qs_etcb_eq and ct_not_in_release_q\<rbrace>
   end_timeslice canTimeout
   \<lbrace>\<lambda>_. ready_or_release :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: end_timeslice_def get_tcb_queue_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)+
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  done

lemma end_timeslice_valid_blocked[wp]:
  "end_timeslice canTimeout \<lbrace>valid_blocked_except_set S ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  by (wpsimp wp: handle_timeout_valid_blocked thread_get_wp'
                 tcb_sched_append_valid_blocked_except_set_const
                 postpone_valid_blocked_except_set)

lemma end_timeslice_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> active_sc_tcb_at (cur_thread s) s
        \<and> active_sc_valid_refills s\<rbrace>
   end_timeslice canTimeout
   \<lbrace>\<lambda>_. released_ipc_queues ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  by (wpsimp wp: handle_timeout_released_ipc_queues thread_get_wp' simp: is_timeout_fault_def)

lemma head_insufficient_loop_weak_valid_sched_action_not:
  "\<lbrace>\<lambda>s. weak_valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   head_insufficient_loop csc_ptr
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: set_refills_wp get_refills_wp
                simp: non_overlapping_merge_refills_def refill_pop_head_def update_refill_hd_rewrite
                      update_sched_context_set_refills_rewrite)
    apply (fastforce simp: weak_valid_sched_action_def vs_all_heap_simps
                           obj_at_def scheduler_act_not_def)
   apply (wpsimp wp: set_refills_wp get_refills_wp
               simp: non_overlapping_merge_refills_def refill_pop_head_def)
  apply (wpsimp wp: set_refills_wp get_refills_wp
              simp: non_overlapping_merge_refills_def refill_pop_head_def)
  done

lemma refill_head_overlapping_loop_weak_valid_sched_action_not:
  "\<lbrace>\<lambda>s. weak_valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   refill_head_overlapping_loop csc_ptr
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: set_refills_wp get_refills_wp
                simp: merge_refills_def refill_pop_head_def update_refill_hd_rewrite
                      update_sched_context_set_refills_rewrite)
    apply (fastforce simp: weak_valid_sched_action_def vs_all_heap_simps
                           obj_at_def scheduler_act_not_def)
   apply (wpsimp wp: set_refills_wp get_refills_wp
               simp: merge_refills_def refill_pop_head_def)+
  done

lemma handle_overrun_loop_weak_valid_sched_action_not:
  "\<lbrace>\<lambda>s. weak_valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s \<and> cur_sc s = csc_ptr\<rbrace>
   handle_overrun_loop sc_ptr
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply handle_overrun_loop_body_simple
    apply (fastforce simp: weak_valid_sched_action_def vs_all_heap_simps
                           obj_at_def scheduler_act_not_def)
   apply handle_overrun_loop_body_simple
  apply (wpsimp wp: set_refills_wp get_refills_wp
              simp: merge_refills_def refill_pop_head_def)
  done

lemma refill_budget_check_weak_valid_sched_action_act_not:
  "\<lbrace>weak_valid_sched_action and (\<lambda>s. sc_scheduler_act_not (cur_sc s) s)\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  supply map_map[simp del]
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp], rename_tac csc_ptr)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip, wp handle_overrun_loop_weak_valid_sched_action_not)
   apply force
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule_tac B="\<lambda>_ s. weak_valid_sched_action s \<and> sc_scheduler_act_not (cur_sc s) s
                           \<and> cur_sc s = csc_ptr"
               in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_wp get_refills_wp
               simp: update_sched_context_set_refills_rewrite update_refill_hd_rewrite
                     schedule_used_defs)
   apply (fastforce simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps
                          obj_at_def scheduler_act_not_def
                   split: if_splits)
  apply (wpsimp wp: head_insufficient_loop_weak_valid_sched_action_not)
  done

lemma refill_budget_check_round_robin_weak_valid_sched_action:
  "\<lbrace>weak_valid_sched_action and (\<lambda>s. sc_scheduler_act_not (cur_sc s) s)\<rbrace>
   refill_budget_check_round_robin consumed
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
            update_sched_context_set_refills_rewrite
  by (wpsimp wp: set_refills_weak_valid_sched_action_act_not is_round_robin_wp)

crunches schedule_used
  for cur_sc_tcb[wp]: cur_sc_tcb
  (simp: schedule_used_defs wp: crunch_wps)

lemma refill_budget_check_cur_sc_tcb[wp]:
  "refill_budget_check usage \<lbrace>cur_sc_tcb\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (handle_overrun_loop_simple
          ; clarsimp simp: obj_at_def cur_sc_tcb_def sc_at_pred_n_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (head_insufficient_loop_simple
         ; clarsimp simp: obj_at_def cur_sc_tcb_def sc_at_pred_n_def)
  done

lemma refill_budget_check_active_sc_tcb_at':
  assumes "\<And>P. refill_budget_check usage \<lbrace>\<lambda>s. P (t s)\<rbrace>"
  shows "refill_budget_check usage \<lbrace>\<lambda>s. P (active_sc_tcb_at (t s) s)\<rbrace>"
  by (rule hoare_lift_Pf[where f=t, OF _ assms]) wp

lemmas refill_budget_check_active_sc_tcb_at_ct[wp]
  = refill_budget_check_active_sc_tcb_at'[where t=cur_thread, OF refill_budget_check_valid_sched_misc]

lemma refill_budget_check_round_robin_active_sc_tcb_at[wp]:
  "refill_budget_check_round_robin usage \<lbrace>\<lambda>s. P (active_sc_tcb_at t s)\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_tl_def update_refill_hd_def
  by (wpsimp wp: hoare_drop_imp)

lemma refill_budget_check_round_robin_active_sc_tcb_at':
  assumes "\<And>P. refill_budget_check_round_robin usage \<lbrace>\<lambda>s. P (t s)\<rbrace>"
  shows "refill_budget_check_round_robin usage \<lbrace>\<lambda>s. P (active_sc_tcb_at (t s) s)\<rbrace>"
  by (rule hoare_lift_Pf[where f=t, OF _ assms]) wp

lemmas refill_budget_check_round_robin_active_sc_tcb_at_ct[wp]
  = refill_budget_check_round_robin_active_sc_tcb_at'[where t=cur_thread, OF refill_budget_check_round_robin_valid_sched_misc]

lemma update_time_stamp_released_ipc_queues[wp]:
  "\<lbrace>released_ipc_queues and valid_machine_time\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding released_ipc_queues_defs released_sc_tcb_at_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_disj_lift update_time_stamp_budget_ready)

crunches cap_delete
  for scheduler_act_sane[wp]: " scheduler_act_sane :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma cap_revoke_scheduler_act_sane:
  "\<lbrace>simple_sched_action\<rbrace>
   cap_revoke slot
   \<lbrace>\<lambda>rv. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_strengthen_post)
   apply (rule validE_valid, rule cap_revoke_preservation)
     apply (wpsimp wp: preemption_point_inv  simp: ct_in_state_def)+
  done

lemma cap_delete_ct_not_in_release_qE_E:
  "\<lbrace>ct_not_in_release_q\<rbrace>
   cap_delete x
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cap_delete_def by wpsimp

lemma set_tcb_obj_ref_ct_in_state_no_change:
  "(\<And>y. P (tcb_state y) \<Longrightarrow> P (tcb_state (f (\<lambda>_. new) y))) \<Longrightarrow>
   set_tcb_obj_ref f ref new \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding set_tcb_obj_ref_def
  apply (wpsimp wp: set_object_wp)
  apply (clarsimp dest!: get_tcb_SomeD simp: ct_in_state_def pred_tcb_at_def obj_at_def)
  done

lemma preemption_point_ct_in_state[wp]:
  "preemption_point \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: preemption_point_inv; clarsimp simp: ct_in_state_def)

(* FIXME: crunch call stack should only display on failure *)
crunches finalise_cap
  for ct_not_blocked[wp]: "ct_not_blocked :: 'state_ext state \<Rightarrow> _"
  (ignore: set_tcb_obj_ref set_object thread_set
       wp: set_thread_state_ct_in_state crunch_wps set_tcb_obj_ref_ct_in_state_no_change thread_set_ct_in_state maybeM_inv)

end

context DetSchedSchedule_AI_det_ext begin

crunches cap_swap_ext
  for ct_not_blocked[wp]: "ct_not_blocked :: det_state \<Rightarrow> _"
  (wp: crunch_wps dxo_wp_weak ignore_del: cap_swap_ext)

end

lemmas rec_del_invs''_CTEDeleteCall = rec_del_invs''
                                      [where call = "(CTEDeleteCall x True)" for x,
                                       simplified,
                                       simplified pred_conj_def,
                                       THEN use_specE']

lemma tcb_release_enqueue_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and (\<lambda>s. tcb_ptr \<noteq> cur_thread s)\<rbrace>
   tcb_release_enqueue tcb_ptr
   \<lbrace>\<lambda>xa. ct_not_in_release_q\<rbrace>"
  unfolding postpone_def
  apply (rule hoare_weaken_pre, wps)
  by wpsimp+

context DetSchedSchedule_AI begin

lemma cap_delete_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   cap_delete x
   \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cap_delete_def
  apply (rule_tac Q="\<lambda>_. cur_sc_chargeable and ct_not_blocked and invs "
                   in hoare_strengthen_post)
   apply (wpsimp wp: rec_del_invs''_CTEDeleteCall
                     [where Q="cur_sc_chargeable and ct_not_blocked",
                      simplified])
      apply (wpsimp wp: finalise_cap_cur_sc_chargeable)
     apply (wpsimp simp:)
    apply (wpsimp wp: preemption_point_inv)
   apply (clarsimp simp: ct_in_state_def)+
  done

crunches install_tcb_cap
  for ct_not_blocked[wp]: "ct_not_blocked :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv)

lemma install_tcb_cap_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and ct_not_blocked\<rbrace>
   install_tcb_cap target slot n slot_opt
   \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv cap_delete_cur_sc_chargeable)

crunches restart
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  (wp: maybeM_inv)

lemma reply_unlink_tcb_ct_in_state_weak:
  "\<lbrace>ct_in_state P and (\<lambda>s. t \<noteq> cur_thread s \<or> P Inactive)\<rbrace>
   reply_unlink_tcb t r
  \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding reply_unlink_tcb_def
  by (wpsimp wp: sts_ctis_neq gts_wp get_simple_ko_wp)

lemma blocked_cancel_ipc_ct_in_state:
  "\<lbrace>ct_in_state P and (\<lambda>s. x \<noteq> cur_thread s \<or> P Inactive)\<rbrace>
   blocked_cancel_ipc a x c
   \<lbrace>\<lambda>rv. ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding blocked_cancel_ipc_def
  apply (wpsimp wp: set_thread_state_ct_st hoare_vcg_if_lift2 hoare_vcg_imp_lift get_simple_ko_wp
                    reply_unlink_tcb_ct_in_state_weak get_ep_queue_wp get_blocking_object_wp
                    hoare_vcg_disj_lift hoare_vcg_all_lift)
  by auto

lemma reply_remove_tcb_ct_in_state:
  "\<lbrace>ct_in_state P and (\<lambda>s. x \<noteq> cur_thread s \<or> P Inactive)\<rbrace>
   reply_remove_tcb x y
   \<lbrace>\<lambda>rv. ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding reply_remove_tcb_def
  by (wpsimp wp: set_thread_state_ct_st hoare_vcg_if_lift2 hoare_vcg_imp_lift get_simple_ko_wp
                    reply_unlink_tcb_ct_in_state_weak get_ep_queue_wp get_blocking_object_wp
                    hoare_vcg_disj_lift hoare_vcg_all_lift get_sk_obj_ref_wp gts_wp)

lemma cancel_signal_ct_in_state:
  "\<lbrace>ct_in_state P and (\<lambda>s. x \<noteq> cur_thread s \<or> P Inactive)\<rbrace>
   cancel_signal x ntfnptr
   \<lbrace>\<lambda>rv. ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding cancel_signal_def
  by (wpsimp wp: set_thread_state_ct_st hoare_vcg_if_lift2 hoare_vcg_imp_lift get_simple_ko_wp
                    reply_unlink_tcb_ct_in_state_weak get_ep_queue_wp get_blocking_object_wp
                    hoare_vcg_disj_lift hoare_vcg_all_lift get_sk_obj_ref_wp gts_wp)

lemma cancel_ipc_ct_in_state:
  "\<lbrace> ct_in_state P and (\<lambda>s. ipc_queued_thread x s \<longrightarrow> x = cur_thread s \<longrightarrow> P Inactive)\<rbrace>
   cancel_ipc x
   \<lbrace>\<lambda>rv. ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding cancel_ipc_def
  apply (wpsimp wp: blocked_cancel_ipc_ct_in_state reply_remove_tcb_ct_in_state cancel_signal_ct_in_state
                     hoare_vcg_imp_lift' thread_set_ct_in_state gts_wp)
  by (auto simp: tcb_at_kh_simps pred_map_eq_normalise vs_all_heap_simps)

(* FIXME: move *)
lemma if_cond_then_disj_strg:
  "if A then C else B \<Longrightarrow> A \<or> B"
  by (simp split: if_split_asm)

lemma sched_context_cancel_yield_to_ct_in_state[wp]:
  "sched_context_cancel_yield_to thread \<lbrace>ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: sched_context_cancel_yield_to_def set_tcb_obj_ref_def)
  apply (wpsimp wp: get_tcb_obj_ref_wp update_sched_context_wp set_object_wp)
  apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def get_tcb_def)
  done

lemma suspend_ct_in_state:
  "\<lbrace>\<lambda>s. if x = cur_thread s then P Inactive else ct_in_state P s \<and> ct_not_blocked s\<rbrace>
   suspend x
   \<lbrace>\<lambda>rv. ct_in_state P:: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: suspend_def update_restart_pc_def)
  apply (rule hoare_seq_ext[rotated, where A=A and B="\<lambda>_. A" for A])
   apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' cancel_ipc_ct_in_state)
  apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift set_thread_state_ct_st
                    set_tcb_obj_ref_ct_in_state get_tcb_obj_ref_wp hoare_vcg_all_lift
         | strengthen if_cond_then_disj_strg)
  done

lemma install_tcb_frame_cap_cur_sc_chargeable:
  "\<lbrace>invs and cur_sc_chargeable and ct_not_blocked\<rbrace>
      install_tcb_frame_cap t sl buf
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_frame_cap_def
  by (wpsimp wp: cap_delete_cur_sc_chargeable)

lemma tcc_cur_sc_chargeable:
  "\<lbrace>invs and tcb_inv_wf (ThreadControlCaps t sl fh th croot vroot buf)
    and cur_sc_chargeable and ct_not_blocked\<rbrace>
   invoke_tcb (ThreadControlCaps t sl fh th croot vroot buf)
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_cong[cong]
  apply (simp add: split_def cong: option.case_cong)
  apply wp
       \<comment> \<open>install_tcb_frame_cap\<close>
       apply (wpsimp wp: install_tcb_frame_cap_cur_sc_chargeable)
      \<comment> \<open>install_tcb_caps\<close>
      apply (invoke_tcb_install_tcb_cap_helper wp: install_tcb_cap_cur_sc_chargeable)+
  \<comment> \<open>cleanup\<close>
  apply (simp)
  apply (strengthen tcb_cap_always_valid_strg)
  apply (clarsimp cong: conj_cong)
  \<comment> \<open>resolve generated preconditions\<close>
  apply (intro conjI impI;
         clarsimp simp: is_cnode_or_valid_arch_is_cap_simps tcb_ep_slot_cte_wp_ats real_cte_at_cte
                 dest!: is_valid_vtable_root_is_arch_cap)
      apply (all \<open>clarsimp simp: is_cap_simps cte_wp_at_caps_of_state valid_fault_handler_def\<close>)
     apply (all \<open>clarsimp simp: obj_at_def is_tcb typ_at_eq_kheap_obj cap_table_at_typ\<close>)
  by auto

crunches maybe_sched_context_unbind_tcb, maybe_sched_context_bind_tcb, set_priority
         , bind_notification
  for scheduler_act_sane[wp]: scheduler_act_sane
  (wp: crunch_wps simp: crunch_simps)

crunches install_tcb_cap, install_tcb_frame_cap
  for scheduler_act_sane[wp]: "scheduler_act_sane :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps preemption_point_inv ignore: check_cap_at simp: check_cap_at_def crunch_simps)

lemma test_possible_switch_to_scheduler_act_sane':
  "\<lbrace>scheduler_act_sane and (\<lambda>s. st_tcb_at runnable thread s \<longrightarrow> thread \<noteq> cur_thread s)\<rbrace>
   test_possible_switch_to thread
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  unfolding test_possible_switch_to_def
  apply (wpsimp wp: possible_switch_to_scheduler_act_sane' is_schedulable_wp)
  by (clarsimp simp: schedulable_def2)

lemma restart_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and (\<lambda>s. thread = cur_thread s \<longrightarrow> ct_in_state activatable s)\<rbrace>
   restart thread
   \<lbrace>\<lambda>rv. scheduler_act_sane:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding restart_def
  apply (wpsimp wp: test_possible_switch_to_scheduler_act_sane' gts_wp sts_st_tcb_at_pred
                    hoare_vcg_if_lift2 hoare_vcg_imp_lift maybeM_inv)
  by (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)

lemma invoke_tcb_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_in_state activatable\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>rv. scheduler_act_sane:: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (case_tac iv; simp)
          apply (find_goal \<open>match premises in "_ = CopyRegisters _ _ _ _ _ _ _" \<Rightarrow> \<open>-\<close>\<close>)
          apply (wpsimp wp: hoare_vcg_if_lift2 mapM_x_wp_inv hoare_vcg_imp_lift' suspend_ct_in_state)
          apply (clarsimp split: if_split)
         apply (find_goal \<open>match premises in "_ = NotificationControl _ _" \<Rightarrow> \<open>-\<close>\<close>)
         apply (rename_tac t ntfn)
         apply (case_tac ntfn; wpsimp)
        apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)+
  done

lemma reply_push_scheduler_act_sane[wp]:
  "reply_push caller callee reply_ptr can_donate \<lbrace>scheduler_act_sane:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift | safe)+

lemma invoke_tcb_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable and invs and tcb_inv_wf x and ct_not_blocked\<rbrace>
   invoke_tcb x
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac x)
  defer 5
  defer 4
    apply wpsimp+
    apply (case_tac x82; wpsimp)
    apply ((wpsimp wp: install_tcb_cap_cur_sc_chargeable)+)[2]
  apply (wpsimp wp: tcc_cur_sc_chargeable[simplified])
  done

lemma cap_revoke_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable
    and invs
    and ct_not_blocked\<rbrace>
   cap_revoke (a, b)
   \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_strengthen_post, rule cap_revoke_preservation2)
    apply (wpsimp wp: preemption_point_inv cap_delete_cur_sc_chargeable)+
     apply (clarsimp simp: ct_in_state_def)+
  done

lemma invoke_cnode_cur_sc_chargeable:
  "\<lbrace>cur_sc_chargeable
    and invs and ct_not_blocked\<rbrace>
   invoke_cnode x
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (wpsimp wp: cap_revoke_cur_sc_chargeable simp: invoke_cnode_def)+
  apply (rule valid_validE_E)
  apply (wpsimp wp: cap_delete_cur_sc_chargeable)+
  done

crunches cancel_badged_sends
  for scheduler_act_sane[wp]: scheduler_act_sane

crunches invoke_cnode
  for scheduler_act_sane[wp]: "scheduler_act_sane :: 'state_ext state \<Rightarrow> _"

lemma invs_strengthen_cur_sc_tcb_only_sym_bound:
  "\<lbrakk>cur_sc_tcb_are_bound s; invs s\<rbrakk> \<Longrightarrow> cur_sc_tcb_only_sym_bound s"
  unfolding cur_sc_tcb_only_sym_bound_def
  apply (clarsimp simp: tcb_at_kh_simps[symmetric] pred_tcb_at_eq_commute)
  apply (intro conjI; intro allI impI)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
   apply (subst (asm) sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[OF refl refl], clarsimp)
  apply (subst (asm) sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[OF refl refl], clarsimp)
  apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
  done

lemma perform_invocation_cur_sc_chargeable:
  "\<lbrace>cur_sc_tcb_are_bound and ct_not_blocked and invs and
    valid_invocation iv\<rbrace>
   perform_invocation a b c iv
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac iv; simp)
             apply (wpsimp simp:)
              apply (strengthen strengthen_cur_sc_chargeable)
              apply (wpsimp wp: cur_sc_chargeable_invoke_untypedE_R)
             apply (fastforce intro: invs_strengthen_cur_sc_tcb_only_sym_bound)
            apply wpsimp+
         apply (wpsimp wp: hoare_vcg_E_conj hoare_elim_pred_conjE2 invoke_tcb_cur_sc_chargeable)
         apply (fastforce intro: invs_strengthen_cur_sc_chargeable simp: valid_sched_def)
        apply wpsimp+
      apply (wpsimp wp: invoke_cnode_cur_sc_chargeable invoke_cnode_scheduler_act_sane)
     apply (fastforce intro: invs_strengthen_cur_sc_chargeable simp: valid_sched_def)
    apply wpsimp
    apply (fastforce intro: invs_strengthen_cur_sc_chargeable)
   apply wpsimp
  apply wpsimp
  apply (fastforce intro: invs_strengthen_cur_sc_chargeable)
  done

(* FIXME: move *)
lemma active_activatable:
  "active st \<Longrightarrow> activatable st"
  by (case_tac st; simp)

lemma handle_invocation_cur_sc_chargeable:
  "\<lbrace>cur_sc_tcb_are_bound and invs and ct_active\<rbrace>
   handle_invocation a b c d x
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def syscall_def
  apply (simp add: handle_invocation_def ts_Restart_case_helper split_def
                   liftE_liftM_liftME liftME_def bindE_assoc)
  apply (wpsimp wp: syscall_valid perform_invocation_cur_sc_chargeable
                    set_thread_state_ct_in_state hoare_drop_imps set_thread_state_runnable_valid_sched)
      apply (rule validE_cases_valid, clarsimp)
      apply (subst validE_R_def[symmetric])
      apply (rule_tac Q'="\<lambda>r s.
             cur_sc_tcb_are_bound s \<and>
             thread = cur_thread s \<and>
             ct_active s \<and>
             invs s \<and> valid_invocation r s" in hoare_post_imp_R[rotated])
       apply (clarsimp)
       apply (intro conjI)
          apply (fastforce simp: ct_in_state_def runnable_eq_active)
         apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def)
        apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def)
      apply (wp decode_inv_wf)
     apply wpsimp
     apply (rule validE_cases_valid, clarsimp)
     apply (subst validE_R_def[symmetric])
     apply wpsimp+
  apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def is_tcb invs_valid_objs)
  done

crunches check_domain_time
  for ct_active[wp]: ct_active

lemma handle_event_cur_sc_chargeable:
  "\<lbrace>cur_sc_tcb_are_bound and invs and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)\<rbrace>
   handle_event e
   -, \<lbrace>\<lambda>rv. cur_sc_chargeable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp)
       apply (rename_tac syscall)
       apply (case_tac syscall; simp)
                 apply (wpsimp simp: handle_send_def handle_call_def
                                 wp: handle_invocation_cur_sc_chargeable check_budget_restart_true
                        | erule active_from_running)+
  done

lemma misc_cur_sc_tcb_bound[wp]:
  "update_sched_context csc_ptr f \<lbrace>\<lambda>s. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) (cur_thread s) s\<rbrace>"
  "set_refills a b \<lbrace>\<lambda>s. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) (cur_thread s) s\<rbrace>"
  "refill_budget_check t1 \<lbrace>\<lambda>s. bound_sc_tcb_at (\<lambda>x. x = Some (cur_sc s)) (cur_thread s) s\<rbrace>"
  apply (rule hoare_lift_Pf[where f=cur_thread])
  apply (rule hoare_lift_Pf[where f=cur_sc])
  apply wpsimp+
  apply (rule hoare_lift_Pf[where f=cur_thread])
  apply (rule hoare_lift_Pf[where f=cur_sc])
  apply wpsimp+
  apply (rule hoare_lift_Pf[where f=cur_sc])
  apply (wpsimp)+ (* fixme: cleanup *)
  done

lemma round_robin_refills_sum:
  "length (sc_refills sc) = MIN_REFILLS \<Longrightarrow>
   r_amount (refill_hd sc) + r_amount (refill_tl sc) = refills_sum (sc_refills sc)"
  apply (clarsimp simp: MIN_REFILLS_def)
  apply (case_tac "sc_refills sc"; simp)
  apply (case_tac "list"; simp)
  done

lemma update_sched_context_weak_valid_sched_action':
  "\<lbrace>weak_valid_sched_action
    and K (\<forall>sc. sc_refills (f sc) = sc_refills (sc))
    and K (\<forall>sc. sc_active sc \<longrightarrow> sc_active (f sc))\<rbrace>
      update_sched_context ref f
   \<lbrace>\<lambda>_. weak_valid_sched_action\<rbrace>"
  apply (wpsimp simp: set_object_def wp: get_object_wp update_sched_context_wp)
  apply (clarsimp simp: weak_valid_sched_action_def)
  apply (prop_tac "budget_ready t s";
         clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps split: if_splits)
  apply (prop_tac "t \<noteq> ref"; clarsimp)
  apply (rule_tac x=ref'a in exI)
  by fastforce

lemma update_sched_context_valid_blocked':
  "\<lbrace>valid_blocked and K (\<forall>sc. sc_active sc \<longleftrightarrow> sc_active (f sc))\<rbrace>
     update_sched_context ptr f \<lbrace>\<lambda>_. valid_blocked\<rbrace>"
  apply (wpsimp simp: set_object_def wp: get_object_wp update_sched_context_wp)
  apply (clarsimp simp: valid_blocked_defs)
  apply (prop_tac "active_sc_tcb_at t s \<and> pred_map active (tcb_sts_of s) t",
         clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps split: if_splits)
  by fastforce

lemma sc_with_tcb_propE1:
  "P t s
   \<Longrightarrow> (\<forall>tp. bound_sc_tcb_at ((=) (Some scp)) tp s \<longrightarrow> tp = t)
   \<Longrightarrow> sc_with_tcb_prop scp P s"
 by (clarsimp simp: tcb_at_kh_simps pred_map_eq_def)

lemma ct_active_sc_helper:
  "\<And>s. (\<forall>t. t = (cur_thread s) \<longrightarrow> P (active_sc_tcb_at t s)) \<Longrightarrow>
   P (active_sc_tcb_at (cur_thread s) s)"
  by simp

lemma refill_budget_check_round_robin_released_ipc_queues:
  "\<lbrace>released_ipc_queues and cur_sc_not_blocked\<rbrace>
   refill_budget_check_round_robin usage
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: refill_budget_check_round_robin_def update_refill_tl_def
                        update_refill_hd_def bind_assoc update_sched_context_set_refills_rewrite)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp wp: set_refills_released_ipc_queues)
   apply (fastforce simp: cur_sc_not_blocked_def pred_map_ipc_queued_thread_state_iff)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (wpsimp wp: set_refills_released_ipc_queues)
  apply (fastforce simp: cur_sc_not_blocked_def pred_map_ipc_queued_thread_state_iff)
  done

lemma refill_pop_head_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   refill_pop_head sc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite)
  apply (wpsimp wp: set_refills_released_ipc_queues get_refills_wp)
  apply (clarsimp simp: pred_map_ipc_queued_thread_state_iff cur_sc_not_blocked_def)
  done

lemma refill_pop_head_cur_sc_not_blocked:
  "refill_pop_head sc_ptr \<lbrace>cur_sc_not_blocked\<rbrace>"
  apply (clarsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: cur_sc_not_blocked_def vs_all_heap_simps)
  done

lemma non_overlapping_merge_refills_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   non_overlapping_merge_refills sc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: non_overlapping_merge_refills_def update_refill_hd_rewrite bind_assoc)
  apply (rule hoare_seq_ext_skip)
   apply (intro hoare_vcg_conj_lift_pre_fix)
     apply (wpsimp wp: refill_pop_head_released_ipc_queues)
    apply (wpsimp wp: refill_pop_head_cur_sc_not_blocked)
   apply (clarsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite bind_assoc)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (wpsimp wp: set_refills_released_ipc_queues get_refills_wp set_refills_wp)
  apply (clarsimp simp: pred_map_ipc_queued_thread_state_iff cur_sc_not_blocked_def obj_at_def)
  done

lemma head_insufficient_loop_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   head_insufficient_loop sc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: head_insufficient_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: non_overlapping_merge_refills_released_ipc_queues)
   apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def update_refill_hd_def)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: cur_sc_not_blocked_def vs_all_heap_simps)
  apply (clarsimp simp: non_overlapping_merge_refills_def refill_pop_head_def)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  done

lemma schedule_used_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   schedule_used sc_ptr new
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: schedule_used_defs)
  apply (wpsimp wp: set_refills_released_ipc_queues get_refills_wp hoare_vcg_all_lift
               simp: update_sched_context_set_refills_rewrite
         | wp (once) hoare_drop_imps)+
  apply (clarsimp simp: pred_map_ipc_queued_thread_state_iff cur_sc_not_blocked_def)
  done

crunches refill_single
  for inv[wp]: P

lemma handle_overrun_loop_body_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   handle_overrun_loop_body usage
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  (is "valid _ _ (\<lambda>_ s. ?post s)")
  apply (clarsimp simp: handle_overrun_loop_body_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. ?post s" in hoare_seq_ext; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp simp: update_refill_hd_rewrite
                   wp: set_refills_released_ipc_queues get_refills_wp)
  apply (clarsimp simp: pred_map_ipc_queued_thread_state_iff cur_sc_not_blocked_def)
  apply (rule hoare_seq_ext_skip)
   apply (clarsimp simp: pred_conj_def)
   apply (intro hoare_vcg_conj_lift_pre_fix)
      apply (wpsimp wp: refill_pop_head_released_ipc_queues set_refills_released_ipc_queues
                        get_refills_wp hoare_vcg_all_lift hoare_drop_imps)
     apply (wpsimp wp: refill_pop_head_cur_sc_not_blocked)
    apply (wpsimp wp: set_refills_wp)
   apply (wpsimp wp: set_refills_wp)
  apply (wpsimp wp: schedule_used_released_ipc_queues)
  done

lemma handle_overrun_loop_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   handle_overrun_loop usage
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: handle_overrun_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix
         ; (solves handle_overrun_loop_body_simple)?)
  apply (wpsimp wp: handle_overrun_loop_body_released_ipc_queues)
  apply fastforce
  done

lemma merge_refills_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   merge_refills sc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: merge_refills_def update_refill_hd_rewrite)
  apply (rule hoare_seq_ext_skip)
   apply (intro hoare_vcg_conj_lift_pre_fix)
     apply (wpsimp wp: refill_pop_head_released_ipc_queues)
    apply (clarsimp simp: refill_pop_head_def)
    apply (wpsimp wp: set_refills_wp get_refills_wp)
    apply (clarsimp simp: cur_sc_not_blocked_def vs_all_heap_simps)
   apply (clarsimp simp: refill_pop_head_def update_sched_context_set_refills_rewrite)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (wpsimp wp: set_refills_released_ipc_queues get_refills_wp)
  apply (clarsimp simp: pred_map_ipc_queued_thread_state_iff cur_sc_not_blocked_def)
  done

lemma refill_head_overlapping_loop_released_ipc_queues:
  "\<lbrace>\<lambda>s. released_ipc_queues s \<and> cur_sc_not_blocked s \<and> sc_ptr = cur_sc s\<rbrace>
   refill_head_overlapping_loop sc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_head_overlapping_loop_def)
  apply (wpsimp wp: valid_whileLoop[where I="\<lambda>_. ?pre"]
         ; fastforce?)
  apply (intro hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: merge_refills_released_ipc_queues)
   apply (clarsimp simp: merge_refills_def refill_pop_head_def update_refill_hd_rewrite
                         update_sched_context_set_refills_rewrite)
   apply (wpsimp wp: set_refills_wp get_refills_wp)
   apply (clarsimp simp: cur_sc_not_blocked_def vs_all_heap_simps)
  apply (clarsimp simp: merge_refills_def refill_pop_head_def)
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  done

crunches head_insufficient_loop, handle_overrun_loop
  for cur_sc_not_blocked[wp]: cur_sc_not_blocked
  (wp: crunch_wps)

lemma refill_budget_check_released_ipc_queues:
  "\<lbrace>released_ipc_queues and cur_sc_not_blocked\<rbrace>
   refill_budget_check usage
   \<lbrace>\<lambda>_. released_ipc_queues\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (clarsimp simp: pred_conj_def)
   apply (intro hoare_vcg_conj_lift_pre_fix
          ; (solves \<open>wpsimp | handle_overrun_loop_simple\<close>)?)
   apply (wpsimp wp: handle_overrun_loop_released_ipc_queues)
   apply fastforce
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (clarsimp simp: pred_conj_def)
   apply (intro hoare_vcg_conj_lift_pre_fix)
     apply (unfold update_refill_hd_def)
     apply (wpsimp wp: schedule_used_released_ipc_queues update_sched_context_set_refills_rewrite)
       apply (clarsimp simp: update_sched_context_set_refills_rewrite)
       apply (wpsimp wp: set_refills_released_ipc_queues get_refills_wp
                   simp: cur_sc_not_blocked_def merge_refills_def refill_pop_head_def obj_at_def)+
     apply (fastforce simp: pred_map_ipc_queued_thread_state_iff)
    apply (wpsimp wp: set_refills_wp get_refills_wp)
    apply (clarsimp simp: cur_sc_not_blocked_def vs_all_heap_simps)
   apply (wpsimp wp: set_refills_wp)
  apply (wpsimp wp: head_insufficient_loop_released_ipc_queues
                    refill_head_overlapping_loop_released_ipc_queues)
  done

lemma charge_budget_valid_blocked[wp]:
  "\<lbrace>valid_blocked_except_set S\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_blocked_except_set S:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def refill_reset_rr_def update_refill_hd_def
            update_refill_tl_def update_sched_context_set_refills_rewrite
  by (wpsimp wp: reschedule_required_valid_blocked end_timeslice_valid_blocked
                 assert_inv gts_wp is_schedulable_wp' is_round_robin_wp)

lemma refill_reset_rr_valid_release_q[wp]:
  "\<lbrace>valid_release_q and sc_refills_sc_at (\<lambda>refills. length refills = 2) scp\<rbrace>
   refill_reset_rr scp
   \<lbrace>\<lambda>_. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: refill_reset_rr_def update_refill_hd_def update_refill_tl_def
                        update_sched_context_set_refills_rewrite bind_assoc)
  apply (intro hoare_seq_ext[OF _ get_refills_sp])
  apply (rule_tac B="\<lambda>_. ?pre" in hoare_seq_ext[rotated])
   apply (wpsimp wp: set_refills_valid_release_q get_refills_wp hoare_vcg_imp_lift'
                     hoare_vcg_all_lift
          | wpsimp wp: set_refills_wp)+
   apply (clarsimp simp: obj_at_def vs_all_heap_simps tcb_ready_times_defs
                         map_project_simps map_join_simps opt_map_simps sc_at_pred_n_def)
  apply (wpsimp wp: set_refills_valid_release_q get_refills_wp hoare_vcg_imp_lift' hoare_vcg_all_lift)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps tcb_ready_times_defs
                        map_project_simps map_join_simps opt_map_simps sc_at_pred_n_def)
  apply (metis butlast.simps(2) hd_append2 list.sel(1) list_length_2 neq_Nil_conv)
  done

lemma charge_budget_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> ct_not_in_release_q s \<and> cur_sc_chargeable s
        \<and> valid_refills (cur_sc s) s \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (clarsimp simp: charge_budget_def)
  apply wpsimp
              apply (wpsimp wp: end_timeslice_valid_release_q)
             apply (wpsimp wp: assert_inv)
            apply (wpsimp wp: gts_wp is_schedulable_wp')+
       apply (rule_tac Q="\<lambda>_ s. valid_release_q s \<and> cur_sc_chargeable s
                                 \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)"
              in hoare_strengthen_post[rotated])
        apply (clarsimp simp: tcb_at_kh_simps ct_in_state_def runnable_eq_active
                       split: if_splits)
       apply (wpsimp wp: sc_consumed_add_invs)
      apply (wpsimp wp: refill_budget_check_valid_release_q is_round_robin_wp)+
   apply (clarsimp simp: valid_refills_def vs_all_heap_simps rr_valid_refills_def
                         sc_at_pred_n_def obj_at_def ct_in_state_def pred_tcb_at_def
                         runnable_eq_active
                  split: if_splits)
  apply (fastforce simp: cur_sc_chargeable_def obj_at_def valid_release_q_def
                         in_queue_2_def vs_all_heap_simps)
  done

lemma refill_reset_rr_active_sc_tcb_at[wp]:
  "refill_reset_rr scp \<lbrace>(\<lambda>s. P (active_sc_tcb_at t s)) :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding refill_reset_rr_def set_refill_hd_def update_refill_hd_def set_refill_tl_def
            update_refill_tl_def
  apply (wpsimp wp: hoare_vcg_ex_lift)
  done

lemma refill_reset_rr_valid_sched_action:
  "\<lbrace>valid_sched_action and sc_scheduler_act_not scp\<rbrace>
   refill_reset_rr scp
   \<lbrace>\<lambda>_. valid_sched_action\<rbrace>"
  unfolding refill_reset_rr_def update_refill_hd_def
            update_refill_tl_def update_sched_context_set_refills_rewrite
  by (wpsimp wp: set_refills_valid_sched_action_act_not)

lemma charge_budget_valid_sched_action:
  "\<lbrace>valid_sched_action and scheduler_act_sane and cur_sc_chargeable\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (clarsimp simp: charge_budget_def)
  apply wpsimp
            apply (wpsimp wp: gts_wp is_schedulable_wp')+
       apply (rule_tac Q="\<lambda>ya s.
                (if (pred_map runnable (tcb_sts_of s) (cur_thread s) \<and> ct_not_in_release_q s \<and> active_sc_tcb_at (cur_thread s) s)
                 then True
                 else valid_sched_action s)" in hoare_strengthen_post[rotated])
        apply (clarsimp simp: tcb_at_kh_simps ct_in_state_def runnable_eq_active
                       split: if_splits)
       apply (wpsimp wp: hoare_vcg_if_lift_strong sc_consumed_add_invs)
      apply (wpsimp wp: hoare_vcg_if_lift_strong)
          apply (rule_tac hoare_strengthen_post[rotated], erule ct_active_sc_helper)
          apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
         apply (rule_tac hoare_strengthen_post[rotated], erule ct_active_sc_helper)
         apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
        apply (wpsimp wp: hoare_vcg_disj_lift hoare_vcg_imp_lift')
          apply (rule_tac hoare_strengthen_post[rotated], erule ct_active_sc_helper)
          apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
         apply (wpsimp wp: hoare_vcg_disj_lift hoare_vcg_imp_lift')
         apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')+
      apply (wpsimp wp: refill_reset_rr_valid_sched_action
                        refill_budget_check_valid_sched_action_act_not)+
     apply (wpsimp wp: is_round_robin_wp)+
  apply (clarsimp simp: valid_sched_def valid_sched_action_def split: if_splits)
  apply (subgoal_tac "sc_scheduler_act_not (cur_sc s) s", simp)
  apply (intro conjI impI allI)
  apply (clarsimp simp: cur_sc_chargeable_def scheduler_act_sane_def)
  apply (rename_tac t')
  apply (subgoal_tac "pred_map runnable (tcb_sts_of s) t'")
  apply (drule_tac x=t' in spec)+
  apply (fastforce simp: pred_map_simps)
  apply (clarsimp simp:  weak_valid_sched_action_def in_queue_2_def)
  done

(* FIXME: why are these three not crunchable? *)
lemma charge_budget_ct_in_cur_domain[wp]:
  "\<lbrace>ct_in_cur_domain \<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. ct_in_cur_domain :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_if_lift2)

lemma charge_budget_valid_idle_etcb[wp]:
  "\<lbrace>valid_idle_etcb\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_idle_etcb :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_if_lift2)

lemma charge_budget_ct_not_in_q[wp]:
  "\<lbrace>ct_not_in_q \<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. ct_not_in_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)

lemma refill_reset_rr_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at tptr
    and valid_refills csc_ptr
    and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) csc_ptr)\<rbrace>
   refill_reset_rr csc_ptr
   \<lbrace>\<lambda>_. released_sc_tcb_at tptr :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding released_sc_tcb_at_def refill_reset_rr_def update_refill_hd_def
            update_refill_tl_def update_sched_context_set_refills_rewrite bind_assoc
  apply (wpsimp simp: active_sc_tcb_at_def2 budget_ready_def2 budget_sufficient_def2
                  wp: hoare_vcg_ex_lift
         | wp set_refills_wp get_refills_wp)+
  apply (clarsimp simp: pred_tcb_at_def obj_at_def vs_all_heap_simps refill_ready_def)
  done

lemma refill_reset_rr_valid_ready_qs[wp]:
  "\<lbrace>valid_ready_qs
    and valid_refills csc_ptr
    and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) csc_ptr)\<rbrace>
   refill_reset_rr csc_ptr
   \<lbrace>\<lambda>_. valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding valid_ready_qs_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift'
           simp: Ball_def )

lemma refill_reset_rr_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills
    and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) csc_ptr)\<rbrace>
   refill_reset_rr csc_ptr
   \<lbrace>\<lambda>_. active_sc_valid_refills :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding refill_reset_rr_def update_refill_hd_def update_refill_tl_def
            update_sched_context_set_refills_rewrite
  apply (wpsimp wp: set_refills_wp get_refills_wp)
  apply (clarsimp simp: active_sc_valid_refills_def)
  apply (drule_tac x=scp in spec)
  apply (prop_tac "is_active_sc scp s")
   apply (clarsimp simp: pred_map_def vs_all_heap_simps obj_at_def split: if_splits)
  apply (fastforce simp: active_sc_valid_refills_def obj_at_def vs_all_heap_simps list_length_2
                         cfg_valid_refills_def rr_valid_refills_def MIN_REFILLS_def)
  done

lemma refill_reset_rr_released_ipc_queues[wp]:
  "\<lbrace>released_ipc_queues
    and valid_refills csc_ptr
    and (\<lambda>s. pred_map (\<lambda>cfg. scrc_period cfg = 0) (sc_refill_cfgs_of s) csc_ptr)\<rbrace>
   refill_reset_rr csc_ptr
   \<lbrace>\<lambda>_. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding released_ipc_queues_defs
  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_disj_lift)

lemma charge_budget_released_ipc_queues:
  "\<lbrace>released_ipc_queues
    and cur_sc_not_blocked
    and active_sc_valid_refills
    and current_time_bounded
    and cur_sc_active
    and K (unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and cur_sc_offset_ready 0\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. released_ipc_queues :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (clarsimp simp: charge_budget_def)
  apply (wpsimp wp: end_timeslice_released_ipc_queues assert_inv gts_wp is_schedulable_wp')
       apply (rule_tac Q="\<lambda>_. released_ipc_queues and active_sc_valid_refills
                              and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)"
                    in hoare_strengthen_post[rotated]
              , clarsimp simp: tcb_at_kh_simps ct_in_state_def runnable_eq_active split: if_splits)
       apply (wpsimp wp: refill_budget_check_released_ipc_queues
                         refill_budget_check_active_sc_valid_refills
                         is_round_robin_wp' get_sched_context_wp gets_wp)+
  apply (clarsimp simp: vs_all_heap_simps active_sc_valid_refills_def split: if_splits)
  done

lemma ct_not_blocked_cur_sc_not_blocked:
  "cur_sc_chargeable s \<Longrightarrow> ct_not_blocked s \<Longrightarrow> cur_sc_not_blocked s"
  unfolding cur_sc_not_blocked_def cur_sc_chargeable_def
  apply (clarsimp)
  apply (drule_tac x=t in spec)
  apply (drule_tac x=t in spec)
  by (auto simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)

crunches refill_budget_check_round_robin, refill_budget_check
  for valid_machine_time[wp]: valid_machine_time
  (wp: crunch_wps)

lemma charge_budget_valid_ready_qs:
  "\<lbrace>valid_ready_qs
    and released_ipc_queues
    and active_sc_valid_refills
    and valid_sched_action
    and scheduler_act_sane
    and ct_not_queued and scheduler_act_sane
    and cur_sc_chargeable
    and cur_sc_not_blocked
    and cur_sc_active
    and K(unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and cur_sc_offset_ready 0
    and current_time_bounded\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_ready_qs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (clarsimp simp: charge_budget_def)
  apply wpsimp
              apply (wpsimp wp: end_timeslice_valid_ready_qs)
             apply (wpsimp wp: assert_inv)
            apply (wpsimp wp: gts_wp is_schedulable_wp')+
       apply (rule_tac Q="\<lambda>_ s. ct_not_queued s \<and> cur_sc_chargeable s \<and> valid_ready_qs s \<and> active_sc_valid_refills s
                                 \<and> released_ipc_queues s \<and> valid_sched_action s \<and> scheduler_act_sane s"
              in hoare_strengthen_post[rotated])
        apply (clarsimp simp: tcb_at_kh_simps ct_in_state_def runnable_eq_active
                       split: if_splits)
       apply wpsimp
      apply (wpsimp wp: refill_reset_rr_valid_sched_action
                        refill_budget_check_active_sc_valid_refills
                        refill_budget_check_valid_ready_qs_not_queued
                        refill_budget_check_released_ipc_queues
                        refill_budget_check_valid_sched_action_act_not)
     apply (wpsimp wp: is_round_robin_wp)+
  apply (clarsimp split: if_splits)
  apply (subgoal_tac "sc_not_in_ready_q (cur_sc s) s \<and> sc_scheduler_act_not (cur_sc s) s", simp)
   apply (fastforce simp: vs_all_heap_simps pred_map_def obj_at_def ct_in_state_def pred_tcb_at_def
                          active_sc_valid_refills_def cur_sc_chargeable_def runnable_eq_active)
  apply (clarsimp simp: vs_all_heap_simps pred_map_def obj_at_def ct_in_state_def pred_tcb_at_def)
  apply (intro conjI impI allI)
   apply (clarsimp simp: cur_sc_chargeable_def)
   apply (subgoal_tac "pred_map runnable (tcb_sts_of s) t")
    apply (drule_tac x=t in spec)+
    apply (fastforce simp: vs_all_heap_simps valid_ready_qs_def in_queue_2_def runnable_eq_active
                    split: thread_state.splits)
   apply (clarsimp simp: valid_ready_qs_def in_queue_2_def in_ready_q_def)
  apply (clarsimp simp: cur_sc_chargeable_def scheduler_act_sane_def)
  apply (subgoal_tac "pred_map runnable (tcb_sts_of s) t")
   apply (drule_tac x=t in spec)+
   apply (clarsimp simp: vs_all_heap_simps valid_ready_qs_def in_queue_2_def in_ready_q_def)
  apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def)
  done

crunches end_timeslice
  for active_sc_valid_refills[wp]: "active_sc_valid_refills :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma charge_budget_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and K (unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and current_time_bounded
    and cur_sc_offset_ready 0\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. active_sc_valid_refills :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: charge_budget_def)
  apply (wpsimp wp: hoare_vcg_if_lift2 get_tcb_obj_ref_wp is_schedulable_wp
                    refill_budget_check_round_robin_active_sc_valid_refills
                    refill_budget_check_active_sc_valid_refills)
      apply (rule_tac Q="\<lambda>_. active_sc_valid_refills and current_time_bounded"
             in hoare_strengthen_post[rotated], clarsimp)
      apply (wpsimp wp: hoare_vcg_if_lift2 is_round_robin_wp
                        refill_budget_check_active_sc_valid_refills)+
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma end_timeslice_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> (can_timeout \<longrightarrow> active_if_bound_sc_tcb_at (cur_thread s) s)\<rbrace>
   end_timeslice can_timeout
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def by (wpsimp wp: handle_timeout_active_reply_scs thread_get_wp')

lemma charge_budget_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> (can_timeout \<longrightarrow> cur_sc_tcb_are_bound s \<longrightarrow> cur_sc_active s)\<rbrace>
   charge_budget consumed can_timeout
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  supply if_split[split del]
  apply (wpsimp wp: end_timeslice_active_reply_scs hoare_vcg_disj_lift hoare_vcg_imp_lift'
                    get_tcb_obj_ref_wp is_schedulable_wp)
      apply (rule_tac Q="\<lambda>_. active_reply_scs" in hoare_strengthen_post[rotated],
             clarsimp split: if_splits simp: schedulable_def2)
  apply (wpsimp simp: refill_reset_rr_def update_refill_hd_def update_sched_context_set_refills_rewrite
                      update_refill_tl_def)+
  apply (clarsimp simp: schedulable_def2
                 split: if_splits)
  done

lemma charge_budget_ready_or_release:
  "\<lbrace>ready_or_release and ready_qs_etcb_eq and ct_not_in_release_q and ct_not_queued
    and cur_sc_chargeable and active_sc_valid_refills
    and cur_sc_active\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. ready_or_release :: 'state_ext state \<Rightarrow> _ \<rbrace>"
  apply (clarsimp simp: charge_budget_def when_def)
  by (wpsimp wp: hoare_drop_imp)

lemma charge_budget_valid_sched:
  "\<lbrace>valid_sched
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and ct_not_in_release_q
    and ct_not_queued
    and scheduler_act_sane
    and cur_sc_chargeable
    and cur_sc_not_blocked
    and cur_sc_active
    and current_time_bounded
    and (\<lambda>s. (canTimeout \<longrightarrow> cur_sc_tcb_are_bound s \<longrightarrow> cur_sc_active s))
    and K (unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and cur_sc_offset_ready 0\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding valid_sched_def
  apply (wpsimp wp: charge_budget_valid_ready_qs charge_budget_active_sc_valid_refills
                    charge_budget_valid_release_q
                    charge_budget_valid_sched_action
                    charge_budget_released_ipc_queues
                    charge_budget_active_reply_scs
                    charge_budget_ready_or_release)
  apply (clarsimp simp: active_sc_valid_refills_def)
  done

lemma check_budget_valid_ready_qs:
  "\<lbrace>valid_ready_qs and released_ipc_queues and valid_sched_action
    and ct_not_queued
    and active_sc_valid_refills
    and scheduler_act_sane and cur_sc_chargeable
    and cur_sc_not_blocked and cur_sc_active
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. valid_ready_qs::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: charge_budget_valid_ready_qs)
  apply (intro conjI)
   apply (clarsimp simp: consumed_time_bounded_def current_time_bounded_def)
  apply (clarsimp simp: refill_ready_no_overflow_def vs_all_heap_simps)
  done

lemma check_budget_valid_release_q:
  "\<lbrace>valid_release_q and active_sc_valid_refills and cur_sc_active
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and ct_not_in_release_q
    and cur_sc_chargeable\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. valid_release_q::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: get_sched_context_wp charge_budget_valid_release_q
                    hoare_vcg_if_lift2 hoare_drop_imp hoare_vcg_all_lift)
  apply (clarsimp simp: active_sc_valid_refills_def)
  done

lemma check_budget_released_ipc_queues:
  "\<lbrace>released_ipc_queues
    and active_sc_valid_refills
    and cur_sc_not_blocked and cur_sc_active
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. released_ipc_queues::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: charge_budget_released_ipc_queues)
  apply (intro conjI)
   apply (fastforce simp: consumed_time_bounded_def current_time_bounded_def)
  apply (clarsimp simp: refill_ready_no_overflow_def vs_all_heap_simps)
  done

lemma check_budget_active_sc_valid_refills:
  "\<lbrace>active_sc_valid_refills
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. active_sc_valid_refills::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: charge_budget_active_sc_valid_refills)
  apply (intro conjI impI)
   apply (clarsimp simp: current_time_bounded_def consumed_time_bounded_def)
  apply (clarsimp simp: refill_ready_no_overflow_def vs_all_heap_simps)
  done

crunches check_budget
  for ct_not_in_q[wp]: "ct_not_in_q ::'state_ext state \<Rightarrow> _"
  and ct_in_cur_domain[wp]: "ct_in_cur_domain ::'state_ext state \<Rightarrow> _"
  and valid_blocked[wp]: "valid_blocked_except_set S ::'state_ext state \<Rightarrow> _"
  and valid_idle_etcb[wp]: "valid_idle_etcb ::'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma check_budget_valid_sched_action:
  "\<lbrace>valid_sched_action and scheduler_act_sane and cur_sc_chargeable\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. valid_sched_action::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  by (wpsimp wp: get_sched_context_wp charge_budget_valid_sched_action
                 hoare_vcg_if_lift2 hoare_drop_imp hoare_vcg_all_lift)

lemma check_budget_active_reply_scs:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> (cur_sc_tcb_are_bound s \<longrightarrow> cur_sc_active s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. active_reply_scs :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def by (wpsimp wp: charge_budget_active_reply_scs)

lemma check_budget_ready_or_release:
  "\<lbrace>ready_or_release and valid_ready_qs and ct_not_in_release_q and ct_not_queued
    and cur_sc_chargeable and active_sc_valid_refills
    and cur_sc_active\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. ready_or_release :: 'state_ext state \<Rightarrow> _ \<rbrace>"
  unfolding check_budget_def by (wpsimp wp: charge_budget_ready_or_release)

lemma check_budget_valid_sched:
  "\<lbrace>valid_sched
    and (\<lambda>s. heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s))
    and ct_not_in_release_q
    and ct_not_queued
    and scheduler_act_sane
    and cur_sc_chargeable
    and cur_sc_not_blocked and cur_sc_active
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_tcb_are_bound s \<longrightarrow> cur_sc_active s)
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: valid_sched_def)
  by (wpsimp wp: check_budget_valid_ready_qs check_budget_active_sc_valid_refills
                 check_budget_valid_release_q
                 check_budget_valid_sched_action
                 check_budget_released_ipc_queues
                 check_budget_active_reply_scs
                 check_budget_ready_or_release)

lemma tcb_sched_dequeue_valid_blocked_except_set:
  "\<lbrace>\<lambda>s. if not_queued tcb_ptr s then valid_blocked_except_set {tcb_ptr} s else valid_blocked s\<rbrace>
   tcb_sched_action tcb_sched_dequeue tcb_ptr
   \<lbrace>\<lambda>rv s. valid_blocked_except_set {tcb_ptr} s\<rbrace>"
  unfolding tcb_sched_action_def
  apply (wpsimp wp: set_tcb_queue_wp simp: thread_get_def)
  apply (clarsimp simp: valid_blocked_defs tcb_sched_dequeue_def obj_at_def split: if_splits)
   apply (drule_tac x=t in spec; clarsimp )
   apply (case_tac "not_queued t s"; clarsimp)
   apply (clarsimp simp: not_queued_def in_ready_q_def not_queued_2_def)
   apply (drule_tac x=d in spec)
   apply (drule_tac x=d in spec)
   apply (drule_tac x=p in spec)
   apply (drule_tac x=p in spec)
   apply (fastforce simp: tcb_sched_dequeue_def split: if_splits)
  apply (clarsimp simp: not_queued_2_def valid_blocked_defs in_ready_q_def)
  apply (drule_tac x=t in spec; clarsimp )
  apply (auto simp: tcb_sched_dequeue_def split: if_splits)
  done

lemma tcb_release_remove_valid_blocked:
  "\<lbrace>\<lambda>s. if not_in_release_q tcb_ptr s then valid_blocked_except tcb_ptr s else valid_blocked s\<rbrace>
   tcb_release_remove tcb_ptr
   \<lbrace>\<lambda>rv s. valid_blocked_except tcb_ptr s\<rbrace>"
  unfolding tcb_release_remove_def
  apply (wpsimp)
  apply (clarsimp simp: valid_blocked_defs obj_at_def split: if_splits)
   apply (fastforce simp: in_release_q_def in_ready_q_def tcb_sched_act_in_queues_2_simps)
  apply (fastforce simp: in_release_q_def in_ready_q_def tcb_sched_act_in_queues_2_simps)
  done

lemma tcb_release_remove_sc_tcb_sc_at[wp]:
  "tcb_release_remove tcb_ptr \<lbrace>\<lambda>s. Q (sc_tcb_sc_at P sc_ptr s)\<rbrace>"
  by (wpsimp simp: tcb_release_remove_def)

lemma update_sched_context_tcb_ready_time:
  "\<lbrace>\<lambda>s. P (tcb_ready_time t s) \<and> (\<forall>x. sc_refills (f x) = sc_refills x)\<rbrace>
   update_sched_context sc_ptr f
   \<lbrace>\<lambda>_ s. P (tcb_ready_time t s)\<rbrace>"
  apply (wpsimp simp: update_sched_context_def set_object_def
                  wp: get_object_wp split_del: if_split)
  by (auto simp: vs_all_heap_simps tcb_ready_times_defs obj_at_def opt_map_def map_project_def
                 map_join_def tcb_scps_of_tcbs_def tcbs_of_kh_def sc_refill_cfgs_of_scs_def
                 scs_of_kh_def
          split: option.split)

lemma active_sc_tcb_at_update_sched_context_no_change:
  "\<forall>x. (sc_active (f x)) = (sc_active x) \<Longrightarrow>
    \<forall>x. sc_refills (f x) = sc_refills x
   \<Longrightarrow> \<lbrace>\<lambda>s. P (active_sc_tcb_at t s)\<rbrace> update_sched_context sc_ptr f \<lbrace>\<lambda>_ s. P (active_sc_tcb_at t s)\<rbrace>"
  unfolding update_sched_context_def
  apply (wpsimp wp: valid_sched_lift set_object_wp get_object_wp
              simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  apply (intro conjI impI allI)
   apply wpsimp
  apply (erule_tac P=P in back_subst, force)
  done

lemma update_sched_context_valid_refills_indep:
  "\<forall>sc. sc_refill_cfg_of (f sc) = sc_refill_cfg_of sc \<Longrightarrow>
   update_sched_context sc_ptr f \<lbrace>valid_refills t\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma charge_budget_valid_sched_misc[wp]:
  "charge_budget consumed canTimeout
   \<lbrace>\<lambda>s::'state_ext state. P (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                            (etcbs_of s) \<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imp)

lemma check_budget_valid_sched_misc[wp]:
  "check_budget
   \<lbrace>\<lambda>s::'state_ext state. P (cur_sc s) (cur_time s) (cur_domain s) (cur_thread s) (idle_thread s)
                            (etcbs_of s)\<rbrace>"
  unfolding check_budget_def
  by (wpsimp wp: hoare_drop_imp)

lemma pst_vs_for_invoke_sched_control_configure_flags:
  "\<lbrace>valid_sched_except_blocked and valid_blocked_except target
    and st_tcb_at runnable target
    and (\<lambda>s. target \<noteq> idle_thread s)
    and (\<lambda>s. not_in_release_q target s \<longrightarrow> released_if_bound_sc_tcb_at target s)\<rbrace>
    possible_switch_to target
   \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wp possible_switch_to_valid_sched_strong)
  apply (clarsimp simp: valid_sched_def )
  apply (intro conjI; intro allI impI)
   apply (clarsimp simp:  released_sc_tcb_at_def tcb_at_kh_simps pred_map_simps)
  apply (erule valid_blockedE', clarsimp)
  apply (clarsimp simp: in_release_queue_def not_in_release_q_def valid_blocked_thread_def
                        vs_all_heap_simps)
  done

lemma refill_budget_check_sc_refill_max_sc_at:
  "refill_budget_check usage \<lbrace>sc_refill_max_sc_at P sc_ptr\<rbrace>"
  apply (clarsimp simp: refill_budget_check_def schedule_used_defs)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
   apply (handle_overrun_loop_simple
          ; clarsimp simp: sc_at_pred_n_def obj_at_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)+
  apply (rule hoare_seq_ext_skip)
  apply (wpsimp wp: set_refills_wp get_refills_wp whileLoop_wp'
              simp: obj_at_def merge_refills_def refill_pop_head_def sc_at_pred_n_def
                    update_sched_context_set_refills_rewrite update_refill_hd_rewrite)
   apply (head_insufficient_loop_simple
          ; clarsimp simp: sc_at_pred_n_def obj_at_def)
  done

lemma refill_budget_check_round_robin_sc_refill_max_sc_at:
  "refill_budget_check_round_robin usage \<lbrace>sc_refill_max_sc_at P sc_ptr\<rbrace>"
  unfolding refill_budget_check_round_robin_def update_refill_hd_def update_refill_tl_def
  apply (wpsimp wp: update_sched_context_wp set_refills_wp hoare_vcg_all_lift hoare_vcg_imp_lift'
                    get_refills_wp
              simp: refill_budget_check_round_robin_def is_round_robin_def sc_at_pred_n_def
                    obj_at_def refill_full_def refill_ready_def
      | intro conjI impI)+
  done

crunches commit_time
  for sc_refill_max_sc_at[wp]: "sc_refill_max_sc_at P sc_ptr"
  (wp: crunch_wps update_sched_context_sc_at_pred_n_no_change ignore: update_sched_context)

crunches tcb_release_remove, tcb_sched_action
  for sc_refill_max_sc_at[wp]: "sc_refill_max_sc_at P sc_ptr"

lemma cur_sc_offset_ready_weaken_zero[elim!]:
  "cur_sc_offset_ready k s \<Longrightarrow> cur_sc_offset_ready 0 s"
  by (clarsimp simp: cur_sc_offset_ready_def pred_map_simps)

lemma current_time_bounded_drop_WCET:
  "current_time_bounded s \<Longrightarrow> unat (cur_time s) + unat MAX_PERIOD \<le> unat max_time"
  by (clarsimp simp: current_time_bounded_def)

abbreviation (input) iscc_valid_sched_predicate where
  "iscc_valid_sched_predicate sc_ptr tcb_ptr mrefills budget s \<equiv>
    valid_sched_except_blocked s
    \<and> valid_blocked_except tcb_ptr s
    \<and> MIN_REFILLS \<le> mrefills
    \<and> MIN_BUDGET \<le> budget
    \<and> schact_is_rct s
    \<and> invs s
    \<and> sc_ptr \<noteq> idle_sc_ptr
    \<and> ct_not_in_release_q s
    \<and> ct_not_queued s"

(* FIXME: move *)
lemma consumed_time_bounded_trivial[simp]:
  "consumed_time_bounded_2 0 k = True"
  by (clarsimp simp: consumed_time_bounded_def)

crunches commit_time
  for consumed_time_bounded[wp]: consumed_time_bounded

lemma tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed'[wp_unsafe]:
  "tcb_release_remove tcb_ptr
   \<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_2 sc_ptr (release_queue s) (consumed_time s) (tcb_scps_of s)\<rbrace>"
  apply (wpsimp wp: tcb_release_remove_wp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (case_tac "t = tcb_ptr"; clarsimp simp: in_queue_2_def tcb_sched_dequeue_def)
  done

lemma tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed[wp_unsafe]:
  "tcb_release_remove tcb_ptr \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (rule_tac f=cur_sc in hoare_lift_Pf2)
   apply (wpsimp wp: tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed')+
  done

lemma ct_not_in_release_q_cur_sc_in_release_q_imp_zero_consumed:
  "schact_is_rct s \<Longrightarrow> invs s \<Longrightarrow> ct_not_in_release_q s \<Longrightarrow> cur_sc_in_release_q_imp_zero_consumed s"
  apply (frule invs_cur_sc_tcb)
  apply (clarsimp simp: schact_is_rct_def cur_sc_tcb_def obj_at_kh_kheap_simps pred_map_eq_normalise
                        cur_sc_in_release_q_imp_zero_consumed_def)
  apply (frule (2) heap_refs_retract_eq[OF invs_retract_tcb_scps], clarsimp)
  done

lemma refill_new_active_reply_scs[wp]:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> active_sc max_refills\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>_. active_reply_scs\<rbrace>"
  supply if_split [split del]
  apply (rule active_reply_scs_lift_pre_conj, rule active_reply_sc_at_lift_pre_conj, wpsimp)
  unfolding refill_new_def maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: valid_sched_wp is_round_robin_wp hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_if_lift2
                    hoare_vcg_disj_lift)
  by (clarsimp simp: heap_upd_def vs_all_heap_simps split: if_split)

lemma refill_update_active_reply_scs[wp]:
  "\<lbrace>\<lambda>s. active_reply_scs s \<and> active_sc new_max_refills\<rbrace>
   refill_update sc_ptr new_period new_budget new_max_refills
   \<lbrace>\<lambda>_. active_reply_scs\<rbrace>"
  apply (rule active_reply_scs_lift_pre_conj, rule active_reply_sc_at_lift_pre_conj, wpsimp)
  unfolding refill_update_def refill_add_tail_def update_refill_hd_def update_refill_tl_def get_refills_def
  apply (wpsimp wp: valid_sched_wp hoare_drop_imps hoare_vcg_all_lift)
  apply (clarsimp simp: heap_upd_def vs_all_heap_simps)
  done

crunches commit_time
  for cur_time_machine_state[wp]: "\<lambda>s. P (cur_time s) (machine_state s)"
  (wp: crunch_wps)

lemma invoke_sched_control_configure_flags_valid_sched:
  "\<lbrace>valid_sched
    and valid_sched_control_inv iv and schact_is_rct and invs
    and ct_not_in_release_q and ct_released and ct_not_queued
    and current_time_bounded
    and consumed_time_bounded
    and cur_sc_active
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   invoke_sched_control_configure_flags iv
   \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split[split del] return_bind[simp del]
  apply (simp add: invoke_sched_control_configure_flags_def)
  apply (cases iv; simp)
  apply (rename_tac sc_ptr budget period mrefills badge flag)
  apply (subst bind_assoc[symmetric])
  apply (rule_tac B="\<lambda>rv s. valid_sched s
                            \<and> MIN_REFILLS \<le> mrefills
                            \<and> MIN_BUDGET \<le> budget
                            \<and> budget \<le> period
                            \<and> ex_nonz_cap_to sc_ptr s
                            \<and> schact_is_rct s
                            \<and> invs s
                            \<and> sc_ptr \<noteq> idle_sc_ptr
                            \<and> ct_not_in_release_q s
                            \<and> ct_not_queued s
                            \<and> cur_sc_active s
                            \<and> current_time_bounded s
                            \<and> period \<le> MAX_PERIOD
                            \<and> cur_sc_offset_ready (consumed_time s) s
                            \<and> cur_sc_offset_sufficient (consumed_time s) s
                            \<and> cur_sc_in_release_q_imp_zero_consumed s
                            \<and> consumed_time_bounded s"
            in hoare_seq_ext[rotated])
   apply (wpsimp wp: update_sc_sporadic_invs')
    apply (wpsimp wp: update_sc_badge_invs')
   apply (wpsimp wp: update_sched_context_wp)
   apply (intro conjI impI)
    apply (frule invs_valid_global_refs)
    apply (frule invs_valid_objs)
    apply (fastforce dest!: idle_sc_no_ex_cap)
   apply (clarsimp simp: obj_at_def sc_refill_max_sc_at_def)
   apply (erule ct_not_in_release_q_cur_sc_in_release_q_imp_zero_consumed; clarsimp)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (case_tac "sc_tcb sc = None")
   apply (clarsimp simp: bind_assoc valid_sched_def)
   apply (wpsimp wp: refill_new_valid_release_q refill_new_valid_ready_qs
                     refill_new_schedulable_ipc_queues refill_new_valid_sched_action
                     refill_new_valid_blocked_no_sc_tcb refill_new_active_sc_valid_refills)
   apply (frule invs_sym_refs)
   apply (clarsimp simp: active_sc_def current_time_bounded_def MIN_REFILLS_def schact_is_rct_simple
                   cong: conj_cong)
   apply (intro conjI impI allI)
           apply (subgoal_tac "heap_ref_eq t sc_ptr (sc_tcbs_of s)")
            apply (clarsimp simp: sc_at_kh_simps vs_all_heap_simps sc_at_pred_n_def obj_at_def)
           apply (clarsimp simp: sc_at_pred_n_def obj_at_def split: if_splits)
           apply (erule heap_refs_retractD[rotated])
           apply (erule sym_refs_retract_tcb_scps)
          apply (clarsimp simp add: sc_at_pred_n_def obj_at_def)
         apply (clarsimp simp: current_time_bounded_def)
        apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
       apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
       apply (subgoal_tac "heap_ref_eq t sc_ptr (sc_tcbs_of s)")
        apply (clarsimp simp: sc_at_kh_simps vs_all_heap_simps)
       apply (erule heap_refs_retractD[rotated])
       apply (erule sym_refs_retract_tcb_scps)
      apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
     apply clarsimp
    apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def)

  \<comment> \<open>\<exists>y. sc_tcb sc = Some y\<close>
  apply (clarsimp simp: bind_assoc)
  apply (subst return_bind)
  apply (rename_tac tcb_ptr)
  apply (rule_tac B="\<lambda>rv s. iscc_valid_sched_predicate sc_ptr tcb_ptr mrefills budget s
                            \<and> budget \<le> period \<and> period \<le> MAX_PERIOD \<and> current_time_bounded s
                            \<and> ex_nonz_cap_to sc_ptr s \<and> consumed_time_bounded s
                            \<and> sc_refill_max_sc_at (\<lambda>rm. rm = sc_refill_max sc) sc_ptr s
                            \<and> sc_tcb_sc_at (\<lambda>to. to = sc_tcb sc) sc_ptr s
                            \<and> not_in_release_q tcb_ptr s
                            \<and> cur_sc_offset_ready (consumed_time s) s
                            \<and> cur_sc_offset_sufficient (consumed_time s) s
                            \<and> cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_active s
                            \<and> current_time_bounded s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: tcb_release_remove_valid_sched_except_blocked tcb_release_remove_valid_blocked
                     tcb_release_remove_ready_or_release
                     hoare_vcg_conj_lift tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed)
   apply (clarsimp simp: valid_sched_valid_sched_except_blocked current_time_bounded_def
                         sc_at_pred_n_def obj_at_def)

  apply (rule_tac B="\<lambda>rv s. iscc_valid_sched_predicate sc_ptr tcb_ptr mrefills budget s
                            \<and> budget \<le> period \<and> period \<le> MAX_PERIOD
                            \<and> ex_nonz_cap_to sc_ptr s \<and> consumed_time_bounded s
                            \<and> sc_refill_max_sc_at (\<lambda>rm. rm = sc_refill_max sc) sc_ptr s
                            \<and> sc_tcb_sc_at (\<lambda>to. to = sc_tcb sc) sc_ptr s
                            \<and> not_in_release_q tcb_ptr s \<and> cur_sc_offset_ready (consumed_time s) s
                            \<and> cur_sc_offset_sufficient (consumed_time s) s
                            \<and> cur_sc_in_release_q_imp_zero_consumed s \<and> cur_sc_active s
                            \<and> current_time_bounded s \<and> not_queued tcb_ptr s"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: tcb_sched_dequeue_valid_sched_except_blocked
                     tcb_sched_dequeue_valid_blocked_except_set
                     tcb_release_remove_ready_or_release tcb_sched_dequeue_ct_not_queued)
    apply (rule tcb_dequeue_not_queued)
   apply clarsimp
   apply (intro conjI)
    apply (clarsimp simp: valid_sched_def split: if_splits)
    using valid_blocked_except_set_in_ready_q apply blast
   apply (clarsimp simp: valid_sched_def)

  apply clarsimp
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rename_tac csc)
  apply (rule_tac B="\<lambda>rv s. iscc_valid_sched_predicate sc_ptr tcb_ptr mrefills budget s
                            \<and> budget \<le> period \<and> period \<le> MAX_PERIOD
                            \<and> sc_tcb_sc_at (\<lambda>tcb. tcb = sc_tcb sc) sc_ptr s
                            \<and> sc_refill_max_sc_at (\<lambda>rm. rm = sc_refill_max sc) sc_ptr s
                            \<and> not_in_release_q tcb_ptr s \<and> consumed_time_bounded s
                            \<and> cur_sc_active s
                            \<and> current_time_bounded s \<and> not_queued tcb_ptr s"
           in hoare_seq_ext[rotated])

   apply (case_tac "sc_ptr \<noteq> csc")
    apply (wpsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps)

   \<comment> \<open>sc_ptr = csc\<close>
   apply (clarsimp simp: valid_sched_def)
   apply (wpsimp wp: commit_time_valid_release_q_cur_sc_not_in_release_q commit_time_invs
                     commit_time_valid_ready_qs commit_time_valid_sched_action
                     commit_time_released_ipc_queues commit_time_valid_blocked_except_set
                     commit_time_sc_refill_max_sc_at
                     commit_time_active_sc_valid_refills)
   apply (simp add: sc_at_pred_n_def obj_at_def cur_sc_more_than_ready_def current_time_bounded_def)
   apply (intro conjI impI)
    apply (clarsimp simp: vs_all_heap_simps obj_at_def)
    apply (frule invs_sym_refs)
    apply (frule sym_ref_tcb_sc; blast?)
    apply simp
   apply (clarsimp simp: vs_all_heap_simps obj_at_def)

  apply (rule_tac B="\<lambda>rv s. valid_sched_except_blocked s
                            \<and> budget \<le> period \<and> period \<le> MAX_PERIOD \<and> current_time_bounded s
                            \<and> valid_blocked_except tcb_ptr s \<and> consumed_time_bounded s
                            \<and> invs s \<and> schact_is_rct s
                            \<and> pred_map_eq (Some sc_ptr) (tcb_scps_of s) tcb_ptr
                            \<and> sc_tcb_sc_at (\<lambda>tcb. tcb = sc_tcb sc) sc_ptr s
                            \<and> active_sc_tcb_at tcb_ptr s
                            \<and> sc_ptr \<noteq> idle_sc_ptr"
           in hoare_seq_ext)
   apply (simp add: return_bind)
   apply (rule hoare_seq_ext[OF _ gts_sp])
   apply (rename_tac thread_state2)
   apply (simp only: valid_sched_def cong: conj_cong)
   apply (rule_tac B="\<lambda>rv s. valid_sched_except_blocked s
                             \<and> budget \<le> period \<and> period \<le> MAX_PERIOD \<and> current_time_bounded s
                             \<and> valid_blocked_except tcb_ptr s \<and> schact_is_rct s
                             \<and> invs s \<and> consumed_time_bounded s
                             \<and> (runnable thread_state2
                                \<longrightarrow> not_in_release_q tcb_ptr s \<longrightarrow> released_sc_tcb_at tcb_ptr s)
                             \<and> pred_map_eq (thread_state2) (tcb_sts_of s) tcb_ptr
                             \<and> sc_tcb_sc_at (\<lambda>tcb. tcb = sc_tcb sc) sc_ptr s
                             \<and> sc_ptr \<noteq> idle_sc_ptr"
           in hoare_seq_ext[rotated])
      apply (simp only: valid_sched_def cong: conj_cong)
      apply (wpsimp wp: sched_context_resume_valid_ready_qs sched_context_resume_valid_release_q
                        sched_context_resume_valid_sched_action
                        sched_context_resume_valid_blocked_except_set
                        hoare_vcg_const_imp_lift)
        apply (rule_tac Q="\<lambda>_ s. active_sc_tcb_at tcb_ptr s
                                 \<and> (runnable thread_state2 \<longrightarrow> active_sc_tcb_at tcb_ptr s
                                        \<longrightarrow> not_in_release_q tcb_ptr s \<longrightarrow> released_sc_tcb_at tcb_ptr s)"
               in hoare_strengthen_post[rotated])
         apply clarsimp
        apply (wpsimp wp: sched_context_resume_cond_released_sc_tcb_at)
       apply (wpsimp wp: sched_context_resume_sc_tcb_sc_at)
      apply (clarsimp; intro conjI impI)
          apply (clarsimp simp: op_equal schact_is_rct_def)
         apply (clarsimp simp: pred_map_eq_def pred_map_def obj_at_kh_kheap_simps)
        apply (fastforce simp: sc_at_pred_n_def obj_at_def pred_tcb_at_def)
       apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
      apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
   apply (rule hoare_seq_ext[OF _ gets_sp])
   apply (simp add: return_bind)
   apply (clarsimp split: if_split)
   apply (intro conjI impI)
    apply (rule_tac Q="valid_sched" in hoare_weaken_pre)
     apply (simp add: valid_sched_def)
     apply (wpsimp wp: reschedule_valid_sched_const[simplified valid_sched_def, simplified])
    using valid_blocked_except_cur_thread valid_sched_def apply force
   apply (simp add: valid_sched_def)
   apply (wpsimp wp: possible_switch_to_valid_sched_weak[simplified valid_sched_def, simplified])
   apply (clarsimp split: if_split)
   apply (intro conjI impI)
     apply (clarsimp simp: pred_map_simps)
    apply (frule invs_valid_idle)
    apply (clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def vs_all_heap_simps)
   apply (clarsimp simp: vs_all_heap_simps runnable_eq_active elim!: valid_blockedE')

  apply (rule hoare_if)
   apply (clarsimp simp: valid_sched_def)
   apply (wpsimp wp: refill_new_valid_ready_qs refill_new_valid_release_q refill_new_invs
                     refill_new_valid_sched_action refill_new_schedulable_ipc_queues
                     refill_new_valid_blocked_except_set refill_new_active_sc_tcb_at
                     refill_new_released_sc_tcb_at refill_new_active_sc_valid_refills)
   apply (simp add: active_sc_valid_refills_def obj_at_kh_kheap_simps pred_map_eq_normalise schact_is_rct_simple)
   apply (frule (1) heap_refs_retractD[OF invs_retract_sc_tcbs])
   apply (clarsimp simp: heap_refs_inj_prop[OF invs_inj_tcb_scps]
                         runnable_eq MIN_REFILLS_def active_sc_def)
   apply (clarsimp simp: vs_all_heap_simps current_time_bounded_def)

  apply (rule hoare_if)
   apply (simp add: return_bind)
   apply (rule hoare_seq_ext[OF _ gts_sp])
   apply (rename_tac thread_state)
   apply (clarsimp simp: valid_sched_def)
   apply (rule hoare_if)

     \<comment> \<open>refill_update branch\<close>
    apply (wpsimp wp: refill_update_valid_ready_qs refill_update_valid_release_q
                      refill_update_valid_sched_action refill_update_released_ipc_queues
                      refill_update_invs refill_update_valid_blocked_except_set
                      refill_update_sc_tcb_sc_at refill_update_active_sc_tcb_at
                      refill_update_active_sc_valid_refills)
    apply (simp add: active_sc_valid_refills_def obj_at_kh_kheap_simps pred_map_eq_normalise schact_is_rct_simple)
    apply (frule (1) heap_refs_retractD[OF invs_retract_sc_tcbs])
    apply (clarsimp simp: heap_refs_inj_prop[OF invs_inj_tcb_scps] runnable_eq)
    apply (clarsimp simp: active_sc_def MIN_REFILLS_def vs_all_heap_simps)

    apply (intro conjI; fastforce)

   \<comment> \<open>the remaining subgoals are handled very similarly, and have almost exactly the same proof\<close>
   apply (wpsimp wp: refill_new_valid_ready_qs refill_new_valid_release_q refill_new_invs
                     refill_new_valid_sched_action refill_new_schedulable_ipc_queues
                     refill_new_valid_blocked_except_set refill_new_active_sc_tcb_at
                     refill_new_released_sc_tcb_at refill_new_active_sc_valid_refills)
   apply (simp add: active_sc_valid_refills_def obj_at_kh_kheap_simps pred_map_eq_normalise schact_is_rct_simple)
   apply (frule (1) heap_refs_retractD[OF invs_retract_sc_tcbs])
   apply (clarsimp simp: heap_refs_inj_prop[OF invs_inj_tcb_scps]
                         runnable_eq MIN_REFILLS_def active_sc_def)
   apply (clarsimp simp: vs_all_heap_simps current_time_bounded_def)
  apply (clarsimp simp: valid_sched_def)
  apply (wpsimp wp: refill_new_valid_ready_qs refill_new_valid_release_q refill_new_invs
                    refill_new_valid_sched_action refill_new_schedulable_ipc_queues
                    refill_new_valid_blocked_except_set refill_new_active_sc_tcb_at
                    refill_new_released_sc_tcb_at refill_new_active_sc_valid_refills)
  apply (simp add: active_sc_valid_refills_def obj_at_kh_kheap_simps pred_map_eq_normalise schact_is_rct_simple)
  apply (frule (1) heap_refs_retractD[OF invs_retract_sc_tcbs])
  apply (clarsimp simp: heap_refs_inj_prop[OF invs_inj_tcb_scps]
                        runnable_eq MIN_REFILLS_def active_sc_def)
  apply (clarsimp simp: vs_all_heap_simps current_time_bounded_def)
  done

end

lemma ct_active_imp_not_timeout:
  "\<lbrakk>invs s; ct_active s\<rbrakk> \<Longrightarrow> \<not> timeout_faulted_tcb_at (cur_thread s) s"
  by (fastforce dest!: invs_fault_tcbs_valid_states fault_tcbs_valid_states_active
                simp: ct_in_state_def tcb_at_kh_simps is_timeout_fault_opt_def pred_map_def)

context DetSchedSchedule_AI_det_ext begin

lemma perform_invocation_valid_sched:
  "\<lbrace>invs and valid_invocation i and ct_active and scheduler_act_sane and valid_sched and valid_machine_time
        and cur_sc_active
        and schact_is_rct and ct_not_queued and ct_not_in_release_q and ct_released
        and current_time_bounded and consumed_time_bounded
        and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)
        and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>rv. valid_sched::det_state \<Rightarrow> _\<rbrace>"
  apply (cases i; simp)
             apply (wpsimp wp: invoke_untyped_valid_sched)
            apply (wpsimp wp: send_ipc_valid_sched)
            apply (clarsimp simp: valid_sched_valid_sched_except_blocked valid_blockedD
                                  valid_idle_idle_thread_is_idle[OF invs_valid_idle]
                                  ct_active_imp_not_timeout)
            apply (fastforce simp: vs_all_heap_simps)
           apply (wpsimp wp: send_signal_valid_sched)
          apply (wpsimp wp: do_reply_transfer_valid_sched)
          apply (fastforce elim:)
         apply (wpsimp wp: invoke_tcb_valid_sched)
         apply (fastforce simp: tcb_at_kh_simps vs_all_heap_simps)
        apply (wpsimp wp: invoke_domain_valid_sched)
        apply (clarsimp simp: vs_all_heap_simps schact_is_rct_def)
       apply (wpsimp wp: invoke_sched_context_valid_sched;
              clarsimp simp: tcb_at_kh_simps vs_all_heap_simps schact_is_rct_def)
      apply (wpsimp wp: invoke_sched_control_configure_flags_valid_sched)
     apply (wpsimp wp: invoke_cnode_valid_sched simp: current_time_bounded_def)
    apply (wpsimp wp: invoke_irq_handler_valid_sched;
           clarsimp simp: invs_valid_objs invs_valid_idle)
   apply (wpsimp wp: arch_perform_invocation_valid_sched simp: current_time_bounded_def;
          intro conjI; clarsimp)
  apply wpsimp
  done

end

lemma ct_active_sc_cur_sc_active:
  "active_sc_tcb_at (cur_thread s) s \<Longrightarrow> bound_sc_tcb_at (\<lambda>p. p = Some (cur_sc s)) (cur_thread s) s \<Longrightarrow> cur_sc_active s"
  by (clarsimp simp: active_sc_tcb_at_def2 is_sc_active_kh_simp tcb_at_kh_simps vs_all_heap_simps)

lemma cur_sc_active_ct_active_sc:
  "cur_sc_active s \<Longrightarrow> bound_sc_tcb_at (\<lambda>p. p = Some (cur_sc s)) (cur_thread s) s \<Longrightarrow> active_sc_tcb_at (cur_thread s) s"
  by (fastforce simp: active_sc_tcb_at_def2 is_sc_active_kh_simp)

lemma cur_sc_chargeable_when_ct_active_sc:
  "active_sc_tcb_at (cur_thread s) s \<Longrightarrow> cur_sc_chargeable s \<Longrightarrow> cur_sc_tcb_are_bound s"
  unfolding cur_sc_chargeable_def
  by (clarsimp simp: vs_all_heap_simps)

context DetSchedSchedule_AI_det_ext begin

lemma lookup_extra_caps_not_timeout[wp]:
  "\<lbrace>valid_objs\<rbrace> lookup_extra_caps thread buffer mi -, \<lbrace>\<lambda>rv s. \<not> is_timeout_fault rv\<rbrace>"
  apply (simp add: lookup_extra_caps_def split del: if_split)
  by (wpsimp wp: mapME_wp' lookup_cap_and_slot_valid_fault)

lemma cur_sc_tcb_bound_ready:
  "\<lbrakk>cur_sc_offset_ready k s; cur_sc_tcb_are_bound s; current_time_bounded s; cur_sc s \<noteq> idle_sc_ptr\<rbrakk>
   \<Longrightarrow> budget_ready (cur_thread s) s"
  apply (clarsimp simp: vs_all_heap_simps refill_ready_no_overflow_def refill_ready_def)
  apply (simp add: word_le_nat_alt unat_add_lem)
  by (frule cur_time_no_overflow, simp add: unat_plus_simple)

lemma schact_is_rct_ct_released:
  "\<lbrakk>schact_is_rct s; cur_sc_active s; valid_sched s; invs s;
    cur_sc_offset_ready k s; current_time_bounded s; cur_sc s \<noteq> idle_sc_ptr\<rbrakk>
   \<Longrightarrow> ct_released s"
  apply (subgoal_tac "active_sc_tcb_at (cur_thread s) s")
  apply (clarsimp simp: released_sc_tcb_at_def)
   apply (rule cur_sc_tcb_bound_ready[OF _ invs_strengthen_cur_sc_tcb_are_bound], fastforce+)
  apply (erule (2) cur_sc_active_ct_active_sc[OF _ invs_cur_sc_tcb_symref])
  done

lemma handle_invocation_valid_sched:
  "\<lbrace>invs
    and valid_sched and valid_machine_time
    and ct_active
    and ct_not_queued
    and ct_not_in_release_q
    and cur_sc_active
    and schact_is_rct
    and current_time_bounded
    and consumed_time_bounded
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
     handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>\<lambda>rv. valid_sched::det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: handle_invocation_def)
  apply (wp syscall_valid handle_fault_valid_sched | wpc)+
                apply (wp set_thread_state_runnable_valid_sched)[1]
               apply wp+
         apply (wp gts_wp hoare_vcg_all_lift)
        apply (rule_tac Q="\<lambda>_. valid_sched" and E="\<lambda>_. valid_sched" in hoare_post_impErr)
          apply (wp perform_invocation_valid_sched)
         apply ((clarsimp simp: st_tcb_at_def obj_at_def)+)[2]
       apply (wp ct_in_state_set set_thread_state_runnable_valid_sched
                 sts_schedulable_scheduler_action
            hoare_vcg_E_conj | simp add: split_def if_apply_def2 split del: if_split)+
  apply clarsimp
  apply (subgoal_tac "ct_released s")
   apply (clarsimp simp: valid_sched_def ct_not_in_q_def valid_ready_qs_def not_queued_def
                     schedulable_def2 ct_in_state_def runnable_eq_active not_in_release_q_def
                     in_release_queue_def released_sc_tcb_at_def)
   apply (fastforce elim: st_tcb_ex_cap st_tcb_at_strengthen_pred
                   intro: fault_tcbs_valid_states_active)
  apply (rule schact_is_rct_ct_released; fastforce?)
  apply (rule cur_sc_not_idle_sc_ptr; fastforce?)
  apply (rule invs_strengthen_cur_sc_tcb_are_bound; fastforce)
  done

end

lemma valid_sched_ct_not_queued:
  "\<lbrakk>valid_sched s; scheduler_action s = resume_cur_thread\<rbrakk> \<Longrightarrow>
    not_queued (cur_thread s) s"
  by (fastforce simp: valid_sched_def ct_not_in_q_def)


context DetSchedSchedule_AI begin

crunch cur[wp]: handle_fault_reply "cur_tcb :: 'state_ext state \<Rightarrow> bool"
  (wp: crunch_wps simp: crunch_simps)

end

locale DetSchedSchedule_AI_handle_hypervisor_fault =
  DetSchedSchedule_AI state_ext_t for state_ext_t :: "'state_ext::state_ext itself" +
  assumes handle_hyp_fault_valid_sched[wp]:
    "\<And>t fault.
      \<lbrace>valid_sched and invs and st_tcb_at active t and not_queued t and scheduler_act_not t
          and ct_in_state activatable\<rbrace>
        handle_hypervisor_fault t fault
      \<lbrace>\<lambda>_. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  (* commented predicate apparently not needed in ARM_HYP case. This is not verified and
     assumed for the ARM case. *)
  assumes handle_reserved_irq_valid_sched' [wp]:
    "\<And>irq.
      \<lbrace>valid_sched and invs and
         (\<lambda>s. irq \<in> non_kernel_IRQs \<longrightarrow> scheduler_act_sane s \<comment>\<open>\<and> ct_not_queued s\<close> )\<rbrace>
        handle_reserved_irq irq
      \<lbrace>\<lambda>rv. valid_sched :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_hyp_fault_cur_time[wp]:
    "\<And>t fault P. handle_hypervisor_fault t fault
                \<lbrace>(\<lambda>s. P (consumed_time s) (cur_sc s) (cur_time s) (cur_domain s)
                        (cur_thread s) (idle_thread s) (last_machine_time_of s) (time_state_of s)
                        (sc_refill_cfgs_of s) (etcbs_of s)) :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_hypervisor_fault_scheduler_act_sane[wp]:
    "\<And>t fault.
     \<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
     handle_hypervisor_fault t fault
     \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_reserved_irq_scheduler_act_sane[wp]:
    "\<And>irq. handle_reserved_irq irq \<lbrace>scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_reserved_ct_ready_if_schedulable[wp]:
    "\<And>irq. handle_reserved_irq irq \<lbrace>ct_ready_if_schedulable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_reserved_cur_sc_more_than_ready[wp]:
    "\<And>irq. handle_reserved_irq irq \<lbrace>cur_sc_more_than_ready :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_hypervisor_fault_ct_ready_if_schedulable[wp]:
    "\<And>t fault. handle_hypervisor_fault t fault \<lbrace>ct_ready_if_schedulable :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_vm_fault_not_timeout_fault[wp]:
    "\<And>thread ft.
      \<lbrace>\<top>::'state_ext state \<Rightarrow> bool\<rbrace> handle_vm_fault thread ft -,\<lbrace>\<lambda>rv s.  \<not> is_timeout_fault rv\<rbrace>"
  assumes handle_hypervisor_fault_cur_sc_in_release_q_imp_zero_consumed[wp]:
    "\<And>t fault.
       \<lbrace>cur_sc_in_release_q_imp_zero_consumed and ct_not_blocked and ct_not_in_release_q
            and valid_release_q\<rbrace>
       handle_hypervisor_fault t fault
       \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: 'state_ext state \<Rightarrow> _\<rbrace>"
  assumes handle_hypervisor_fault_ct_not_in_release_q[wp]:
    "\<And>t fault. handle_hypervisor_fault t fault \<lbrace>ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"

locale DetSchedSchedule_AI_handle_hypervisor_fault_det_ext =
  DetSchedSchedule_AI_handle_hypervisor_fault "TYPE (det_ext)"
  + DetSchedSchedule_AI_det_ext

context DetSchedSchedule_AI_handle_hypervisor_fault begin

lemma handle_interrupt_valid_sched:
  "\<lbrace>valid_sched
    and invs
    and (\<lambda>s. irq \<in> non_kernel_IRQs \<longrightarrow> scheduler_act_sane s)
    and current_time_bounded\<rbrace>
  handle_interrupt irq \<lbrace>\<lambda>rv. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_interrupt_def
  apply (wpsimp wp: get_cap_wp hoare_drop_imps hoare_vcg_all_lift send_signal_valid_sched
              simp: do_machine_op_bind current_time_bounded_def)
  done

crunch not_ct[wp]: handle_fault,lookup_reply,lookup_cap,receive_ipc,receive_signal
  "not_cur_thread target::'state_ext state \<Rightarrow> _"
  (wp: mapM_wp' maybeM_inv hoare_drop_imp hoare_vcg_if_lift2 simp: unless_def)

lemma handle_recv_not_cur_thread[wp]:
  "\<lbrace>not_cur_thread target\<rbrace> handle_recv param_a param_b \<lbrace>\<lambda>_. not_cur_thread target::'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: handle_recv_def Let_def split del: if_split)
  apply (wpsimp split_del: if_split simp: whenE_def wp: hoare_vcg_if_lift2 hoare_drop_imp)
     apply (rule_tac Q'="\<lambda>_. not_cur_thread target" in hoare_post_imp_R)
      by wpsimp+

crunch it[wp]: handle_fault,lookup_reply,lookup_cap "\<lambda>s. P (idle_thread s)"
  (wp: mapM_wp' maybeM_inv hoare_drop_imp simp: unless_def)

crunch it[wp]: receive_signal "\<lambda>s. P (idle_thread s)"
  (wp: mapM_wp' maybeM_inv hoare_drop_imp hoare_vcg_if_lift2 simp: unless_def)

lemma handle_recv_it[wp]: "\<lbrace>\<lambda>s. P (idle_thread s)\<rbrace> handle_recv param_a param_b \<lbrace>\<lambda>_ s. P (idle_thread s)\<rbrace>"
  apply (clarsimp simp: handle_recv_def Let_def split del: if_split)
  apply (wpsimp split_del: if_split simp: whenE_def wp: hoare_vcg_if_lift2 hoare_drop_imp)
     apply (rule_tac Q'="\<lambda>_ s. P (idle_thread s)" in hoare_post_imp_R)
      by wpsimp+

lemma postpone_not_queued[wp]:
  "\<lbrace>not_queued t\<rbrace> postpone scptr \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (clarsimp simp: postpone_def)
  apply (wpsimp simp: tcb_sched_action_def get_sc_obj_ref_def thread_get_def
                  wp: get_sched_context_wp hoare_drop_imp
                      set_tcb_queue_wp)
  by (clarsimp simp: in_queues_2_def tcb_sched_ready_q_update_set_simps split: option.splits)

crunches set_extra_badge
  for ct_active[wp]: "ct_active::'state_ext state \<Rightarrow> _"
  (wp: crunch_wps hoare_drop_imps dxo_wp_weak simp: cap_insert_ext_def)

lemma set_message_info_ct_active[wp]:
  "\<lbrace>ct_active\<rbrace>
    set_message_info tptr f \<lbrace>\<lambda>_. ct_active\<rbrace>"
  by (wpsimp split_del: if_split simp: set_message_info_def ct_in_state_def split_def set_object_def)

crunches do_normal_transfer, do_fault_transfer
  for ct_active[wp]: "ct_active::'state_ext state \<Rightarrow> _"
  (simp: zipWithM_x_mapM wp: mapM_wp' transfer_caps_loop_pres)

end

lemma next_domain_valid_list[wp]:
  "next_domain \<lbrace>valid_list\<rbrace>"
  unfolding next_domain_def Let_def
  apply (fold reset_work_units_def)
  apply (wpsimp | simp add: reset_work_units_def)+
  done

crunch valid_list[wp]: switch_sched_context,set_next_interrupt valid_list (wp: hoare_drop_imp)

lemma sc_and_timer_valid_list[wp]:
  "\<lbrace>valid_list\<rbrace> sc_and_timer \<lbrace>\<lambda>_. valid_list\<rbrace>"
  by (wpsimp simp: sc_and_timer_def)

lemma sched_context_bind_tcb_released_sc_tcb_at_other:
  "\<lbrace>released_sc_tcb_at t and active_sc_valid_refills and K (t \<noteq> tcb_ptr)\<rbrace>
   sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. released_sc_tcb_at t\<rbrace>"
  apply (simp add: sched_context_bind_tcb_def)
  by (wpsimp wp: set_tcb_sc_update_bound_sc_obj_tcb_at_neq)

lemma sched_context_unbind_tcb_released_if_bound[wp]:
  "sched_context_unbind_tcb sc_ptr \<lbrace>released_if_bound_sc_tcb_at t\<rbrace>"
  apply (simp add: sched_context_unbind_tcb_def)
  apply (wpsimp wp: hoare_vcg_disj_lift set_tcb_sc_update_bound_sc_obj_tcb_at_neq)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps)

crunches sched_context_unbind_all_tcbs, sched_context_yield_to
  for released_if_bound_sc_tcb_at[wp]: "released_if_bound_sc_tcb_at t"
  (wp: crunch_wps ignore: update_sched_context set_tcb_obj_ref)

lemma sched_context_unbind_all_tcbs_not_bound[wp]:
  "\<lbrace>invs and K (sc \<noteq> idle_sc_ptr)\<rbrace>
   sched_context_unbind_all_tcbs sc
   \<lbrace>\<lambda>_ s. \<not> heap_ref_eq sc t (tcb_scps_of s)\<rbrace>"
  apply (rule_tac Q="\<lambda>ya. invs and sc_tcb_sc_at (\<lambda>x. x = None) sc"
         in hoare_post_imp)
   apply (clarsimp simp: tcb_at_kh_simps[symmetric] pred_tcb_at_eq_commute)
   apply (subst (asm) sym_refs_bound_sc_tcb_iff_sc_tcb_sc_at[OF refl refl], clarsimp)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def)
  by wpsimp

lemma update_sched_context_released_if_bound_other:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> \<not> heap_ref_eq sc_ptr t (tcb_scps_of s)\<rbrace>
   update_sched_context sc_ptr f
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  apply (wpsimp wp: update_sched_context_wp)
  by (auto simp: vs_all_heap_simps obj_at_kh_kheap_simps)

lemma sched_context_zero_refill_max_released_if_bound_other:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> \<not> heap_ref_eq sc_ptr t (tcb_scps_of s)\<rbrace>
   sched_context_zero_refill_max sc_ptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: sched_context_zero_refill_max_def set_refills_def)
  by (wpsimp wp: update_sched_context_released_if_bound_other)

crunches restart_thread_if_no_fault
  for released_if_bound[wp]: "released_if_bound_sc_tcb_at t"
  (wp: crunch_wps hoare_vcg_all_lift hoare_vcg_if_lift2 )

lemma cancel_all_signals_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at t and active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_signals ntfnptr
   \<lbrace>\<lambda>_. released_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: cancel_all_signals_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac "ntfn_obj ntfn"; clarsimp?, (solves wpsimp)?)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext)
   apply wpsimp
  apply (rule hoare_strengthen_post)
   apply (rule mapM_x_wp')
   apply (wpsimp wp: gts_wp refill_unblock_check_active_sc_valid_refills hoare_drop_imps)
  apply simp
  done

crunches cancel_all_signals
  for misc[wp]: "\<lambda>s. P (tcb_scps_of s) (sc_tcbs_of s) (idle_thread s)"
  (simp: crunch_simps wp: crunch_wps)

lemma
  cancel_all_ipc_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>" and
  cancel_all_signals_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_signals ntfnptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  by (wpsimp wp: hoare_vcg_disj_lift simp: pred_map_eq_def)+

context DetSchedSchedule_AI begin

lemma reply_push_cannot_donate_active_sc_tcb_at[wp]:
  "reply_push caller callee reply_ptr False
   \<lbrace>\<lambda>(s:: 'state_ext state). active_sc_tcb_at t s\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  by (wpsimp wp: hoare_drop_imp)

lemma send_ipc_cannot_donate_active_sc_tcb_at[wp]:
  "send_ipc block call badge can_grant can_grant_reply False thread epptr
   \<lbrace>\<lambda>(s:: 'state_ext state). active_sc_tcb_at t s\<rbrace>"
  unfolding send_ipc_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)

lemma end_timeslice_canTimeout_active_sc_tcb_at[wp]:
  "end_timeslice True
   \<lbrace>\<lambda>(s:: 'state_ext state). active_sc_tcb_at t s\<rbrace>"
  unfolding end_timeslice_def handle_timeout_def send_fault_ipc_def
  by (wpsimp wp: hoare_drop_imp)

lemma check_budget_canTimeout_active_sc_tcb_at[wp]:
  "charge_budget consumeda True
   \<lbrace>\<lambda>(s:: 'state_ext state). active_sc_tcb_at t s\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imp)

lemma check_budget_ct_active_sc_tcb_at[wp]:
  "check_budget
   \<lbrace>\<lambda>(s:: 'state_ext state). active_sc_tcb_at (cur_thread s) s\<rbrace>"
  unfolding check_budget_def
  apply wpsimp
  apply (rule_tac Q="\<lambda>r s. \<forall>t. t = cur_thread s \<longrightarrow> active_sc_tcb_at t s" in hoare_strengthen_post)
  apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
  apply simp+
  by (wpsimp wp: hoare_drop_imp)+

lemma check_budget_restart_valid_sched:
  "\<lbrace>valid_sched
    and invs
    and ct_not_in_release_q
    and ct_not_queued
    and schact_is_rct
    and current_time_bounded
    and consumed_time_bounded
    and cur_sc_active
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)
    and cur_sc_not_blocked\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv s::'state_ext state. \<not>rv \<longrightarrow> valid_sched s\<rbrace>"
  apply (clarsimp simp: check_budget_restart_def)
  apply (wpsimp wp: gts_wp hoare_vcg_all_lift set_thread_state_Restart_valid_sched)
   apply (rule_tac Q="\<lambda>r s. valid_sched s \<and> (\<not>r \<longrightarrow> active_sc_tcb_at (cur_thread s) s)" in hoare_strengthen_post[rotated])
    apply (clarsimp simp: ct_in_state_def runnable_eq_active tcb_at_kh_simps vs_all_heap_simps)
   apply (wpsimp wp: hoare_vcg_if_lift2 check_budget_valid_sched hoare_drop_imp)
  apply (simp add: invs_retract_tcb_scps)
  apply (intro conjI)
    apply clarsimp
   apply (fastforce intro: invs_cur_sc_chargeableE)
  apply (clarsimp, erule (2) cur_sc_active_ct_active_sc[OF _ invs_cur_sc_tcb_symref])
  done

lemma handle_yield_valid_sched:
  "\<lbrace>valid_sched
    and invs
    and ct_not_in_release_q
    and ct_not_queued
    and ct_not_blocked
    and schact_is_rct
    and cur_sc_chargeable
    and current_time_bounded
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and cur_sc_active\<rbrace>
   handle_yield
   \<lbrace>\<lambda>rv. valid_sched::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_yield_def
  apply (wpsimp wp: charge_budget_valid_sched get_refills_wp
              simp: invs_retract_tcb_scps)
  apply (intro conjI)
     apply (clarsimp)
    apply (drule ct_not_blocked_cur_sc_not_blocked; simp)
   apply (rule_tac y=" unat MAX_PERIOD + unat MAX_PERIOD" in order_trans[rotated])
    apply (clarsimp simp: current_time_bounded_def)
   apply (rule add_mono[rotated], simp)
   apply (clarsimp simp: valid_sched_def active_sc_valid_refills_def)
   apply (drule_tac x="cur_sc s" in spec, clarsimp)
   apply (clarsimp simp: word_le_nat_alt[symmetric])
   apply (rule valid_refills_r_amount_bounded_max_sc_period)
   apply (clarsimp simp: valid_refills_def2 obj_at_def)
  apply (clarsimp simp: cur_sc_offset_ready_def obj_at_def refill_ready_def current_time_bounded_def
                        vs_all_heap_simps)
  done

lemma update_time_stamp_ct_budget_ready[wp]:
 "\<lbrace>(\<lambda>s. budget_ready (cur_thread s) s) and valid_machine_time :: 'state_ext state \<Rightarrow> _\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_ s. budget_ready (cur_thread s) s\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<exists>t. t = cur_thread s \<and> budget_ready t s"
   in hoare_strengthen_post)
  by (wpsimp wp: hoare_vcg_ex_lift)+

lemma update_time_stamp_ct_released[wp]:
 "\<lbrace>ct_released and valid_machine_time :: 'state_ext state \<Rightarrow> _\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_. ct_released\<rbrace>"
  by (wpsimp simp: released_sc_tcb_at_def)

lemma update_time_stamp_released_if_bound_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s :: 'state_ext state. released_if_bound_sc_tcb_at t s \<and> valid_machine_time s\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_ s. released_if_bound_sc_tcb_at t s\<rbrace>"
  by (wpsimp wp: hoare_vcg_disj_lift simp: released_sc_tcb_at_def)

lemma update_time_stamp_ct_released_if_bound_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s :: 'state_ext state. released_if_bound_sc_tcb_at (cur_thread s) s \<and> valid_machine_time s\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_ s. released_if_bound_sc_tcb_at (cur_thread s) s\<rbrace>"
  by (wpsimp wp: hoare_vcg_disj_lift simp: released_sc_tcb_at_def)

(* FIXME maybe move *)
lemma wcet_offset_translate:
  "x \<le> - kernelWCET_ticks - 1 \<Longrightarrow> unat x + unat kernelWCET_ticks < 2^ len_of TYPE (64)"
  by (force dest: word_leq_minus_one_le[rotated] no_plus_overflow_neg simp: no_olen_add_nat kernelWCET_ticks_non_zero)

lemma update_time_stamp_cur_sc_offset_ready[wp]:
  "\<lbrace>valid_machine_time and cur_sc_offset_ready used::'state_ext state \<Rightarrow> _\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. cur_sc_offset_ready used\<rbrace>"
  unfolding update_time_stamp_def
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule_tac Q="valid_machine_time and (cur_sc_offset_ready used and (\<lambda>s. cur_time s = previous_time))"
                in hoare_weaken_pre[rotated]; clarsimp)
  apply (rule hoare_seq_ext[OF _ dmo_getCurrentTime_sp])
   apply wpsimp
   apply (clarsimp simp: cur_sc_offset_ready_def vs_all_heap_simps unat_arith_simps(1) split: option.splits)
  by wpsimp

lemma valid_refills_cur_time[simp]:
  "valid_refills sc (s\<lparr>cur_time := b\<rparr>) = valid_refills sc s"
  by (clarsimp simp: valid_refills_def)

crunches handle_fault, invoke_domain, handle_timeout
  for ct_not_in_release_q[wp]: "ct_not_in_release_q::'state_ext state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma charge_budget_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane::'state_ext state \<Rightarrow> _\<rbrace>
   charge_budget consumed can_timeout
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: is_schedulable_wp hoare_drop_imp is_round_robin_wp)

lemma check_budget_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane::'state_ext state \<Rightarrow> _\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  by (wpsimp wp: is_schedulable_wp hoare_drop_imp)

lemma send_ipc_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: send_ipc_def wp: hoare_drop_imp possible_switch_to_scheduler_act_sane' gts_wp)
  apply (rule_tac Q="\<lambda>_. scheduler_act_sane and ct_not_blocked" in hoare_strengthen_post[rotated])
  apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps, fastforce)
  apply (wpsimp simp: send_ipc_def wp: hoare_drop_imp hoare_vcg_all_lift)+
  done

lemma maybe_donate_sc_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane \<rbrace>
   maybe_donate_sc a g
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
   unfolding maybe_donate_sc_def
   by (wpsimp wp: hoare_drop_imp)

lemma update_waiting_ntfn_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and (\<lambda>s. queue \<noteq> [] \<longrightarrow> hd queue \<noteq> cur_thread s)\<rbrace>
   update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding update_waiting_ntfn_def
  by (wpsimp wp: possible_switch_to_scheduler_act_sane' is_schedulable_wp
                 hoare_drop_imp)+

lemma send_signal_scheduler_act_sane:
  "\<lbrace>scheduler_act_sane
    and ct_not_blocked_on_ntfn
    and ct_not_blocked_on_receive
    and invs\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_signal_def
  apply (wpsimp wp: possible_switch_to_scheduler_act_sane' is_schedulable_wp)+
           apply (wpsimp wp: hoare_drop_imps)
          apply (wpsimp wp: gts_wp get_simple_ko_wp)+
  apply (intro conjI; clarsimp)
   apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps receive_blocked_def vs_all_heap_simps
                         is_blocked_thread_state_defs)
   apply (case_tac "tcb_state y"; simp)
  apply (prop_tac "tcb_at (hd x) s")
   apply (clarsimp)
  apply (prop_tac "(hd x, NTFNSignal) \<in> state_refs_of s ntfnptr")
   apply (clarsimp simp: state_refs_of_def refs_of_def get_refs_def obj_at_def split: option.splits)
  using hd_in_set apply fastforce
  apply (drule sym_refsD, clarsimp)
  apply (clarsimp)
  apply (drule TCBSignal_in_state_refs_of)
  by (clarsimp simp: tcb_at_kh_simps ct_in_state_def pred_map_eq_normalise vs_all_heap_simps)

lemma send_fault_ipc_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   send_fault_ipc tptr handler_cap fault can_donate
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_fault_ipc_def
  by (wpsimp wp: thread_set_ct_in_state)

lemma handle_timeout_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   handle_timeout tptr timeout
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def by wpsimp

lemma ipc_queued_thread_state_if[simp]:
  "ipc_queued_thread_state (if r then Restart else Inactive) = False"
  by simp

lemma do_reply_transfer_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>_. scheduler_act_sane ::'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding do_reply_transfer_def
  supply if_split[split del]
  apply (wpsimp wp: possible_switch_to_scheduler_act_sane' hoare_vcg_all_lift
                    hoare_vcg_if_lift2 sts_ctis_neq thread_set_ct_in_state
                    gts_wp get_simple_ko_wp
         | wp (once) hoare_drop_imps)+
  by (clarsimp simp: ct_in_state_def pred_tcb_at_eq_commute tcb_at_kh_simps vs_all_heap_simps)

lemma invoke_domain_valid_sched_misc[wp]:
  "invoke_domain thread domain
   \<lbrace>\<lambda>s. P (consumed_time s) (cur_sc s) (ep_send_qs_of s) (ep_recv_qs_of s) (cur_time s)
          (cur_domain s) (cur_thread s) (idle_thread s) (release_queue s)
          (tcb_sts_of s) (tcb_scps_of s) (sc_refill_cfgs_of s)\<rbrace>"
  unfolding invoke_domain_def
  by (wpsimp simp: set_domain_def)

lemma invoke_domain_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane\<rbrace>
   invoke_domain thread domain
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  unfolding invoke_domain_def
  by (wpsimp simp: set_domain_def wp: hoare_vcg_if_lift2)

lemma sched_context_bind_ntfn_valid_sched_pred_strong[wp]:
  "sched_context_bind_ntfn sc ntfn \<lbrace>valid_sched_pred_strong P\<rbrace>"
  unfolding sched_context_bind_ntfn_def
  by wpsimp

crunches sched_context_cancel_yield_to
  for sc_tcb_sc_at[wp]: "sc_tcb_sc_at P scp"
  (wp: get_tcb_obj_ref_wp)

lemma sched_context_cancel_yield_to_sc_tcb_sc_at_not_ct[wp]:
  "sched_context_cancel_yield_to sp \<lbrace> \<lambda> s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) scp s\<rbrace>"
  apply (simp add: sched_context_cancel_yield_to_def)
  by (wpsimp wp: hoare_drop_imp)

lemma sched_context_yield_to_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane
    and (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. \<exists>t. sctcb = Some t \<and> t \<noteq> cur_thread s) scptr s)\<rbrace>
   sched_context_yield_to scptr args
   \<lbrace>\<lambda>_. scheduler_act_sane\<rbrace>"
  apply (clarsimp simp: sched_context_yield_to_def assert_opt_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (clarsimp simp: when_def complete_yield_to_def bind_assoc maybeM_def get_tcb_obj_ref_def
                         get_sc_obj_ref_def)
   apply (rule hoare_seq_ext_skip, wpsimp, rename_tac yield_tcb)
   apply (case_tac yield_tcb; clarsimp)
    apply (wpsimp wp: hoare_drop_imps)
   apply (clarsimp simp: bind_assoc assert_opt_def)
   apply (rule hoare_seq_ext_skip, wpsimp)
   apply (rule hoare_seq_ext_skip, wpsimp)
   apply (rule hoare_seq_ext_skip, wpsimp)
   apply (rule hoare_seq_ext_skip)
    apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_ex_lift hoare_vcg_imp_lift'
                simp: set_consumed_def)
   apply (wpsimp wp: set_object_wp update_sched_context_wp
               simp: set_tcb_obj_ref_def)
  apply (rule hoare_seq_ext_skip)
   apply ((wpsimp wp:sched_context_resume_sc_tcb_sc_at | wps)+)[1]
  apply (rule_tac B="\<lambda>_. scheduler_act_sane" in hoare_seq_ext[rotated]; (solves \<open>wpsimp\<close>)?)
  by (wpsimp wp: set_scheduler_action_wp hoare_vcg_all_lift hoare_drop_imps
           simp: sc_at_pred_n_def obj_at_def scheduler_act_not_def
          split: if_splits
      | wps)+

lemma invoke_sched_context_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and valid_sched_context_inv iv\<rbrace>
   invoke_sched_context iv
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding invoke_sched_context_def
  apply (case_tac iv; simp)
  by (wpsimp simp:  wp: hoare_vcg_if_lift2)+

lemma invoke_sched_control_configure_flags_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane\<rbrace>
   invoke_sched_control_configure_flags x8
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding invoke_sched_control_configure_flags_def
  apply wpsimp
               apply (wpsimp wp: possible_switch_to_scheduler_act_sane')
              apply (wpsimp wp:  hoare_vcg_if_lift2 hoare_vcg_imp_lift')
             apply (wpsimp wp:  hoare_vcg_if_lift2 hoare_vcg_imp_lift')
            apply (rule_tac Q="\<lambda>_ s. scheduler_act_sane s" in hoare_strengthen_post[rotated])
             apply (clarsimp split: if_split)
  by (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp gts_wp hoare_vcg_all_lift)+

crunches invoke_irq_handler
  for scheduler_act_sane[wp]: "scheduler_act_sane::'state_ext state \<Rightarrow> _"

(* FIXME: RT move *)
lemma ct_activatable_ct_not_blocked[elim!]:
  "ct_in_state activatable s \<Longrightarrow> ct_not_blocked s"
  apply (erule ct_in_state_weaken)
  apply (fastforce dest: ipc_queued_thread_state_not_runnable)
  done

(* FIXME: RT move *)
lemma ct_activatable_ct_not_blocked_on_ntfn[elim!]:
  "ct_in_state activatable s \<Longrightarrow> ct_not_blocked_on_ntfn s"
  apply (erule ct_in_state_weaken)
  apply (case_tac st; simp)
  done

(* FIXME: RT move *)
lemma ct_activatable_ct_not_blocked_on_receive[elim!]:
  "ct_in_state activatable s \<Longrightarrow> ct_not_blocked_on_receive s"
  apply (erule ct_in_state_weaken)
  apply (case_tac st; simp add: is_blocked_thread_state_defs)
  done

lemma perform_invocation_scheduler_act_sane[wp]:
  "\<lbrace>valid_invocation iv and simple_sched_action and ct_in_state activatable and invs\<rbrace>
   perform_invocation block call can_donate iv
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac iv; simp)
  by (wpsimp wp: hoare_drop_imp invoke_cnode_scheduler_act_sane send_signal_scheduler_act_sane
                 invoke_tcb_scheduler_act_sane | fastforce)+

lemma postpone_ct_not_in_release_q:
  "\<lbrace>ct_not_in_release_q and (\<lambda>s. \<forall>t. sc_tcb_sc_at ((=) (Some t)) scp s \<longrightarrow> t\<noteq>cur_thread s)\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_. ct_not_in_release_q\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: tcb_release_enqueue_ct_not_in_release_q get_sc_obj_ref_wp)
  by (fastforce simp: sc_at_pred_n_def obj_at_def)

lemma postpone_ct_not_queued:
  "\<lbrace>ct_not_queued and (\<lambda>s. \<not> heap_ref_eq (cur_thread s) sc_ptr (sc_tcbs_of s))\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>_. ct_not_queued\<rbrace>"
  apply (simp add: postpone_def)
  by (wpsimp wp: get_sc_obj_ref_wp tcb_dequeue_not_queued | wps)+

lemma postpone_not_queued_other:
  "\<lbrace>not_queued t and (\<lambda>s. \<not> heap_ref_eq t sc_ptr (sc_tcbs_of s))\<rbrace>
   postpone sc_ptr
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (simp add: postpone_def)
  by (wpsimp wp: get_sc_obj_ref_wp tcb_dequeue_not_queued)

lemma sched_context_resume_ct_not_in_release_q:
  "\<lbrace>\<lambda>s. ct_not_in_release_q s \<and> \<not> heap_ref_eq (cur_thread s) sc_ptr (sc_tcbs_of s)\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. ct_not_in_release_q\<rbrace>"
  unfolding sched_context_resume_def
  by (wpsimp wp: postpone_ct_not_in_release_q get_tcb_queue_wp is_schedulable_wp
           simp: thread_get_def vs_all_heap_simps obj_at_kh_kheap_simps)

lemma sched_context_resume_not_queued:
  "\<lbrace>not_queued t and (\<lambda>s. \<not> heap_ref_eq t sc_ptr (sc_tcbs_of s))\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (simp add: sched_context_resume_def)
  by (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps hoare_vcg_if_lift
                 postpone_not_queued_other
           simp: if_fun_split)

lemma sched_context_resume_ct_not_queued:
  "\<lbrace>\<lambda>s. ct_not_queued s \<and> \<not> heap_ref_eq (cur_thread s) sc_ptr (sc_tcbs_of s)\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding sched_context_resume_def
  by (wpsimp wp: get_tcb_queue_wp is_schedulable_wp postpone_not_queued_other
           simp: thread_get_def sc_at_pred_n_def obj_at_def | wps)+

lemma sched_context_donate_bound_not_cur_thread:
  "\<lbrace>\<lambda>s. tcb_ptr \<noteq> cur_thread s\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>rv s. \<not> heap_ref_eq (cur_thread s) sc_ptr (sc_tcbs_of s)\<rbrace>"
  unfolding sched_context_donate_def
  apply (rule_tac hoare_seq_ext[OF _ gsct_sp])
  apply (rule_tac B = "\<lambda>_ s. tcb_ptr \<noteq> cur_thread s" in hoare_seq_ext)
  apply (wpsimp wp: set_tcb_obj_ref_wp)
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: obj_at_def sc_at_pred_n_def vs_all_heap_simps obj_at_kh_kheap_simps
                        pred_map_simps)
  by wpsimp

lemma maybe_donate_sc_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and (\<lambda>s. thread = cur_thread s \<longrightarrow> bound_sc_tcb_at bound (cur_thread s) s):: 'state_ext state \<Rightarrow> _\<rbrace>
   maybe_donate_sc thread scp
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (rule hoare_pre_tautI[where P="\<lambda>s. thread = cur_thread s"])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases, simp)
  apply (wpsimp wp: hoare_pre_cont)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  apply wpsimp
         apply (wpsimp wp: sched_context_resume_ct_not_in_release_q hoare_vcg_all_lift hoare_vcg_imp_lift')
        apply simp
      apply (wpsimp wp: sched_context_donate_bound_not_cur_thread
                  simp: vs_all_heap_simps obj_at_kh_kheap_simps)
     apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)+
  done

lemma update_waiting_ntfn_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and (\<lambda>s. queue \<noteq> [] \<longrightarrow> hd queue \<noteq> cur_thread s)\<rbrace>
   update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding update_waiting_ntfn_def
  by (wps | wpsimp wp: maybeM_inv hoare_vcg_imp_lift' set_thread_state_bound_sc_tcb_at)+

lemma send_signal_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and ct_not_blocked_on_ntfn and ct_not_blocked_on_receive and invs\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_signal_def
  apply (wpsimp wp: gts_wp ct_in_state_set hoare_drop_impE get_simple_ko_wp
                    hoare_vcg_imp_lift' set_thread_state_bound_sc_tcb_at
       | wps)+
  apply (intro conjI allI impI; clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def)
   apply (case_tac "tcb_state tcb"; simp add: receive_blocked_def)
  apply (subgoal_tac "(hd x, NTFNSignal) \<in> state_refs_of s ntfnptr")
  apply (drule sym_refsD; clarsimp)
  apply (drule TCBSignal_in_state_refs_of)
  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps pred_map_eq_normalise)
  apply (fastforce dest: hd_in_set simp: state_refs_of_def get_refs_def split: option.splits)
  done

lemma sched_context_donate_not_queued[wp]:
  "\<lbrace>ct_not_queued and (\<lambda>s. tcb_ptr \<noteq> cur_thread s) and schact_is_rct\<rbrace>
   sched_context_donate scp tcb_ptr
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp simp: set_tcb_obj_ref_def
               wp: hoare_drop_imp tcb_dequeue_not_queued get_sc_obj_ref_wp | wps)+

lemma maybe_donate_sc_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and (\<lambda>s. tcb_ptr \<noteq> cur_thread s) and schact_is_rct\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding maybe_donate_sc_def
  apply (wpsimp wp: sched_context_resume_ct_not_queued)
      apply (wpsimp wp: sched_context_donate_bound_not_cur_thread)
     apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)+
  done

lemma test_reschedule_not_ct_schact_is_rct[wp]:
  "\<lbrace>(\<lambda>s. from_tptr \<noteq> cur_thread s) and schact_is_rct\<rbrace>
   test_reschedule from_tptr
   \<lbrace>\<lambda>_. schact_is_rct :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: test_reschedule_def when_def)
  apply (intro hoare_seq_ext[OF _ gets_sp], rename_tac cur action)
  apply (clarsimp, intro conjI impI; (solves \<open>wpsimp\<close>)?)
   apply (clarsimp simp: pred_conj_def)
   apply (metis (mono_tags, lifting) hoare_assume_pre)
  apply (case_tac action; (solves \<open>wpsimp\<close>)?)
  apply (wpsimp simp: schact_is_rct_def)
  apply (metis (mono_tags, lifting) pred_andE pred_conj_assoc scheduler_action.distinct(2)
               valid_pre_satisfies_post)
  done

lemma sched_context_donate_schact_is_rct:
  "\<lbrace>(\<lambda>s. \<not> heap_ref_eq (cur_thread s) sc_ptr (sc_tcbs_of s))
    and schact_is_rct\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. schact_is_rct :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding sched_context_donate_def when_def
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (clarsimp simp: bind_assoc)
  apply (rule conjI; wpsimp)
  apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps)
  done

lemma maybe_donate_sc_schact_is_rct[wp]:
  "\<lbrace>(\<lambda>s. tcb_ptr \<noteq> cur_thread s) and schact_is_rct\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_. schact_is_rct :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def when_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip, wpsimp, rename_tac ntfn_sc)
  apply (clarsimp simp: maybeM_def)
  apply (case_tac ntfn_sc; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (wpsimp wp: sched_context_donate_schact_is_rct)
  apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps)
  done

lemma set_thread_state_act_schact_is_rct:
  "\<lbrace>schact_is_rct
    and (\<lambda>s. tcb_ptr = cur_thread s \<longrightarrow> ct_schedulable s)\<rbrace>
   set_thread_state_act tcb_ptr
   \<lbrace>\<lambda>_. schact_is_rct\<rbrace>"
  apply (clarsimp simp: set_thread_state_act_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])+
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp])
  apply (rule hoare_when_cases; fastforce?)
  apply (wpsimp wp: set_scheduler_action_wp)
  apply (subst (asm) schedulable_unfold)
  apply (clarsimp simp: schedulable_def2)
  apply (clarsimp simp: schedulable_def2 tcb_at_kh_simps vs_all_heap_simps is_sc_active_def)
  done

lemma set_thread_state_schact_is_rct_strong:
  "\<lbrace>schact_is_rct
    and (\<lambda>s. ref = cur_thread s
             \<longrightarrow> active_sc_tcb_at ref s \<and> runnable ts \<and> not_in_release_q ref s)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. schact_is_rct\<rbrace>"
  unfolding set_thread_state_def
  apply (wpsimp wp: set_thread_state_act_schact_is_rct set_object_wp)
  apply (clarsimp simp: schedulable_def2 vs_all_heap_simps tcb_at_kh_simps dest!: get_tcb_SomeD)
  apply (rule_tac x=ref' in exI, simp)
  by fastforce

lemma set_thread_state_schact_is_rct_weak:
  "\<lbrace>schact_is_rct
    and (\<lambda>s. ref \<noteq> cur_thread s)\<rbrace>
   set_thread_state ref ts
   \<lbrace>\<lambda>_. schact_is_rct\<rbrace>"
  by (wpsimp wp: set_thread_state_schact_is_rct_strong)

lemma update_waiting_ntfn_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and (\<lambda>s. queue \<noteq> [] \<longrightarrow> hd queue \<noteq> cur_thread s)
    and schact_is_rct\<rbrace>
   update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding update_waiting_ntfn_def is_schedulable_def when_def
 by (wpsimp wp: possible_switch_to_ct_not_queued hoare_drop_imp
                 set_thread_state_schact_is_rct_weak)

crunches cancel_ipc
  for schact_is_rct[wp]: "schact_is_rct"
  (wp: hoare_drop_imps crunch_wps set_thread_state_schact_is_rct_weak simp: crunch_simps)

lemma send_signal_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and ct_active and sym_refs \<circ> state_refs_of and schact_is_rct\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding send_signal_def
  apply (clarsimp simp: bind_assoc)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])

  apply (case_tac "ntfn_obj ntfn"; clarsimp?, (solves \<open>wpsimp\<close>)?)
   apply (find_goal \<open>match premises in \<open>_ = WaitingNtfn _ \<close> \<Rightarrow> \<open>-\<close>\<close>)
   apply (rename_tac queue)
   apply wpsimp
   apply (prop_tac "cur_thread s \<in> set queue")
    using list.set_sel(1) apply fastforce
   apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def)
   apply (frule_tac q=queue and t="cur_thread s" in sym_refs_WaitingNtfn_ipc_queued_thread; blast?)
   apply (metis ipc_queued_thread_state.simps(1) ipc_queued_thread_state.simps(3)
                kernel_object.inject(2) option.inject tcb_sts.all_simps(2))
  apply (case_tac "ntfn_bound_tcb ntfn"; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (wpsimp wp: possible_switch_to_not_queued hoare_drop_imp hoare_vcg_all_lift set_thread_state_schact_is_rct_weak
              simp: is_schedulable_def cong: conj_cong
         | wps)+
  apply (fastforce simp: pred_tcb_at_def obj_at_def ct_in_state_def receive_blocked_def)
  done

lemma do_reply_transfer_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and ct_not_blocked and invs\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: do_reply_transfer_def maybeM_def if_cond_refill_unblock_check_def)
  apply (rule hoare_seq_ext[OF _ grt_sp])
  apply (case_tac recv_opt, wpsimp, clarsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rename_tac receiver state)
  apply (case_tac "\<forall>r'. state \<noteq> BlockedOnReply r'", solves \<open>wpsimp\<close>, clarsimp)
  apply (rule hoare_seq_ext[OF _ assert_sp])
  apply (rule_tac S="r'=reply" in hoare_gen_asm''; clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule_tac B="\<lambda>_ s. ct_not_in_release_q s \<and> receiver \<noteq> cur_thread s
                            \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)"
           in hoare_seq_ext[rotated])
   apply wpsimp
   apply (clarsimp simp: invs_retract_tcb_scps vs_all_heap_simps ct_in_state_kh_simp)
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: maybeM_inv)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac "runnable state \<longrightarrow> sc_opt = None"
         ; clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
   apply wpsimp
  apply (rename_tac scp)
  apply (rule_tac B="\<lambda>_ s. pred_map_eq (Some scp) (tcb_scps_of s) receiver
                           \<and> pred_map runnable (tcb_sts_of s) receiver
                           \<and> ct_not_in_release_q s \<and> receiver \<noteq> cur_thread s
                            \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: refill_unblock_check_valid_sched_except_blocked hoare_vcg_disj_lift)
   apply (clarsimp simp: pred_map_simps)
  apply (wpsimp wp: postpone_ct_not_in_release_q)
  apply (clarsimp simp: heap_refs_inv_def, frule (1) heap_refs_retractD)
  by (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise vs_all_heap_simps)

lemma handle_timeout_not_queued:
  "\<lbrace>not_queued t and scheduler_act_not t
    and (\<lambda>s. \<forall>qtail tcb. ko_at (TCB tcb) t' s
                         \<longrightarrow> \<not> pred_map_eq (t # qtail) (ep_recv_qs_of s) (cap_ep_ptr (tcb_timeout_handler tcb)))\<rbrace>
   handle_timeout t' ex
   \<lbrace>\<lambda>_. not_queued t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def
  apply (wpsimp wp: send_fault_ipc_not_queued_not_ep_queued simp: obj_at_def get_tcb_def)
  apply (case_tac "kheap s t'"; clarsimp?)
  apply (case_tac a; clarsimp?)
  done

lemma handle_timeout_ct_not_queued:
  "\<lbrace>ct_not_queued and scheduler_act_sane
    and (\<lambda>s. \<forall>qtail tcb. ko_at (TCB tcb) t' s
                         \<longrightarrow> \<not> pred_map_eq ((cur_thread s) # qtail) (ep_recv_qs_of s) (cap_ep_ptr (tcb_timeout_handler tcb)))\<rbrace>
   handle_timeout t' ex
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_weaken_pre)
  by (wpsimp wp: handle_timeout_not_queued simp: obj_at_def | wps)+

lemma do_reply_transfer_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and ct_not_blocked and scheduler_act_sane and sym_refs \<circ> state_refs_of
    and tcb_at sender\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (clarsimp simp:  do_reply_transfer_def swp_def maybeM_def)
  apply (rule hoare_seq_ext[OF _ grt_sp])
  apply (case_tac recv_opt; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rename_tac receiver)
  apply (rule hoare_seq_ext[OF _ gts_sp], rename_tac state)
  apply (case_tac state; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rename_tac r)
  apply (case_tac "r = reply"; clarsimp)
  apply (clarsimp simp: sk_obj_at_pred_def obj_at_def)
  apply (rule_tac B="\<lambda>_ s. receiver \<noteq> cur_thread s
                           \<and> ct_not_queued s
                           \<and> (\<forall>ep_ptr q. ep_recv_qs_of s ep_ptr \<noteq> Some (cur_thread s # q))
                           \<and> scheduler_act_sane s
                           \<and> heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> tcb_at receiver s
                           \<and> tcb_at sender s"
            in  hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_remove_tcb_scps_of_retract hoare_vcg_all_lift)
   apply (intro conjI)
     apply (clarsimp simp: pred_tcb_at_def obj_at_def ct_in_state_def)
     apply (case_tac "tcb_state tcb"; clarsimp?)
    apply (clarsimp simp: obj_at_def ct_in_state_def pred_tcb_at_def vs_all_heap_simps)
    apply (frule_tac t="cur_thread s" in sym_refs_RecvEP_ipc_queued_thread; blast?, simp?)
    apply (clarsimp simp: vs_all_heap_simps)
   apply fastforce

  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: maybeM_inv)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (clarsimp simp: when_def pred_conj_def)
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ assert_opt_sp])
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_if)
   apply (wpsimp wp: possible_switch_to_ct_not_queued)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_if)
   apply (wpsimp wp: handle_timeout_ct_not_queued
               simp: pred_tcb_at_def obj_at_def ct_in_state_def vs_all_heap_simps)
  apply (wpsimp wp: postpone_ct_not_queued)
  apply (clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (frule (1) heap_refs_retractD)
  apply (clarsimp simp: vs_all_heap_simps)
  done

lemma handle_invocation_scheduler_act_sane[wp]:
  "\<lbrace>schact_is_rct and invs and ct_active\<rbrace>
   handle_invocation False False True True reply_cptr
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def syscall_def
  apply (simp add: handle_invocation_def ts_Restart_case_helper split_def
                   liftE_liftM_liftME liftME_def bindE_assoc)
  apply (wpsimp wp: hoare_drop_imp ct_in_state_set hoare_drop_impE)
      apply (rule validE_cases_valid, clarsimp)
      apply (subst validE_R_def[symmetric])
      apply (rule_tac Q'="\<lambda>rv s. simple_sched_action s \<and> cur_thread s = thread
                                  \<and> st_tcb_at active thread s \<and> invs s
                                  \<and> valid_invocation rv s"
                   in hoare_post_imp_R[rotated])
       apply (clarsimp cong: conj_cong simp: ct_in_state_def pred_tcb_at_def obj_at_def)
      apply (wp decode_inv_wf)
     apply (wpsimp wp: hoare_vcg_conj_lift hoare_drop_imps)
     apply (rule validE_cases_valid, clarsimp)
     apply (subst validE_R_def[symmetric])
     apply wpsimp+
  apply (fastforce simp: ct_in_state_def)
  done

lemma sched_context_resume_not_in_release_q_other:
  "\<lbrace>not_in_release_q t and sc_tcb_sc_at (\<lambda>sc_tcb. sc_tcb \<noteq> Some t) sc_ptr\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  by (wpsimp wp: sched_context_resume_not_in_release_q simp: sc_tcb_sc_at_def obj_at_def)

lemma sched_context_bind_tcb_not_in_release_q_other:
  "\<lbrace>not_in_release_q t and K (t \<noteq> tcb_ptr)\<rbrace>
   sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  apply (simp add: sched_context_bind_tcb_def)
  by (wpsimp wp: sched_context_resume_not_in_release_q_other sc_tcb_update_sc_tcb_sc_at)

lemma sched_context_bind_tcb_not_queued_other:
  "\<lbrace>not_queued t and K (t \<noteq> tcb_ptr) and scheduler_act_not t\<rbrace>
   sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. not_queued t\<rbrace>"
  apply (simp add: sched_context_bind_tcb_def)
  by (wpsimp wp: reschedule_required_not_queued tcb_sched_enqueue_not_queued update_sched_context_wp
                 sched_context_resume_not_queued sc_tcb_update_sc_tcb_sc_at
                 hoare_vcg_all_lift hoare_drop_imps
           simp: is_schedulable_def vs_all_heap_simps)

lemma sched_context_yield_to_not_in_release_q_other:
  "\<lbrace>not_in_release_q t and sc_tcb_sc_at (\<lambda>sctcb. sctcb \<noteq> Some t) sc_ptr\<rbrace>
   sched_context_yield_to sc_ptr args
   \<lbrace>\<lambda>_. not_in_release_q t\<rbrace>"
  apply (simp add: sched_context_yield_to_def)
  by (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps get_sc_obj_ref_wp
                 sched_context_resume_not_in_release_q_other)

lemma sched_context_update_consumed_sc_yf_sc_at[wp]:
  "sched_context_update_consumed sc_ptr \<lbrace>sc_yf_sc_at P sc_ptr \<rbrace>"
  unfolding sched_context_update_consumed_def
  by (wpsimp wp: update_sched_context_wp
           simp: sc_at_pred_n_def obj_at_def)

crunches sched_context_resume
  for sched_context_at[wp]: "\<lambda>s. \<exists>n. ko_at (SchedContext sc n) sc_ptr s"
  (wp: mapM_wp' get_simple_ko_wp hoare_drop_imps)

crunches sched_context_bind_tcb, sched_context_yield_to, invoke_irq_handler
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  (wp: crunch_wps)

crunches sched_context_unbind_all_tcbs
  for not_in_release_queue[wp]: "not_in_release_q t"
  (wp: crunch_wps simp: crunch_simps)

lemma invoke_sched_context_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and valid_sched_context_inv i and schact_is_rct and invs\<rbrace>
   invoke_sched_context i
   \<lbrace>\<lambda>_. ct_not_in_release_q\<rbrace>"
  apply (simp add: invoke_sched_context_def)
  apply (cases i; simp)
      apply (find_goal \<open>match premises in \<open>_ = InvokeSchedContextBind _ _\<close> \<Rightarrow> \<open>-\<close>\<close>)
      apply (wpsimp wp: sched_context_bind_tcb_not_in_release_q_other | wps)+
      apply (clarsimp dest!: invs_cur_sc_tcb_symref simp: pred_tcb_at_def obj_at_def)
     apply (find_goal \<open>match premises in \<open>_ = InvokeSchedContextYieldTo _ _\<close> \<Rightarrow> \<open>-\<close>\<close>)
     apply wp_pre
      apply (wpsimp wp: sched_context_yield_to_not_in_release_q_other | wps)+
     apply (clarsimp simp: sc_at_ppred_def obj_at_def)
    apply (wpsimp | wps)+
  done

crunches invoke_irq_handler
  for not_in_release_queue[wp]: "not_in_release_q t :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma cap_delete_one_not_queued[wp]:
  "\<lbrace>valid_objs and sym_refs \<circ> state_refs_of and st_tcb_at active t and scheduler_act_not t
    and not_queued t\<rbrace>
   cap_delete_one slot
   \<lbrace>\<lambda>_. not_queued t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding cap_delete_one_def
  by (wpsimp wp: fast_finalise_not_queued empty_slot_valid_sched get_object_wp simp: get_cap_def)

lemma invoke_irq_handler_not_queued[wp]:
  "\<lbrace>valid_objs and sym_refs \<circ> state_refs_of and st_tcb_at active t and scheduler_act_not t
    and not_queued t\<rbrace>
   invoke_irq_handler iv
   \<lbrace>\<lambda>_. not_queued t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (cases iv; wpsimp)

crunches set_domain
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"

lemma perform_invocation_first_phase_ct_not_in_release_q:
  "\<lbrace>ct_not_in_release_q and invs and ct_active and valid_invocation i
    and schact_is_rct and K (safe_invocation i)\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_gen_asm)
  apply (cases i; (wpsimp | wps)+)
   apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def
                   split: thread_state.splits)
  done

lemma perform_invocation_first_phase_ct_not_queued:
  "\<lbrace>ct_not_in_release_q and ct_not_queued and invs and ct_active and valid_invocation i
    and schact_is_rct and K (safe_invocation i)\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_gen_asm)
  apply (cases i; (wpsimp wp: send_ipc_not_queued | wps)+)

    \<comment> \<open>Discharge preconditions for InvokeEndpoint\<close>
    apply (intro conjI)
     apply (erule schact_is_rct_sane)
    apply (clarsimp simp: obj_at_def is_ep_def vs_all_heap_simps)
    apply (frule RecvEP_queued_ipc_queued_thread, fastforce)
    apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def vs_all_heap_simps)

   \<comment> \<open>Discharge preconditions for InvokeReply\<close>
   apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def is_tcb_def)

  \<comment> \<open>Discharge preconditions for InvokeIRQHandler\<close>
  apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def)+
  done

lemma handle_invocation_first_phase_ct_not_in_release_q[wp]:
  "\<lbrace>ct_not_in_release_q and invs and ct_active and schact_is_rct and ct_schedulable\<rbrace>
   handle_invocation calling blocking can_donate True reply_cptr
   \<lbrace>\<lambda>_. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: handle_invocation_def split_def ts_Restart_case_helper)
  apply (wpsimp wp: syscall_valid set_thread_state_ct_st hoare_drop_imps
                    perform_invocation_first_phase_ct_not_in_release_q
                    sts_schedulable_scheduler_action)
  apply (auto simp: ct_in_state_def fault_tcbs_valid_states_active
              dest: invs_fault_tcbs_valid_states
              elim: st_tcb_ex_cap)
  done

lemma reply_push_ct_in_state:
  "\<lbrace>ct_in_state P and (\<lambda>s. caller = cur_thread s \<longrightarrow> (\<forall>y. P (BlockedOnReply y)))\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding reply_push_def bind_sc_reply_def
  by (wpsimp wp: sts_ctis_neq hoare_vcg_if_lift2 hoare_drop_imp hoare_vcg_all_lift
                 get_simple_ko_wp)

lemma handle_invocation_first_phase_ct_not_queued[wp]:
  "\<lbrace>ct_not_in_release_q and ct_not_queued and invs and ct_active and schact_is_rct and ct_schedulable\<rbrace>
   handle_invocation False False can_donate True reply_cptr
   \<lbrace>\<lambda>_. ct_not_queued :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: handle_invocation_def split_def ts_Restart_case_helper)
  apply (wpsimp wp: syscall_valid set_thread_state_ct_st hoare_drop_imps
                    perform_invocation_first_phase_ct_not_queued
                    sts_schedulable_scheduler_action)
  apply (auto simp: ct_in_state_def fault_tcbs_valid_states_active
              dest: invs_fault_tcbs_valid_states
              elim: st_tcb_ex_cap)
done

lemma sched_context_donate_bound_sc_obj_tcb_at_other:
  "\<lbrace>\<lambda>s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s) \<and> tcb_ptr \<noteq> t \<and>
        \<not> heap_ref_eq t sc_ptr (sc_tcbs_of s)\<rbrace>
   sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>_ s. N (bound_sc_obj_tcb_at (P (cur_time s)) t s)\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def)
  apply (wpsimp wp: set_tcb_sc_update_bound_sc_obj_tcb_at_neq get_sc_obj_ref_wp)
  by (fastforce simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma sched_context_donate_caller_not_bound:
  "\<lbrace>\<lambda>s. heap_ref_eq caller caller_sc (sc_tcbs_of s) \<and> callee \<noteq> caller\<rbrace>
   sched_context_donate caller_sc callee
   \<lbrace>\<lambda>_ s. pred_map_eq None (tcb_scps_of s) caller\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def tcb_at_kh_simps[symmetric])
  apply (wpsimp wp: ssc_bound_tcb_at_cases hoare_vcg_imp_lift' get_sc_obj_ref_wp)
  by (auto simp: obj_at_kh_kheap_simps pred_map_eq_normalise vs_all_heap_simps)

lemma sched_context_donate_released_if_bound_caller:
  "\<lbrace>\<lambda>s. heap_ref_eq caller caller_sc (sc_tcbs_of s) \<and> callee \<noteq> caller\<rbrace>
   sched_context_donate caller_sc callee
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at caller\<rbrace>"
  by (wpsimp wp: hoare_disjI1 sched_context_donate_caller_not_bound)

lemma sched_context_donate_released_if_bound_not_callee:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> callee \<noteq> t\<rbrace>
   sched_context_donate caller_sc callee
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  apply (rule hoare_weaken_pre, rule hoare_pre_disj)
    apply (rule sched_context_donate_released_if_bound_caller)
   apply (rule hoare_vcg_disj_lift)
    apply (rule sched_context_donate_bound_sc_tcb_at_None)
   apply (rule sched_context_donate_bound_sc_obj_tcb_at_other)
  by clarsimp

lemma reply_push_released_if_bound_not_callee:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> (can_donate \<longrightarrow> callee \<noteq> t)\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  supply if_weak_cong[cong del]
  apply (simp add: reply_push_def bind_sc_reply_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac sc_caller; simp)
   apply wpsimp
  apply (wpsimp wp: sched_context_donate_released_if_bound_not_callee
                    get_simple_ko_wp hoare_vcg_if_lift)
    apply (wpsimp wp: hoare_vcg_disj_lift hoare_vcg_imp_lift' hoare_vcg_all_lift
                      set_thread_state_ko update_sk_obj_ref_wps)+
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps pred_map_eq_normalise is_tcb)

lemma send_ipc_released_if_bound[wp]:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> active_sc_valid_refills s
        \<and> (can_donate \<longrightarrow> st_tcb_at active t s \<and> valid_objs s \<and> sym_refs (state_refs_of s))\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>rv. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_weak_cong[cong del]
  apply (simp add: send_ipc_def)
  apply (rule hoare_seq_ext [OF _ get_simple_ko_sp])
  apply (case_tac ep, simp_all)
    apply wpsimp
   apply wpsimp
  apply (rename_tac list)
  apply (case_tac list; simp)
  apply (rename_tac dest queue)
  apply (wpsimp wp: reply_push_released_if_bound_not_callee)
           apply (wpsimp wp: sched_context_donate_released_if_bound_not_callee)
          apply (wpsimp wp: hoare_drop_imp)
         apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at t s \<and> active_sc_valid_refills s \<and> (can_donate \<longrightarrow> dest \<noteq> t)"
                in hoare_post_imp, clarsimp)
         apply wpsimp+
    apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at t s \<and> active_sc_valid_refills s \<and> (can_donate \<longrightarrow> dest \<noteq> t)"
           in hoare_post_imp, clarsimp)
    apply wpsimp+
  apply (subgoal_tac "st_tcb_at (not active) t s")
   apply (clarsimp simp: pred_tcb_at_def obj_at_def pred_neg_def)
  apply (erule ep_queued_st_tcb_at; clarsimp)
  apply (rule refl)
  done

lemma send_fault_ipc_no_donation_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t
    and active_sc_valid_refills\<rbrace>
   send_fault_ipc tptr handler_cap fault False
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: send_fault_ipc_def)

lemma handle_timeout_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t
    and active_sc_valid_refills\<rbrace>
   handle_timeout tptr ex
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: handle_timeout_def)

lemma reply_remove_released_if_bound_other:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> caller \<noteq> t\<rbrace>
   reply_remove caller r
   \<lbrace>\<lambda>rv. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding reply_remove_def
  by (wpsimp wp: sched_context_donate_released_if_bound_not_callee
                 hoare_vcg_if_lift2 get_tcb_obj_ref_wp get_simple_ko_wp)

crunches reply_remove
  for valid_machine_time[wp]: valid_machine_time
  (wp: crunch_wps)

lemma do_reply_transfer_released_if_bound[wp]:
  "\<lbrace>released_sc_tcb_at t
    and active_sc_valid_refills
    and current_time_bounded
    and st_tcb_at active t\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>rv. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: do_reply_transfer_def)
  apply wpsimp
              apply (wpsimp wp: hoare_vcg_all_lift hoare_drop_imp weak_if_wp')
             apply (clarsimp cong: conj_cong)
             apply wpsimp
            apply wpsimp
           apply wpsimp
          apply wpsimp
         apply (wpsimp wp: refill_unblock_check_active_sc_valid_refills)
        apply (wpsimp wp: hoare_vcg_all_lift hoare_drop_imp weak_if_wp' reply_remove_released_if_bound_other)
       apply (wpsimp wp: gts_wp get_simple_ko_wp)+
  by (fastforce simp: pred_tcb_at_def obj_at_def)

lemma maybe_donate_sc_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at t\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_. released_sc_tcb_at t\<rbrace>"
  apply (clarsimp simp: maybe_donate_sc_def)
  apply (wpsimp wp: sched_context_donate_bound_sc_obj_tcb_at_other get_sc_obj_ref_wp
                    get_sk_obj_ref_wp get_tcb_obj_ref_wp hoare_drop_imp)
  by (auto simp: obj_at_kh_kheap_simps vs_all_heap_simps)

lemma update_waiting_ntfn_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at t
    and active_sc_valid_refills
    and current_time_bounded\<rbrace>
   update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. released_sc_tcb_at t\<rbrace>"
  unfolding update_waiting_ntfn_def
  by (wpsimp wp: refill_unblock_check_active_sc_valid_refills hoare_drop_imp is_schedulable_wp)

crunches send_signal
  for released_sc_tcb_at[wp]: "released_sc_tcb_at t"
  and cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  (ignore: thread_set wp: crunch_wps simp: crunch_simps)

crunches do_reply_transfer, invoke_sched_context
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  (wp: crunch_wps)

lemma invoke_sched_context_released_sc_tcb_at[wp]:
  "\<lbrace>released_sc_tcb_at t and valid_sched_context_inv i and invs and valid_sched\<rbrace>
   invoke_sched_context i
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  apply (simp add: invoke_sched_context_def)
  apply (cases i; (solves \<open>wpsimp\<close>)?; simp)
  apply (match premises in \<open>_ = InvokeSchedContextBind _ _\<close> \<Rightarrow> \<open>-\<close>)
  apply (wpsimp wp: sched_context_bind_tcb_released_sc_tcb_at_other hoare_disjI2)
  apply (clarsimp simp: obj_at_kh_kheap_simps vs_all_heap_simps valid_sched_active_sc_valid_refills)
  done

lemma fast_finalise_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and invs and st_tcb_at (not ipc_queued_thread_state) t
    and (\<lambda>s. \<exists>slot. cte_wp_at ((=) cap) slot s)
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   fast_finalise cap final
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
  apply (wpsimp wp: reply_remove_released_if_bound_other gts_wp get_simple_ko_wp)
  apply (fastforce simp: tcb_at_kh_simps pred_map_def pred_neg_def)
  done

lemma cap_delete_one_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and invs and st_tcb_at (not ipc_queued_thread_state) t
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   cap_delete_one slot
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: cap_delete_one_def)
  apply (wpsimp wp: get_cap_wp)
  by (cases slot; fastforce)

lemma invoke_irq_handler_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and invs and st_tcb_at (not ipc_queued_thread_state) t
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   invoke_irq_handler i
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (cases i; wpsimp)

lemma update_time_stamp_released_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s :: 'state_ext state. released_sc_tcb_at t s \<and> valid_machine_time s\<rbrace>
  update_time_stamp
  \<lbrace>\<lambda>_ s. released_sc_tcb_at t s\<rbrace>"
  apply (wpsimp wp: hoare_vcg_disj_lift simp: released_sc_tcb_at_def)
  done

lemma preemption_point_released_if_bound_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s :: 'state_ext state. released_sc_tcb_at t s \<and> valid_machine_time s\<rbrace>
  preemption_point
  \<lbrace>\<lambda>_ s. released_sc_tcb_at t s\<rbrace>"
  apply (wpsimp simp: preemption_point_def
                  wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

lemma invoke_untyped_released_if_bound_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s. released_sc_tcb_at t s \<and> invs s \<and> ex_nonz_cap_to t s \<and> ct_active  s
       \<and> scheduler_action s = resume_cur_thread \<and> valid_untyped_inv ui s \<and> valid_machine_time s\<rbrace>
  invoke_untyped ui
  \<lbrace>\<lambda>_ s :: 'state_ext state. released_sc_tcb_at t s\<rbrace>"
  apply (rule validI)
  apply (clarsimp simp: pred_map2'_pred_maps obj_at_kh_kheap_simps[symmetric] pred_tcb_at_eq_commute)
  apply (rename_tac sc_ptr)
  apply (frule use_valid[OF _ invoke_untyped_st_tcb_at], simp)
  apply (frule use_valid)
    apply (rule_tac scp=sc_ptr and P="released_sc (cur_time s)" and N=\<top>
                 in invoke_untyped_sc_at_pred_n[where proj=sc_refill_cfg_of, simplified])
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
   apply (rule_tac t=t and tcb=tcb in ex_nonz_cap_to_tcb_implies_ex_nonz_cap_to_sc)
      apply simp+
  apply (frule use_valid[OF _ invoke_untyped_valid_machine_time], simp)
  apply (prop_tac "cur_time s \<le> cur_time s'")
   apply (fast dest: use_valid[OF _ invoke_untyped_cur_time_monotonic])
  apply (fastforce dest: released_sc_cur_time_increasing)
  done

lemma perform_invocation_first_phase_released_if_bound:
  "\<lbrace>released_sc_tcb_at t and invs and valid_sched and valid_machine_time  and ct_active
    and valid_invocation i and schact_is_rct and ex_nonz_cap_to t and st_tcb_at active t
    and K (safe_invocation i)
    and current_time_bounded\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_ s :: 'state_ext state. released_if_bound_sc_tcb_at t s\<rbrace>"
  apply (rule hoare_weaken_pre[where Q="P and current_time_bounded and active_sc_valid_refills"
                                 and P=P for P])
  apply (cases i; simp, (solves \<open>wpsimp\<close>)?)
     apply (wpsimp wp: hoare_disjI2)
     apply (wpsimp, fastforce)
   apply (wpsimp wp: hoare_disjI2)+
  done

lemma perform_invocation_first_phase_cur_thread:
  "\<lbrace>\<lambda>s. P (cur_thread s) \<and> safe_invocation i\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_ s :: 'state_ext state. P (cur_thread s)\<rbrace>"
  apply (rule hoare_gen_asm_conj)
  by (cases i; wpsimp)

lemma handle_invocation_first_phase_ct_released[wp]:
  "\<lbrace>ct_released and invs and valid_sched and valid_machine_time and ct_active and schact_is_rct
    and ct_schedulable and current_time_bounded\<rbrace>
   handle_invocation calling False can_donate True reply_cptr
   \<lbrace>\<lambda>_ s :: 'state_ext state. released_if_bound_sc_tcb_at (cur_thread s) s\<rbrace>"
  apply (simp add: handle_invocation_def split_def ts_Restart_case_helper)
  apply (wpsimp wp: syscall_valid set_thread_state_ct_st hoare_drop_imps
                    sts_schedulable_scheduler_action set_thread_state_runnable_valid_sched
                    perform_invocation_first_phase_released_if_bound
                    perform_invocation_first_phase_cur_thread sts_st_tcb_at_pred
         | wps
         | rule valid_validE, rule hoare_lift_Pf2_pre_conj[where f=cur_thread])+
  apply (auto simp: ct_in_state_def
              elim: st_tcb_ex_cap pred_tcb_weakenE)
  done

lemma send_ipc_ct_in_state:
  "\<lbrace>ct_in_state P and
    (\<lambda>s. (thread = cur_thread s \<longrightarrow> block \<longrightarrow> (\<forall>pl. P (BlockedOnSend epptr pl)))
         \<and> (\<forall>st. is_blocked_on_receive st \<longrightarrow> P st \<longrightarrow> P Running \<and> P Inactive)
         \<and> (thread = cur_thread s \<longrightarrow>
            ((call \<or> fault_tcb_at bound (cur_thread s) s) \<longrightarrow> (\<forall>y. P (BlockedOnReply y))))
         \<and> (thread = cur_thread s \<longrightarrow> P Inactive)):: 'state_ext state \<Rightarrow> _\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding send_ipc_def
  apply (wpsimp wp: sts_ctis_neq hoare_vcg_if_lift2 hoare_vcg_all_lift hoare_vcg_disj_lift
                    reply_push_ct_in_state sts_ctis_neq)
            apply (wpsimp wp: thread_get_wp')+
        apply (rule_tac Q="\<lambda>a b. ct_in_state P b
                                 \<and> (cur_thread b = x21 \<longrightarrow> P Running)
                                 \<and> (thread = cur_thread b \<longrightarrow> (call \<or> fault_tcb_at bound thread b)
                                    \<longrightarrow> (\<forall>y. P (BlockedOnReply y)) \<and> (\<not>can_grant \<longrightarrow> (P Inactive)))" in hoare_strengthen_post[rotated])
         apply (fastforce simp: pred_tcb_at_def obj_at_def)
        apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_all_lift reply_unlink_tcb_ct_in_state_weak hoare_vcg_imp_lift')
       apply clarsimp
       apply (rule_tac Q="\<lambda>a b. ct_in_state P b
                                \<and> (cur_thread b = x21 \<longrightarrow> (P Running \<and> P Inactive))
                                \<and> (thread = cur_thread b \<longrightarrow> (call \<or> fault_tcb_at bound thread b)
                                   \<longrightarrow> (\<forall>y. P (BlockedOnReply y)))
                                \<and> (thread = cur_thread b \<longrightarrow> (P Inactive))" in hoare_strengthen_post[rotated])
        apply (clarsimp simp: pred_tcb_at_def obj_at_def)[1]
       apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_all_lift reply_unlink_tcb_ct_in_state_weak hoare_vcg_imp_lift')
      apply (wpsimp wp: gts_wp)+
    apply wps
    apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_all_lift reply_unlink_tcb_ct_in_state_weak hoare_vcg_imp_lift')
   apply (wpsimp wp: get_simple_ko_wp)
  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps ct_in_state_def is_blocked_thread_state_defs)
  apply fastforce
  done

lemma handle_timeout_ct_not_blocked_on_ntfn:
  "handle_timeout tptr ex \<lbrace>ct_not_blocked_on_ntfn :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def send_fault_ipc_def
  by (wpsimp wp: send_ipc_ct_in_state thread_set_ct_in_state)

lemma handle_timeout_ct_in_state:
  "\<lbrace>ct_in_state P
    and (\<lambda>s. tptr = cur_thread s)
    and (\<lambda>_. (\<forall>pl x. P (BlockedOnSend x pl))
             \<and> (\<forall>st. is_blocked_on_receive st \<longrightarrow> P st \<longrightarrow> P Running)
             \<and> (\<forall>y. P (BlockedOnReply y))
             \<and> P Inactive)\<rbrace>
   handle_timeout tptr ex
   \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def send_fault_ipc_def
  apply (wpsimp wp: send_ipc_ct_in_state thread_set_wp thread_set_ct_in_state
              simp: send_fault_ipc_def)
  apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps dest!: get_tcb_SomeD)
  done

lemma end_timeslice_ct_not_blocked_on_ntfn[wp]:
  "end_timeslice t \<lbrace>ct_not_blocked_on_ntfn :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  by (wpsimp wp: hoare_drop_imp handle_timeout_ct_not_blocked_on_ntfn)

lemma end_timeslice_ct_in_state:
  "\<lbrakk>P Inactive; P Running; \<forall>y. P (BlockedOnReply y); \<forall>x z. P (BlockedOnSend x z)\<rbrakk>
   \<Longrightarrow> end_timeslice t \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  by (wpsimp wp: hoare_drop_imp handle_timeout_ct_in_state)

lemma refill_reset_rr_ct_in_state[wp]:
  "refill_reset_rr scp \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding refill_reset_rr_def update_refill_tl_def update_refill_hd_def set_refill_tl_def
            set_refill_hd_def
  by wpsimp

lemma charge_budget_ct_in_state:
  "\<lbrakk>P Inactive; P Running; \<forall>y. P (BlockedOnReply y); \<forall>x z. P (BlockedOnSend x z)\<rbrakk>
   \<Longrightarrow> charge_budget consumed t \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imp end_timeslice_ct_in_state)

lemma charge_budget_ct_not_blocked_on_ntfn[wp]:
  "charge_budget consumed t \<lbrace>ct_not_blocked_on_ntfn :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: charge_budget_ct_in_state)

lemma check_budget_ct_not_blocked_on_ntfn[wp]:
  "check_budget \<lbrace>ct_not_blocked_on_ntfn :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  by (wpsimp wp: hoare_drop_imp)

lemma check_budget_ct_in_state:
  "\<lbrakk>P Inactive; P Running; \<forall>y. P (BlockedOnReply y); \<forall>x z. P (BlockedOnSend x z)\<rbrakk>
   \<Longrightarrow> check_budget \<lbrace>ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  by (wpsimp wp: hoare_drop_imp charge_budget_ct_in_state)

lemma valid_sched_ct_not_queued:
  "\<lbrakk>valid_sched s; schact_is_rct s\<rbrakk> \<Longrightarrow> ct_not_queued s"
  by (fastforce simp: valid_sched_def ct_not_in_q_def schact_is_rct_def)

lemma ct_not_blocked_cur_sc_not_blocked_trivial:
  "cur_sc_tcb_only_sym_bound s \<and> ct_not_blocked s \<Longrightarrow> cur_sc_not_blocked s"
  by (rule ct_not_blocked_cur_sc_not_blocked[OF strengthen_cur_sc_chargeable]; clarsimp)


lemma refill_bounded_helper:
  "valid_refills (cur_sc s) s
   \<Longrightarrow> 2*unat MAX_PERIOD \<le> unat max_time
   \<Longrightarrow> (\<forall>sc. (\<exists>n. kheap s (cur_sc s) = Some (SchedContext sc n)) \<longrightarrow>
                   unat (r_amount (refill_hd sc)) + unat MAX_PERIOD \<le> unat max_time)"
  apply clarsimp
  apply (erule order_trans[rotated])
  apply (clarsimp simp: vs_all_heap_simps valid_refills_def)
  apply (subst word_le_nat_alt[symmetric], rule valid_refills_r_amount_bounded_max_sc_period)
  apply (clarsimp simp: sc_valid_refills_def)
  done

lemma update_time_stamp_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding update_time_stamp_def
  apply (rule_tac hoare_seq_ext[OF _ gets_sp])
  apply wpsimp
   apply (rule_tac P="(consumed_time_bounded and (\<lambda>s. cur_time s = previous_time))"
          in dmo_getCurrentTime_wp)
    apply (clarsimp simp: valid_def consumed_time_bounded_def)
    apply (subst unat_add_lem', overflow_hammer)
     apply (subst unat_sub, simp)
     apply (metis (no_types, hide_lams) add_mono_thms_linordered_semiring(3)
            le_add_diff_inverse le_trans max_word_max unat_arith_simps(1) )
    apply (subst unat_sub, simp)
    apply (subst add_diff_assoc, overflow_hammer)
    apply linarith
   apply wpsimp
  apply clarsimp
  done

lemma preemption_point_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift
              simp: OR_choiceE_def)
  done

crunches cancel_badged_sends
  for cur_time[wp]: "(\<lambda>s. P (cur_time s)) :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps filterM_preserved simp: crunch_simps)

crunches handle_fault
  for cur_time[wp]: "(\<lambda>s. P (cur_time s)) :: 'state_ext state \<Rightarrow> _"
  and consumed_time_bounded[wp]: "consumed_time_bounded :: 'state_ext state \<Rightarrow> _"

(* FIXME: move *)
lemma consumed_time_detype[simp]:
  "consumed_time (detype r s) = consumed_time s"
  by (simp add: detype_def)

lemma retype_region_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   retype_region ptr numObjects o_bits type dev
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: retype_region_def wp: mapME_x_wp_inv mapM_x_wp_inv)
  done

lemma reset_untyped_cap_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   reset_untyped_cap slot
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: reset_untyped_cap_def)
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply (rule valid_validE)
  apply (rule hoare_if; (solves wpsimp)?)
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply (rule valid_validE)
  apply (rule hoare_if; (solves wpsimp)?)
  apply (rule_tac Q="\<lambda>_. ?pre" in hoare_strengthen_post)
   apply (wpsimp wp: mapME_x_wp_inv)+
  done

lemma preemption_point_current_time_bounded[wp]:
  "preemption_point \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_drop_imps update_time_stamp_current_time_bounded)
  done

lemma reset_untyped_cap_current_time_bounded[wp]:
  "reset_untyped_cap slot \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: reset_untyped_cap_def)
  apply (wpsimp wp: mapME_x_wp_inv get_cap_wp)
  done

lemma invoke_untyped_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   invoke_untyped ui
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: invoke_untyped_def wp: mapME_x_wp_inv mapM_x_wp_inv)
  done

lemma invoke_untyped_current_time_bounded[wp]:
  "invoke_untyped ui \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: invoke_untyped_def
                  wp: mapM_x_wp_inv)
  done

crunches finalise_cap, send_signal, do_reply_transfer, schedule, activate_thread
  for consumed_time_bounded[wp]: "consumed_time_bounded :: 'state_ext state \<Rightarrow> _"
  and current_time_bounded[wp]: "current_time_bounded :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma rec_del_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   rec_del call
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_strengthen_post)
   apply (rule rec_del_preservation, wpsimp+)
  done

crunches restart, install_tcb_frame_cap, install_tcb_cap, maybe_sched_context_unbind_tcb,
         maybe_sched_context_bind_tcb, bind_notification, invoke_sched_context,
         invoke_sched_control_configure_flags
  for consumed_time_bounded[wp]: "consumed_time_bounded :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv simp: crunch_simps)

crunches install_tcb_cap
  for vmt[wp]: "valid_machine_time :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv simp: crunch_simps)

lemma invoke_tcb_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   invoke_tcb tcb_inv
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (cases tcb_inv; simp)
          apply (wpsimp wp: mapM_x_wp_inv hoare_vcg_conj_lift hoare_drop_imps)+
    apply (rename_tac ntfnptr_opt)
    apply (case_tac ntfnptr_opt; clarsimp?)
     apply wpsimp+
  done

lemma invoke_tcb_current_time_bounded[wp]:
  "invoke_tcb tcb_inv \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (cases tcb_inv; simp)
          apply (wpsimp wp: mapM_x_wp_inv hoare_vcg_conj_lift hoare_drop_imps)+
    apply (rename_tac ntfnptr_opt)
    apply (case_tac ntfnptr_opt; clarsimp?)
     apply wpsimp+
  done

crunches cancel_badged_sends, invoke_irq_handler
  for ctb[wp]: "consumed_time_bounded :: 'state_ext state \<Rightarrow> _"
  and current_time_bounded[wp]: "current_time_bounded :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv filterM_preserved simp: crunch_simps)

lemma invoke_cnode_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   invoke_cnode i
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: invoke_cnode_def)
  apply (cases i; clarsimp)
       apply (wpsimp wp: mapM_x_wp hoare_vcg_conj_lift hoare_drop_imps cap_revoke_preservation
                   simp: invoke_cnode_def)
      apply (wpsimp wp: mapM_x_wp hoare_vcg_conj_lift hoare_drop_imps cap_revoke_preservation
                  simp: invoke_cnode_def)
     apply (rule hoare_strengthen_post)
      apply (rule validE_valid)
      apply (rule cap_revoke_preservation, wpsimp+)
   apply (intro conjI impI)
    apply wpsimp+
  done

lemma invoke_cnode_current_time_bounded[wp]:
  "invoke_cnode i \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: invoke_cnode_def)
  apply (cases i; clarsimp)
       apply (wpsimp wp: mapM_x_wp hoare_vcg_conj_lift hoare_drop_imps cap_revoke_preservation
                   simp: invoke_cnode_def)
      apply (wpsimp wp: mapM_x_wp hoare_vcg_conj_lift hoare_drop_imps cap_revoke_preservation
                  simp: invoke_cnode_def)
     apply (rule hoare_strengthen_post)
      apply (rule validE_valid)
      apply (rule cap_revoke_preservation, wpsimp+)
   apply (intro conjI impI)
    apply wpsimp+
  done

lemma perform_invocation_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   perform_invocation block call can_donate iv
   \<lbrace>\<lambda>_. consumed_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (cases iv; wpsimp)
  done

lemma perform_invocation_current_time_bounded[wp]:
  "perform_invocation block call can_donate iv \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (cases iv; wpsimp)
  done

crunches handle_call, handle_send, handle_recv, handle_yield, check_budget_restart, handle_interrupt
  for consumed_time_bounded'[wp]: "consumed_time_bounded :: 'state_ext state \<Rightarrow> _"
  (wp: syscall_valid crunch_wps check_cap_inv hoare_vcg_all_lift simp: crunch_simps ignore: syscall)

crunches check_budget_restart
  for valid_machine_time[wp]: "valid_machine_time :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps)

lemma update_time_stamp_cur_sc_offset_ready_cs[wp]:
  "\<lbrace>valid_machine_time and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) (s:: 'state_ext state))\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_ s. cur_sc_active s \<longrightarrow>  cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  unfolding update_time_stamp_def
  apply (rule_tac hoare_seq_ext[OF _ gets_sp])
  apply wpsimp
   apply (rule_tac P="\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s \<and> cur_time s = previous_time"
          in dmo_getCurrentTime_wp)
    apply (clarsimp simp: vs_all_heap_simps refill_ready_no_overflow_def)
    apply (rename_tac sc n)
    apply (rule_tac y="unat (r_time (refill_hd sc)) + unat (consumed_time s) + unat (rv - cur_time s)" in order_trans)
     apply clarsimp
     apply (rule unat_plus_gt)
    apply (subst unat_sub, assumption)
    apply (subst diff_add_assoc[symmetric])
     apply overflow_hammer
    apply (clarsimp simp: le_diff_conv)
   apply wpsimp
  apply clarsimp
  done

lemma strengthen_consumed_time_bound:
  "unat (cur_time s) + unat MAX_PERIOD \<le> unat max_time
   \<and> unat (consumed_time s) \<le> unat (cur_time s)
   \<Longrightarrow> unat (consumed_time s) + unat MAX_PERIOD \<le> unat max_time"
  by linarith

lemma handle_invocation_current_time_bounded[wp]:
  "handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>current_time_bounded :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid hoare_drop_imp hoare_drop_impE)
  done

end

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

lemma check_budget_restart_valid_sched_weaker:
  "\<lbrace>valid_sched
    and invs
    and ct_not_in_release_q
    and ct_not_queued
    and schact_is_rct
    and current_time_bounded
    and consumed_time_bounded
    and cur_sc_active
    and ct_not_blocked
    and (\<lambda>s. valid_refills (cur_sc s) s \<and>
            (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s))\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv s::det_ext state. \<not>rv \<longrightarrow> valid_sched s\<rbrace>"
  apply (wpsimp wp: check_budget_restart_valid_sched
              simp: consumed_time_bounded_def current_time_bounded_def)
  apply (erule (2) ct_not_blocked_cur_sc_not_blocked[OF invs_cur_sc_chargeableE])
  done

lemma check_budget_valid_sched_weaker:
  "\<lbrace>valid_sched
    and invs
    and ct_not_in_release_q and ct_not_queued
    and scheduler_act_sane and cur_sc_chargeable
    and consumed_time_bounded
    and current_time_bounded
    and cur_sc_active
    and ct_not_blocked
    and (\<lambda>s. valid_refills (cur_sc s) s)
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. valid_sched::det_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp wp: check_budget_valid_sched simp: invs_retract_tcb_scps)
  apply (erule (1) ct_not_blocked_cur_sc_not_blocked)
  done

lemma check_budget_cur_sc_offset_sufficient_true[wp]:
  "\<lbrace>\<top>\<rbrace> check_budget \<lbrace>\<lambda>rv s. rv \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: gts_wp hoare_vcg_all_lift)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def refill_sufficient_def)
  done

lemma check_budget_restart_cur_sc_offset_sufficient_true[wp]:
  "\<lbrace>\<top>\<rbrace> check_budget_restart \<lbrace>\<lambda>rv s. rv \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding check_budget_restart_def
  apply (wpsimp wp: gts_wp hoare_vcg_all_lift)
  apply (rule_tac Q="\<lambda>rv s. rv \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s" in hoare_strengthen_post[rotated], clarsimp)
  by (wpsimp, simp)

crunches update_time_stamp
  for ct_not_bocked[wp]: ct_not_blocked
  and ct_in_state[wp]: "ct_in_state P"
  and tcb_scps_of_sc_tcbs_of[wp]: "\<lambda>s. P (tcb_scps_of s) (sc_tcbs_of s)"

method handle_event_valid_sched_single
  = (wpsimp wp: handle_invocation_valid_sched)
     , simp add: imp_conjR
     , ((wpsimp wp: hoare_vcg_conj_lift
         | wpsimp wp: check_budget_restart_true check_budget_restart_valid_sched_weaker
                      update_time_stamp_current_time_bounded)+
     , fastforce elim!: valid_sched_ct_not_queued active_from_running
                 intro: active_sc_valid_refillsE)

method handle_event_valid_sched_combined
  =(wpsimp wp: handle_invocation_valid_sched handle_recv_valid_sched
                check_budget_restart_valid_sched_weaker handle_invocation_current_time_bounded
          simp: schedulable_def2 active_sc_tcb_at_fold),
    simp add: imp_conjR,
    (wpsimp wp: hoare_vcg_conj_lift
     | wpsimp wp: check_budget_restart_true check_budget_restart_valid_sched_weaker
                  update_time_stamp_current_time_bounded hoare_drop_imps)+,
    subgoal_tac "ct_released s",
    fastforce dest: valid_sched_ct_not_queued
              elim: active_from_running
              simp: runnable_eq_active released_sc_tcb_at_def
                    active_sc_tcb_at_fold ct_in_state_def2[symmetric]
             intro: active_sc_valid_refillsE,
    (rule schact_is_rct_ct_released; fastforce?),
    (frule invs_strengthen_cur_sc_tcb_are_bound; fastforce?),
    (rule cur_sc_not_idle_sc_ptr; fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def)

method handle_event_valid_sched_yield
  = (wpsimp wp: handle_yield_valid_sched
     , simp add: imp_conjR
     , (wpsimp wp: check_budget_restart_true check_budget_restart_valid_sched_weaker
                   update_time_stamp_current_time_bounded)+
     , fastforce elim!: valid_sched_ct_not_queued elim: invs_cur_sc_chargeableE
                intro!: active_sc_valid_refillsE)

method handle_event_valid_sched_fault
  = ((wpsimp wp: handle_fault_valid_sched check_budget_restart_valid_sched_weaker
                 check_budget_restart_true hoare_vcg_if_lift2 hoare_vcg_disj_lift
                 update_time_stamp_current_time_bounded
      | strengthen invs_retract_tcb_scps)+
     , frule active_from_running
     , clarsimp simp: valid_fault_def ct_in_state_def2[symmetric] is_timeout_fault_def
     , strengthen schact_is_rct_sane valid_sched_ct_not_queued
                  ct_runnable_ct_not_blocked
     , simp,subgoal_tac "ct_released s",
    fastforce dest: valid_sched_ct_not_queued
              elim: active_from_running
              simp: runnable_eq_active released_sc_tcb_at_def
                    active_sc_tcb_at_fold ct_in_state_def2[symmetric]
             intro: active_sc_valid_refillsE,
    (rule schact_is_rct_ct_released; fastforce?),
    (frule invs_strengthen_cur_sc_tcb_are_bound; fastforce?),
    (rule cur_sc_not_idle_sc_ptr; fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def))

lemma handle_event_valid_sched:
  "\<lbrace>invs
    and valid_sched
    and ct_in_state activatable
    and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)
    and cur_sc_active
    and ct_not_in_release_q
    and schact_is_rct
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s)
    and current_time_bounded
    and valid_machine_time
    and consumed_time_bounded\<rbrace>
   handle_event e
   \<lbrace>\<lambda>rv. valid_sched :: det_state \<Rightarrow> _\<rbrace>"

  apply (cases e, simp_all)

  (* SyscallEvent *)
       subgoal for syscall
         by (case_tac syscall, simp_all add: handle_send_def handle_call_def liftE_bindE
             , (handle_event_valid_sched_single
                | handle_event_valid_sched_combined
                | handle_event_valid_sched_yield)+)

      apply (find_goal \<open>match premises in "_ = Interrupt" \<Rightarrow> \<open>-\<close>\<close>)
      defer

      apply handle_event_valid_sched_fault+

   (* HypervisorEvent *)
   apply wpsimp
   apply (clarsimp simp: ct_in_state_def schact_is_rct_def valid_sched_def ct_not_in_q_def
                         pred_tcb_at_def obj_at_def)

  (* Interrupt *)
  apply wpsimp
      apply (wpsimp wp: handle_interrupt_valid_sched check_budget_restart_valid_sched_weaker)
     apply (wpsimp wp: check_budget_valid_sched_weaker hoare_vcg_all_lift hoare_vcg_imp_lift')
    apply(rule_tac Q="\<lambda>_. valid_sched and invs and ct_not_in_release_q
                          and ct_in_state activatable
                          and cur_sc_active
                          and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                          and consumed_time_bounded
                          and schact_is_rct and ct_not_queued
                          and (\<lambda>s. valid_refills (cur_sc s) s)
                          and current_time_bounded" in hoare_strengthen_post[rotated])
     apply (clarsimp simp: if_split)
     apply (intro conjI allI impI)
           apply fastforce
          apply (fastforce intro: invs_cur_sc_chargeableE)
         apply (fastforce elim: ct_in_state_weaken)
        apply fastforce
       apply (fastforce intro: invs_cur_sc_chargeableE)
      apply (fastforce elim: ct_in_state_weaken)
     apply fastforce
    apply (wpsimp wp: update_time_stamp_current_time_bounded)
   apply wpsimp
   apply (clarsimp simp: ct_in_state_def)
  apply (fastforce elim!: valid_sched_ct_not_queued
                    elim: invs_cur_sc_chargeableE ct_in_state_weaken
                  intro!: active_sc_valid_refillsE)
  done

crunches activate_thread, schedule_choose_new_thread, awaken
  for valid_list[wp]: valid_list
  (wp: crunch_wps)

lemma schedule_valid_list[wp]: "\<lbrace>valid_list\<rbrace> Schedule_A.schedule \<lbrace>\<lambda>_. valid_list\<rbrace>"
  apply (simp add: Schedule_A.schedule_def)
  apply (wp add: tcb_sched_action_valid_list alternative_wp select_wp gts_wp hoare_drop_imps
                 is_schedulable_wp hoare_vcg_all_lift
         | wpc | simp)+
  done

lemma call_kernel_valid_list[wp]: "\<lbrace>valid_list\<rbrace> call_kernel e \<lbrace>\<lambda>_. valid_list\<rbrace>"
  apply (simp add: call_kernel_def preemption_path_def)
  by (wpsimp wp: is_schedulable_wp hoare_drop_imps hoare_vcg_all_lift)+

lemma handle_event_consumed_time_bounded[wp]:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   handle_event e
   \<lbrace>\<lambda>_. consumed_time_bounded :: det_state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp; wpsimp wp: hoare_drop_imp hoare_drop_impE cong: conj_cong)
  done

end

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

lemma rec_del_ct_not_queued:
 "\<lbrace>ct_not_queued and scheduler_act_sane and ct_not_blocked and invs and valid_rec_del_call args
        and (\<lambda>s. \<not> exposed_rdcall args
               \<longrightarrow> ex_cte_cap_wp_to (\<lambda>cp. cap_irqs cp = {}) (slot_rdcall args) s)
        and (\<lambda>s. case args of ReduceZombieCall cap sl ex \<Rightarrow>
                       \<not> cap_removeable cap sl
                       \<and> (\<forall>t\<in>obj_refs cap. halted_if_tcb t s)
                  | _ \<Rightarrow> True)\<rbrace>
  rec_del args
  \<lbrace>\<lambda>rv. ct_not_queued :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule validE_valid)
  apply (rule hoare_post_impErr)
  apply (rule hoare_pre)
    apply (rule use_spec)
    apply (rule rec_del_invs''[where Q="ct_not_queued and scheduler_act_sane and ct_not_blocked"])
         apply (wpsimp | wpsimp wp: preemption_point_inv simp: ct_in_state_def)+
  done

lemma cap_delete_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked\<rbrace>
   cap_delete c
   \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding cap_delete_def
  by (wpsimp wp: rec_del_ct_not_queued)

lemma install_tcb_frame_cap_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_frame_cap_def
  by (wpsimp wp: check_cap_inv hoare_vcg_imp_lift')

lemma install_tcb_cap_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked\<rbrace>
   install_tcb_cap target slot n slot_opt
   \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_vcg_imp_lift')

lemma tcc_ct_not_queued:
  "\<lbrace>ct_not_queued
    and invs
    and scheduler_act_sane
    and ct_not_blocked
    and tcb_inv_wf (ThreadControlCaps target slot fault_handler timeout_handler croot vroot buffer)\<rbrace>
   invoke_tcb (ThreadControlCaps target slot fault_handler timeout_handler croot vroot buffer)
   \<lbrace>\<lambda>rv. ct_not_queued :: det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: split_def cong: option.case_cong)
  apply wp
      \<comment> \<open>install_tcb_caps\<close>
      apply invoke_tcb_install_tcb_cap_helper+
  \<comment> \<open>resolve using precondition\<close>
  apply simp
  apply (strengthen tcb_cap_valid_ep_strgs)
  apply (clarsimp cong: conj_cong)
  apply (intro conjI impI;
         clarsimp simp: is_cnode_or_valid_arch_is_cap_simps tcb_ep_slot_cte_wp_ats real_cte_at_cte
                 dest!: is_valid_vtable_root_is_arch_cap)
     apply (all \<open>clarsimp simp: is_cap_simps cte_wp_at_caps_of_state valid_fault_handler_def\<close>)
    apply (all \<open>clarsimp simp: obj_at_def is_tcb typ_at_eq_kheap_obj cap_table_at_typ\<close>)
  by auto

lemma invoke_tcb_ct_not_queuedE_E[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked and tcb_inv_wf iv\<rbrace>
   invoke_tcb iv
   -, \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac iv)
          apply (wpsimp)
         apply (wpsimp)
        apply (wpsimp)
       apply (rule valid_validE_E)
       apply (wpsimp wp: tcc_ct_not_queued[simplified])
      apply wpsimp
     apply (wpsimp)
    apply (wpsimp)
   apply (case_tac x82; simp)
    apply (wpsimp)
   apply (wpsimp)
  apply (wpsimp)
  done

lemma cap_revoke_ct_not_queued[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked\<rbrace> cap_revoke slot \<lbrace>\<lambda>rv. ct_not_queued :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_strengthen_post)
   apply (rule validE_valid, rule cap_revoke_preservation)
    apply (wpsimp wp: preemption_point_inv')+
    apply (clarsimp simp: ct_in_state_def)+
  done

lemma invoke_cnode_ct_not_queuedE_E[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked\<rbrace>
   invoke_cnode iv
   -, \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding invoke_cnode_def
  by wpsimp

lemma perform_invocation_ct_not_queued:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked and valid_invocation iv\<rbrace>
   perform_invocation blocking calling can_donate iv
   -, \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac iv; simp)
  by wpsimp+

lemma cap_cap_slot_fold:
  "(\<forall>cap ref cnodeindex. x = (cap, ref, cnodeindex) \<longrightarrow> P cap ref cnodeindex) = P (fst x) (fst (snd x)) (snd (snd x))"
  by (metis fst_conv snd_conv surj_pair)

lemma handle_invocation_ct_not_queued_E_E:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_active\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   -, \<lbrace>\<lambda>rv. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid perform_invocation_ct_not_queued set_thread_state_ct_in_state
              simp: cap_cap_slot_fold)
  by (fastforce simp: ct_in_state_def elim: pred_tcb_weakenE)

lemma handle_event_ct_not_queuedE_E[wp]:
  "\<lbrace>ct_not_queued and invs and scheduler_act_sane and ct_not_blocked and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)\<rbrace>
   handle_event e
    -, \<lbrace>\<lambda>_. ct_not_queued :: det_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp)
       subgoal for syscall
             apply (case_tac syscall; simp)
             apply (wpsimp simp: handle_call_def handle_send_def
                             wp: handle_invocation_ct_not_queued_E_E check_budget_restart_true
                    | erule active_from_running)+
       done
      apply wpsimp+
  done

end

context DetSchedSchedule_AI begin

lemma reply_unlink_tcb_valid_release_q[wp]:
  "\<lbrace> valid_release_q and not_in_release_q tp\<rbrace>
     reply_unlink_tcb tp rp
   \<lbrace> \<lambda>_. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: reply_unlink_tcb_def
               wp: set_thread_state_valid_release_q gts_wp get_simple_ko_wp)

lemma reply_remove_tcb_valid_release_q[wp]:
  "\<lbrace> valid_release_q and not_in_release_q tp\<rbrace>
   reply_remove_tcb tp rp
   \<lbrace> \<lambda>_. valid_release_q:: 'state_ext state \<Rightarrow> _ \<rbrace>"
  by (wpsimp simp: reply_remove_tcb_def wp: hoare_drop_imp)

lemma blocked_cancel_ipc_valid_release_q[wp]:
  "\<lbrace> valid_release_q and not_in_release_q tptr\<rbrace>
     blocked_cancel_ipc state tptr reply_opt
   \<lbrace> \<lambda>_. valid_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: blocked_cancel_ipc_def)
  by (wpsimp wp: set_thread_state_valid_release_q hoare_drop_imp)

crunches handle_interrupt
for ct_active[wp]: "ct_active::'state_ext state \<Rightarrow> _"

crunches handle_interrupt
for cur_thread[wp]: "\<lambda>s::det_state. P (cur_thread s)"
  (wp: hoare_drop_imp crunch_wps simp: crunch_simps)

crunches handle_reserved_irq
  for release_queue[wp]: "\<lambda>s. P (release_queue s)"
  and valid_release_q[wp]: "\<lambda>s. valid_release_q s"

crunches install_tcb_cap
  for ct_not_in_release_q[wp]: "ct_not_in_release_q :: 'state_ext state \<Rightarrow> _"
  (wp: crunch_wps preemption_point_inv ignore: check_cap_at simp: check_cap_at_def)

lemma cap_revoke_ct_not_in_release_q[wp]:
  "cap_revoke slot \<lbrace>ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: cap_revoke_preservation2 preemption_point_inv)

lemma invoke_cnode_ct_not_in_release_qE_E[wp]:
  "\<lbrace>ct_not_in_release_q\<rbrace>
   invoke_cnode iv
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  by (wpsimp simp: invoke_cnode_def)+

lemma invoke_tcb_ct_not_in_release_qE_E[wp]:
  "\<lbrace>ct_not_in_release_q\<rbrace>
   invoke_tcb iv
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac iv; simp)
           prefer 8
           apply (case_tac x82; wpsimp)
          apply (wpsimp simp: install_tcb_frame_cap_def | wpsimp wp: hoare_drop_imps)+
  done

lemma perform_invocation_ct_not_in_release_qE_E[wp]:
  "\<lbrace>ct_not_in_release_q \<rbrace>
   perform_invocation block call can_donate iv
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (case_tac iv; wpsimp)

lemma handle_invocation_ct_not_in_release_qE_E[wp]:
  "\<lbrace>ct_not_in_release_q\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def syscall_def
  apply (simp add: handle_invocation_def ts_Restart_case_helper split_def
                   liftE_liftM_liftME liftME_def bindE_assoc)
  apply (wpsimp wp: syscall_valid hoare_drop_imps set_thread_state_ct_in_state
                    perform_invocation_ct_not_in_release_qE_E[simplified pred_conj_def conj_assoc])
  done

lemma handle_event_ct_not_in_release_qE_E[wp]:
  "\<lbrace>ct_not_in_release_q\<rbrace>
   handle_event e
   -, \<lbrace>\<lambda>rv. ct_not_in_release_q :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp)
       apply (rename_tac syscall)
       apply (case_tac syscall; simp)
                 apply (wpsimp simp: handle_send_def handle_call_def
                                 wp: handle_invocation_ct_not_in_release_qE_E
                                     check_budget_restart_true)+
  done

lemma check_budget_restart_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv. scheduler_act_sane \<rbrace>"
  unfolding check_budget_restart_def
  by wpsimp

lemma check_budget_restart_simple_sched_action_sane[wp]:
  "\<lbrace>simple_sched_action :: 'state_ext state \<Rightarrow> _\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv. simple_sched_action \<rbrace>"
  unfolding check_budget_restart_def
  by wpsimp

lemma handle_fault_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   handle_fault thread x1
   \<lbrace>\<lambda>rv. scheduler_act_sane:: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_fault_def handle_no_fault_def send_fault_ipc_def
  by (wpsimp wp: thread_set_ct_in_state)

crunches do_nbrecv_failed_transfer
  for scheduler_action[wp]: "\<lambda>s. P (scheduler_action s) (cur_thread s)"
  (wp: crunch_wps ignore: possible_switch_to)

crunches schedule_tcb, maybe_return_sc, complete_signal
  for scheduler_action[wp]: "scheduler_act_sane"
  (wp: crunch_wps hoare_vcg_all_lift simp: crunch_simps)

crunches maybe_return_sc
  for ct_in_state[wp]: "ct_in_state P"
  (wp: crunch_wps simp: crunch_simps)

lemma receive_ipc_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   receive_ipc thread cap is_blocking reply_cap
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: receive_ipc_def wp: hoare_drop_imp possible_switch_to_scheduler_act_sane' gts_wp)
             apply (rule_tac Q="\<lambda>_. scheduler_act_sane and ct_not_blocked" in hoare_strengthen_post[rotated])
              apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)
             apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift get_simple_ko_wp)+
  done

lemma receive_signal_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane\<rbrace>
   receive_signal thread cap is_blocking
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp simp: receive_signal_def wp: hoare_drop_imp gts_wp)

lemma handle_recv_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   handle_recv is_blocking can_reply
   \<lbrace>\<lambda>rv. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding handle_recv_def
  by (wpsimp wp: thread_set_ct_in_state hoare_drop_imp hoare_vcg_all_lift
           simp: Let_def lookup_cap_def)

lemma handle_fault_reply_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked\<rbrace>
   handle_fault_reply cap thread label msg
   \<lbrace>\<lambda>_. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (case_tac cap; wpsimp)

lemma cap_cap_slot_fold:
  "(\<forall>cap ref cnodeindex. x = (cap, ref, cnodeindex) \<longrightarrow> P cap ref cnodeindex) = P (fst x) (fst (snd x)) (snd (snd x))"
  by (metis fst_conv snd_conv surj_pair)

lemma handle_invocation_schact_sane:
  "\<lbrace>simple_sched_action and ct_in_state active and invs\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>\<lambda>rv. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def
  supply if_split [split del]
  apply (wpsimp wp: syscall_valid)
         apply (wpsimp wp: hoare_drop_imp, clarsimp cong: conj_cong)
        apply (wpsimp wp: perform_invocation_scheduler_act_sane, clarsimp cong: conj_cong)
       apply (wpsimp wp: ct_in_state_set)
      apply wpsimp
     apply (wpsimp wp: hoare_drop_imps simp: cap_cap_slot_fold)
    apply wpsimp
   apply wpsimp
  apply (clarsimp cong: conj_cong split: if_splits)
  by (fastforce simp: ct_in_state_def
                elim: st_tcb_at_strengthen_pred
               intro: runnable_nonz_cap_to fault_tcbs_valid_states_active)

(* FIXME: RT move to Invariants_AI *)
lemma ct_active_fault_tcb_at_None:
  "ct_active s \<Longrightarrow> fault_tcbs_valid_states s \<Longrightarrow> fault_tcb_at ((=) None) (cur_thread s) s"
  apply (erule fault_tcbs_valid_states_active)
  apply (clarsimp simp: fault_tcbs_valid_states_def ct_in_state_def)
  done

lemma update_waiting_ntfn_ct_in_state[wp]:
  "\<lbrace>ct_in_state P and (\<lambda>s. queue \<noteq> [] \<longrightarrow> cur_thread s = hd queue \<longrightarrow> P Running)\<rbrace>
     update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (simp add: update_waiting_ntfn_def)
  by (wpsimp wp: sts_ctis_neq maybeM_inv)

lemma install_tcb_frame_cap_ct_not_blocked[wp]:
  "\<lbrace>ct_not_blocked\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding install_tcb_frame_cap_def
  by (wpsimp wp: check_cap_inv hoare_drop_imp thread_set_ct_in_state)

lemma bind_notification_ct_not_blocked[wp]:
  "\<lbrace>ct_in_state P\<rbrace>
   bind_notification tcbptr ntfnptr
   \<lbrace>\<lambda>rv. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding bind_notification_def
  by (wpsimp wp: set_tcb_obj_ref_ct_in_state)

lemma test_possible_switch_to_ct_not_blocked[wp]:
  "\<lbrace>ct_in_state P\<rbrace>
   test_possible_switch_to thread
   \<lbrace>\<lambda>rv. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding test_possible_switch_to_def
  by (wpsimp wp: set_tcb_obj_ref_ct_in_state)

lemma restart_ct_not_blocked[wp]:
  "\<lbrace>ct_in_state P and (\<lambda>s. thread = cur_thread s \<longrightarrow> (P Restart \<and> P Inactive))\<rbrace>
   restart thread
   \<lbrace>\<lambda>rv. ct_in_state P :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding restart_def
  apply (wpsimp wp: hoare_vcg_imp_lift' sts_ctis_neq cancel_ipc_ct_in_state get_tcb_obj_ref_wp gts_wp maybeM_inv)
  done

crunches maybe_sched_context_unbind_tcb, maybe_sched_context_bind_tcb
  for ct_not_blocked[wp]: "ct_not_blocked :: 'state_ext state \<Rightarrow> _"
  (simp: crunch_simps wp: crunch_wps set_tcb_obj_ref_ct_in_state)

crunches set_priority
  for ct_not_blocked[wp]: "ct_not_blocked :: 'state_ext state \<Rightarrow> _"
  (ignore: set_object simp: crunch_simps wp: crunch_wps thread_set_ct_in_state)

lemma invoke_tcb_ct_not_blocked[wp]:
  "\<lbrace>ct_not_blocked\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  apply (case_tac iv; simp)
          prefer 8
          apply (rename_tac tptr epptr_opt)
          apply (case_tac epptr_opt; simp)
           apply (wpsimp wp: mapM_x_wp_inv hoare_drop_imp)+
  done

lemma invoke_untyped_ct_not_blocked[wp]:
  "\<lbrace>invs and ct_active and valid_untyped_inv iv\<rbrace>
   invoke_untyped iv
   -, \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding invoke_untyped_def
  apply wpsimp
  apply (clarsimp simp: ct_in_state_def)
  apply (frule(1) st_tcb_ex_cap[OF _ invs_iflive])
   apply fastforce
  apply (drule ex_nonz_cap_to_overlap,
         ((simp add: cte_wp_at_caps_of_state descendants_range_def2
                     empty_descendants_range_in)+))
  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
  done

lemma cap_revoke_ct_not_blocked[wp]:
  "\<lbrace>ct_not_blocked\<rbrace>
   cap_revoke slot
   \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  by (wpsimp wp: cap_revoke_preservation)

lemma invoke_cnode_ct_not_blocked[wp]:
  "\<lbrace>ct_not_blocked\<rbrace>
   invoke_cnode iv
   -, \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding invoke_cnode_def
  by wpsimp

lemma perform_invocation_ct_not_blocked[wp]:
  "\<lbrace>invs and ct_active and valid_invocation iv\<rbrace>
   perform_invocation block call can_donate iv
   -, \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (case_tac iv; wpsimp)

lemma handle_invocation_ct_not_blocked[wp]:
  "\<lbrace>ct_active and invs\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   -, \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def
  supply if_split [split del]
  apply (wpsimp wp: syscall_valid)
               apply (wpsimp wp: set_thread_state_ct_in_state)
              apply wpsimp
         apply (wpsimp)
   apply (rule_tac Q'="\<lambda>r s.
                  thread = cur_thread s \<and>
                  ct_active s \<and>
                  s \<turnstile> (fst r) \<and>
                  invs s \<and>
                  cte_wp_at ((=) (fst r)) (snd r) s \<and>
                  ex_cte_cap_wp_to (\<lambda>_. True) (snd r) s \<and>
                  real_cte_at (snd r) s \<and>
                  (\<forall>r\<in>zobj_refs (fst r). ex_nonz_cap_to r s) \<and> invs s" in hoare_post_imp_R[rotated])
      apply (clarsimp simp: ct_in_state_def invs_valid_objs cong: conj_cong)
      apply wpsimp+
  done

lemma handle_event_ct_not_blockedE_E[wp]:
  "\<lbrace>ct_in_state activatable and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s) and invs\<rbrace>
   handle_event e
   -, \<lbrace>\<lambda>rv. ct_not_blocked :: 'state_ext state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp)
       subgoal for syscall
       apply (case_tac syscall; simp)
                  apply (wpsimp simp: handle_call_def handle_send_def wp: check_budget_restart_true
                         | erule active_from_running)+
       done
       apply (wpsimp)+
  done

lemma handle_yield_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane\<rbrace>
   handle_yield
   \<lbrace>\<lambda>rv. scheduler_act_sane :: 'state_ext state \<Rightarrow> _\<rbrace>"
  unfolding handle_yield_def
  by wpsimp

lemma check_budget_restart_if_lift:
  "\<lbrace>R\<rbrace> check_budget_restart \<lbrace>\<lambda>_. Q\<rbrace>
   \<Longrightarrow> \<lbrace>P and R\<rbrace> check_budget_restart \<lbrace>\<lambda>r. if r then P else Q\<rbrace>"
  apply (wpsimp wp: hoare_vcg_if_lift2 check_budget_restart_true)
                 apply (wpsimp wp: hoare_drop_imp, simp)
  done

lemma check_budget_ct_not_blocked_on_receive[wp]:
  "check_budget \<lbrace>ct_not_blocked_on_receive :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: check_budget_ct_in_state)

lemma charge_budget_ct_not_blocked_on_receive[wp]:
  "charge_budget consumed canTimeout \<lbrace>ct_not_blocked_on_receive :: 'state_ext state \<Rightarrow> _\<rbrace>"
  by (wpsimp wp: charge_budget_ct_in_state)

lemmas check_budget_restart_false = hoare_drop_imp[where f=check_budget_restart and R="\<lambda>r s. \<not>r"]

lemma cur_sc_chargeable_sc_not_in_release_q:
  "cur_sc_chargeable (s :: 'state_ext state)
   \<Longrightarrow> valid_release_q s
   \<Longrightarrow> ct_not_in_release_q s
   \<Longrightarrow> sc_not_in_release_q (cur_sc s) s"
  apply (clarsimp)
  apply (subgoal_tac "t = cur_thread s \<or> pred_map inactive (tcb_sts_of s) t")
  apply (erule disjE)
  apply clarsimp
  apply (frule_tac t=t in valid_release_q_not_in_release_q_not_runnable)
  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
  apply clarsimp
  apply (clarsimp simp: cur_sc_chargeable_def)
  done

end

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

lemma handle_interrupt_scheduler_act_sane[wp]:
  "\<lbrace>scheduler_act_sane and ct_not_blocked_on_ntfn and ct_not_blocked_on_receive and invs\<rbrace>
   handle_interrupt irq
   \<lbrace>\<lambda>_. scheduler_act_sane :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_interrupt_def
  by (wpsimp wp: hoare_drop_imp send_signal_scheduler_act_sane hoare_vcg_if_lift2)

lemmas schact_is_rct_ct_active_sc = invs_cur_sc_tcb_symref[THEN cur_sc_active_ct_active_sc[rotated]]

lemma handle_event_scheduler_act_sane:
  "\<lbrace>schact_is_rct
    and invs
    and ct_in_state activatable
    and cur_sc_active
    and ct_not_in_release_q
    and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)\<rbrace>
   handle_event e
   \<lbrace>\<lambda>_. scheduler_act_sane :: det_state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; simp)
       apply (rename_tac syscall)
  subgoal for syscall
    apply (case_tac syscall; simp)
              apply (wpsimp simp: handle_call_def
                              wp: handle_invocation_schact_sane check_budget_restart_true check_budget_restart_false)
              apply (fastforce elim: active_from_running)
             apply ((wpsimp wp: handle_invocation_schact_sane check_budget_restart_true
                                 check_budget_restart_false
                    | strengthen ct_runnable_ct_not_blocked active_from_running)+)[1]
             apply (clarsimp simp: schedulable_def2 )
             apply (strengthen schact_is_rct_ct_active_sc)
             apply (clarsimp simp: schact_is_rct_def ct_in_state_def2[symmetric] runnable_eq_active)
             apply (fastforce elim: active_from_running)
            apply ((wpsimp simp: handle_call_def handle_send_def
                            wp: handle_invocation_schact_sane check_budget_restart_true
                                check_budget_restart_false
                   | strengthen ct_runnable_ct_not_blocked active_from_running)+)[1]
            apply (clarsimp simp: schedulable_def2 )
            apply (strengthen schact_is_rct_ct_active_sc)
            apply (clarsimp simp: schact_is_rct_def ct_in_state_def2[symmetric] runnable_eq_active)
            apply (fastforce elim: active_from_running)
           apply ((wpsimp simp: handle_call_def handle_send_def
                           wp: handle_invocation_schact_sane check_budget_restart_true
                               check_budget_restart_false
                  | strengthen ct_runnable_ct_not_blocked active_from_running)+)[1]
           apply (clarsimp simp: schedulable_def2 )
           apply (strengthen schact_is_rct_ct_active_sc)
           apply (clarsimp simp: schact_is_rct_def ct_in_state_def2[symmetric] runnable_eq_active)
           apply (fastforce elim: active_from_running)
          apply ((wpsimp simp: handle_call_def handle_send_def
                          wp: handle_invocation_schact_sane check_budget_restart_true
                              check_budget_restart_false
                 | strengthen ct_runnable_ct_not_blocked active_from_running)+)[1]
          apply fastforce
         apply ((wpsimp simp: handle_call_def handle_send_def
                         wp: handle_invocation_schact_sane check_budget_restart_true
                             check_budget_restart_false
                | strengthen ct_runnable_ct_not_blocked active_from_running)+)[1]
         apply fastforce
        apply (wpsimp simp: handle_call_def handle_send_def
                        wp: handle_invocation_schact_sane check_budget_restart_true
                            check_budget_restart_false
               | strengthen ct_runnable_ct_not_blocked active_from_running)+
    done
      apply (wpsimp wp: check_budget_restart_if_lift, fastforce)
     apply (wpsimp wp: check_budget_restart_if_lift, fastforce)
    apply (wpsimp wp: hoare_drop_imp, fastforce)
   apply (wpsimp wp: check_budget_restart_if_lift, fastforce)
  apply (wpsimp, fastforce)
  done

end

lemma postpone_ct_ready_if_schedulable_weak:
  "postpone scp \<lbrace>ct_ready_if_schedulable\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: valid_sched_wp hoare_drop_imp get_sc_obj_ref_wp)
  by (clarsimp simp: ct_ready_if_schedulable_def obj_at_def in_queue_2_def set_tcb_release_enqueue_upd_insert)

lemma postpone_ct_ready_if_schedulable:
  "\<lbrace>\<lambda>s. \<not> sc_tcb_sc_at (\<lambda>x. x = Some (cur_thread s)) scp s \<longrightarrow> ct_ready_if_schedulable s\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: valid_sched_wp get_sc_obj_ref_wp)
  apply (clarsimp simp: ct_ready_if_schedulable_def obj_at_def sc_at_kh_simps vs_all_heap_simps
                        in_queue_2_def set_tcb_release_enqueue_upd_insert
                 split: if_splits)
  done

crunches sched_context_resume
  for ct_ready_if_schedulable: "ct_ready_if_schedulable"
  (wp: crunch_wps)

lemma ct_ready_if_schedulable_def2:
  "ct_ready_if_schedulable s =
    (\<forall>t. t = cur_thread s
         \<longrightarrow> (active_sc_tcb_at t s \<and> pred_map runnable (tcb_sts_of s) t \<and> not_in_release_q t s)
         \<longrightarrow> budget_ready t s)"
  unfolding ct_ready_if_schedulable_def
  by clarsimp

lemma refill_unblock_check_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable\<rbrace>
   refill_unblock_check scptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (subst ct_ready_if_schedulable_def2)
   apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
  by (clarsimp simp: ct_ready_if_schedulable_def2)

lemma set_tcb_sc_None_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. tptr \<noteq> cur_thread s \<longrightarrow> ct_ready_if_schedulable s\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr None
   \<lbrace>\<lambda>rv. ct_ready_if_schedulable\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (clarsimp split: if_splits simp: ct_ready_if_schedulable_def vs_all_heap_simps)

lemma tcb_release_remove_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. if tptr = cur_thread s
        then active_sc_tcb_at tptr s \<and> pred_map runnable (tcb_sts_of s) tptr
             \<longrightarrow> budget_ready tptr s
        else ct_ready_if_schedulable s\<rbrace>
   tcb_release_remove tptr
   \<lbrace>\<lambda>rv. ct_ready_if_schedulable\<rbrace>"
  apply (wpsimp wp: valid_sched_wp)
  by (clarsimp split: if_splits
                simp: ct_ready_if_schedulable_def vs_all_heap_simps
                      not_in_release_q_2_def tcb_sched_act_set_simps)

lemma sched_context_donate_ct_ready_if_schedulable:
  "\<lbrace>ct_ready_if_schedulable and (\<lambda>s. tptr \<noteq> cur_thread s)\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding sched_context_donate_def
  apply (subst bind_assoc[symmetric])
  apply (rule_tac B = "\<lambda>_ s. tptr \<noteq> cur_thread s \<and> ct_ready_if_schedulable s" in hoare_seq_ext)
   apply (wpsimp wp: valid_sched_wp)
   apply (clarsimp simp: ct_ready_if_schedulable_def vs_all_heap_simps)
  apply (wpsimp wp: hoare_vcg_imp_lift' get_sc_obj_ref_wp)
  done

lemma sched_context_donate_ct_ready_if_schedulable':
  "\<lbrace>\<lambda>s. tptr \<noteq> cur_thread s \<and> sc_tcb_sc_at ((=) (Some (cur_thread s))) scptr s\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding sched_context_donate_def
  apply (subst bind_assoc[symmetric])
  apply (rule_tac B = "\<lambda>_ s. tptr \<noteq> cur_thread s \<and> bound_sc_tcb_at ((=) None) (cur_thread s)s" in hoare_seq_ext)
   apply (wpsimp wp: valid_sched_wp)
   apply (clarsimp simp: ct_ready_if_schedulable_def vs_all_heap_simps tcb_at_kh_simps)
  apply (wpsimp wp: hoare_vcg_imp_lift' get_sc_obj_ref_wp simp: tcb_at_kh_simps)
       apply (rule_tac Q="\<lambda>s. from_tptr = cur_thread s" in hoare_weaken_pre[rotated], assumption)
       apply (wpsimp wp: set_tcb_obj_ref_wp)
       apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
      apply (wpsimp wp: get_sc_obj_ref_wp)+
  by (auto simp: vs_all_heap_simps tcb_at_kh_simps sc_at_kh_simps obj_at_def)

lemma maybe_donate_sc_ct_ready_if_schedulable:
  "\<lbrace>ct_ready_if_schedulable and (\<lambda>s. tptr \<noteq> cur_thread s) \<rbrace>
   maybe_donate_sc tptr ntfnptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding maybe_donate_sc_def
  apply (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp sched_context_donate_ct_ready_if_schedulable
                    sched_context_resume_ct_ready_if_schedulable)
  done

 lemma set_thread_state_ct_ready_if_schedulable:
  "\<lbrace>ct_ready_if_schedulable and (\<lambda>s. tptr \<noteq> cur_thread s \<or> ~ runnable st)\<rbrace>
   set_thread_state tptr st
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding set_thread_state_def
  apply (wpsimp wp: set_object_wp)
  by (fastforce simp: ct_ready_if_schedulable_def vs_all_heap_simps dest!: get_tcb_SomeD)

lemma set_thread_state_ct_ready_if_schedulable_strong:
  "\<lbrace>\<lambda>s. if tptr = cur_thread s
        then runnable st
             \<longrightarrow> active_sc_tcb_at tptr s \<and> not_in_release_q tptr s
             \<longrightarrow> budget_ready tptr s
        else ct_ready_if_schedulable s\<rbrace>
   set_thread_state tptr st
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding set_thread_state_def
  apply (wpsimp wp: set_object_wp)
  by (fastforce simp: ct_ready_if_schedulable_def vs_all_heap_simps dest!: get_tcb_SomeD)

crunches cancel_ipc
  for ct_ready_if_schedulable[wp]: "ct_ready_if_schedulable"
  (wp: crunch_wps ignore: thread_set set_object update_sched_context)

crunches refill_unblock_check
  for valid_machine_time[wp]: valid_machine_time
  (wp: crunch_wps)

lemma update_waiting_ntfn_ct_ready_if_schedulable:
  "\<lbrace>ct_ready_if_schedulable
    and (\<lambda>s. queue \<noteq> [] \<longrightarrow> hd queue \<noteq> cur_thread s)\<rbrace>
   update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding update_waiting_ntfn_def if_cond_refill_unblock_check_def
  by (wpsimp wp: set_thread_state_ct_ready_if_schedulable gts_wp
                 maybe_donate_sc_ct_ready_if_schedulable maybeM_inv)

lemma send_signal_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable
    and ct_not_blocked_on_receive
    and ct_not_blocked_on_ntfn
    and invs\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding send_signal_def if_cond_refill_unblock_check_def
  apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable gts_wp hoare_vcg_all_lift
                    update_waiting_ntfn_ct_ready_if_schedulable get_tcb_obj_ref_wp
                    get_simple_ko_wp maybe_donate_sc_ct_ready_if_schedulable hoare_drop_imps)
  apply (intro allI conjI impI)
   apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)
   apply (case_tac "tcb_state y"; simp add: receive_blocked_def)
  apply (clarsimp simp: obj_at_def)
  apply (frule (4) st_in_waitingntfn'[OF _ _ invs_valid_objs invs_sym_refs hd_in_set])
  apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)
  done

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

lemma handle_interrupt_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable
    and ct_not_blocked_on_receive
    and ct_not_blocked_on_ntfn
    and invs\<rbrace>
   handle_interrupt y
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_interrupt_def
  by (wpsimp wp: hoare_vcg_if_lift2 hoare_drop_imp)

lemma sched_context_donate_ct_ready_if_schedulable_strong:
  "\<lbrace>\<lambda>s. if tptr = cur_thread s
         then (is_active_sc scptr s \<and> ct_in_state' active s \<and> ct_not_in_release_q s
               \<longrightarrow> is_refill_ready scptr s)
              \<and> (sc_tcb_sc_at (\<lambda>x. x \<noteq> Some (tptr)) scptr s)
         else ct_ready_if_schedulable s\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding sched_context_donate_def
  apply (subst bind_assoc[symmetric])
  apply (rule_tac B = "\<lambda>_ s. if (tptr = cur_thread s)
                             then (is_active_sc scptr s \<and> ct_in_state' active s \<and> ct_not_in_release_q s
                                   \<longrightarrow> is_refill_ready scptr s)
                             else (ct_ready_if_schedulable s)"
         in hoare_seq_ext)
   apply (wpsimp wp: valid_sched_wp)
   apply (clarsimp simp: ct_ready_if_schedulable_def vs_all_heap_simps runnable_eq_active)
  apply (wpsimp wp: hoare_vcg_imp_lift' get_sc_obj_ref_wp tcb_release_remove_in_release_q_neq
         | wps)+
  by (fastforce simp: obj_at_def sc_at_kh_simps vs_all_heap_simps)

lemma reply_push_ct_ready_if_schedulable:
  "\<lbrace>\<lambda>s. caller = cur_thread s\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  apply (wpsimp wp: sched_context_donate_ct_ready_if_schedulable)
      apply (rule_tac Q="\<lambda>_ s. caller = cur_thread s
                               \<and> ct_ready_if_schedulable s
                               \<and> bound_sc_tcb_at ((=) sc_caller) caller s
                               \<and> bound_sc_tcb_at ((=) sc_callee) callee s"
             in hoare_post_imp)
       apply (clarsimp simp: tcb_at_kh_simps pred_map_eq_normalise split: if_split)
       apply (fastforce simp: vs_all_heap_simps obj_at_def)
      apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong)
     apply (wpsimp wp: get_tcb_obj_ref_wp)+
  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps obj_at_def)
  done

lemma reply_unlink_tcb_fault_tcb_at_ct[wp]:
  "reply_unlink_tcb t r \<lbrace>\<lambda>s. fault_tcb_at P (cur_thread s) s\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (wpsimp | wps)+
  done

lemma send_ipc_ct_ready_if_schedulable_not_blocked_on_receive:
  "\<lbrace>fault_tcb_at bound thread
    and (\<lambda>s. thread = cur_thread s)
    and ct_not_blocked_on_receive
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   send_ipc True call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  apply wpsimp
       apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv)
      apply wpsimp
     apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv)
    apply (rename_tac queue)
    apply (case_tac queue; simp)
    apply (rename_tac dest list)
    apply (wpsimp wp: maybeM_inv)
               apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
              apply (rule_tac Q="\<lambda>_. ct_ready_if_schedulable and (\<lambda>s. dest \<noteq> cur_thread s)"
                     in hoare_post_imp, simp)
              apply (wpsimp wp: assert_inv)+
             apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
            apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
           apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
            apply (wpsimp wp: sched_context_donate_ct_ready_if_schedulable')
           apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
          apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
         apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
        apply (rule_tac Q="\<lambda>_ s. dest \<noteq> cur_thread s \<and> thread = cur_thread s \<and> fault_tcb_at bound thread s
                                 \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
               in hoare_post_imp)
         apply clarsimp
         apply (intro conjI; intro allI impI)
          apply (clarsimp simp: sc_at_kh_simps tcb_at_kh_simps vs_all_heap_simps obj_at_def)
         apply (clarsimp simp: vs_all_heap_simps obj_at_def tcb_at_kh_simps)
        apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
       apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
      apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
     apply (wpsimp wp: gts_wp)
    apply (rule_tac Q="\<lambda>_ s. ct_not_blocked_on_receive s \<and> thread = cur_thread s
                             \<and> fault_tcb_at bound thread s
                             \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
           in hoare_post_imp, clarsimp)
     apply (clarsimp simp: pred_map_eq_normalise tcb_at_kh_simps vs_all_heap_simps ct_in_state_def)
    apply (wpsimp wp: get_simple_ko_wp)+
  done

lemma send_ipc_ct_ready_if_schedulable_released_if_bound:
  "\<lbrace>fault_tcb_at bound thread
    and (\<lambda>s. thread = cur_thread s)
    and released_if_bound_sc_tcb_at thread
    and released_ipc_queues\<rbrace>
   send_ipc True call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def if_cond_refill_unblock_check_def
  apply wpsimp
       apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv)
      apply wpsimp
     apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv)
    apply (rename_tac queue)
    apply (case_tac queue; simp)
    apply (rename_tac dest list)
    apply (wpsimp wp: maybeM_inv)
               apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
              apply (rule_tac Q="\<lambda>_. ct_ready_if_schedulable and released_if_bound_sc_tcb_at dest"
                     in hoare_post_imp, simp)
               apply (clarsimp simp: vs_all_heap_simps)
              apply (wpsimp wp: assert_inv)+
             apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable
                               reply_push_released_if_bound_callee)
            apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv reply_push_ct_ready_if_schedulable)
           apply (wpsimp wp: sched_context_donate_ct_ready_if_schedulable' sched_context_donate_released_if_bound_callee)
           apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
          apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
         apply (wpsimp wp: get_tcb_obj_ref_wp thread_get_wp')
        apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at dest s \<and>
                                 released_if_bound_sc_tcb_at thread s \<and>
                                 thread = cur_thread s \<and> fault_tcb_at bound thread s"
               in hoare_post_imp)
         apply clarsimp
         apply (intro conjI; intro allI impI)
          apply (clarsimp simp: sc_at_kh_simps tcb_at_kh_simps vs_all_heap_simps obj_at_def)
         apply (clarsimp simp: vs_all_heap_simps obj_at_def tcb_at_kh_simps)
        apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
       apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
      apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
     apply (wpsimp wp: gts_wp)
    apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at thread s
                                \<and> thread = cur_thread s
                                \<and> fault_tcb_at bound thread s
                                \<and> released_ipc_queues s"
           in hoare_post_imp)
     apply clarsimp
     apply (subgoal_tac "blocked_on_recv_ntfn_tcb_at dest s")
      apply (frule (1) released_ipc_queues_blocked_on_recv_ntfn_E1, simp)
     apply (clarsimp simp: pred_map_eq_normalise tcb_at_kh_simps vs_all_heap_simps ct_in_state_def)
    apply (wpsimp wp: get_simple_ko_wp)+
  done

(*FIXME RT: move*)
lemma thread_set_fault_fault_tcb_at:
  "\<lbrace>K (P new_fault)\<rbrace>
   thread_set (tcb_fault_update (\<lambda>_. new_fault)) tptr
   \<lbrace>\<lambda>_. fault_tcb_at P tptr\<rbrace>"
  apply (wpsimp wp: thread_set_wp)
  by (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)

lemma handle_timeout_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. ct_not_blocked_on_receive s \<and> ct = cur_thread s
        \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s) \<and> bound_sc_tcb_at bound ct s\<rbrace>
   handle_timeout ct fault
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_timeout_def send_fault_ipc_def
  apply (wpsimp wp: send_ipc_ct_ready_if_schedulable_not_blocked_on_receive
                    thread_set_fault_fault_tcb_at thread_set_no_change_tcb_pred
              simp: ct_in_state_def
         | wps)+
  done

lemma end_timeslice_ct_ready_if_schedulable[wp]:
  "\<lbrace>cur_sc_tcb_are_bound
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and (\<lambda>s. active_sc_tcb_at (cur_thread s) s)
    and ct_not_blocked_on_receive
    and active_sc_valid_refills\<rbrace>
   end_timeslice x
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding end_timeslice_def
  apply wpsimp
        apply (wpsimp wp: postpone_ct_ready_if_schedulable)
       apply wpsimp+
  apply (intro conjI; intro allI impI)
   apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
  apply (intro conjI; intro allI impI)
   apply (clarsimp simp: obj_at_def ct_ready_if_schedulable_def budget_ready_def2 vs_all_heap_simps)
  apply (clarsimp simp: sc_at_kh_simps pred_map_eq_normalise heap_refs_inv_def2)
  done

crunches check_budget_restart, handle_recv, handle_yield
  for vmt[wp]: "(\<lambda>s. P (last_machine_time_of s) (cur_time s)) :: det_state \<Rightarrow> _"
  and pnt[wp]: "(\<lambda>s. P (last_machine_time_of s) (time_state_of s)) :: det_state \<Rightarrow> _"
  (wp: crunch_wps hoare_vcg_all_lift simp: crunch_simps)

crunches handle_interrupt
  for vmt[wp]: "(\<lambda>s. P (last_machine_time_of s) (cur_time s)) :: det_state \<Rightarrow> _"
  and pnt[wp]: "(\<lambda>s. P (last_machine_time_of s) (time_state_of s)) :: det_state \<Rightarrow> _"
  (ignore: syscall do_machine_op
       wp: syscall_valid crunch_wps do_machine_op_machine_state dxo_wp_weak mapME_x_wp_inv
           check_cap_inv filterM_preserved
     simp: crunch_simps)

crunches do_reply_transfer, restart, maybe_sched_context_unbind_tcb, maybe_sched_context_bind_tcb,
         set_priority, bind_notification
  for vmt[wp]: "(\<lambda>s. P (last_machine_time_of s) (cur_time s)) :: det_state \<Rightarrow> _"
  and pnt[wp]: "(\<lambda>s. P (last_machine_time_of s) (time_state_of s)) :: det_state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma install_tcb_frame_cap_valid_machine_time[wp]:
  "install_tcb_frame_cap target slot buffer \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: install_tcb_frame_cap_def
                  wp: check_cap_inv hoare_drop_imps)
  done

lemma invoke_tcb_valid_machine_time[wp]:
  "invoke_tcb tcb_inv \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (cases tcb_inv; simp)
          apply (wpsimp wp: mapM_x_wp_inv hoare_vcg_conj_lift hoare_drop_imps)+
    apply (rename_tac ntfnptr_opt)
    apply (case_tac ntfnptr_opt; clarsimp?)
     apply wpsimp+
  done

crunches cancel_badged_sends, invoke_irq_handler, invoke_domain, invoke_sched_context,
         invoke_sched_control_configure_flags
  for valid_machine_time[wp]: "valid_machine_time :: det_state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv filterM_preserved simp: crunch_simps)

lemma invoke_cnode_valid_machine_time[wp]:
  "invoke_cnode i \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: invoke_cnode_def)
  apply (cases i; clarsimp)
       apply (wpsimp wp: mapM_x_wp hoare_vcg_conj_lift hoare_drop_imps cap_revoke_preservation
              | intro conjI impI)+
  done

lemma perform_invocation_valid_machine_time[wp]:
  "perform_invocation block call can_donate iv \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (cases iv; clarsimp)
             apply (wpsimp wp: syscall_valid hoare_drop_imp hoare_drop_impE)+
  done

lemma handle_invocation_valid_machine_time[wp]:
  "handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid hoare_drop_imp hoare_drop_impE)
  done

crunches handle_call, check_budget_restart, handle_send
  for valid_machine_time[wp]: "valid_machine_time :: det_state \<Rightarrow> _"
  (ignore: do_machine_op wp: do_machine_op_machine_state)

lemma handle_event_valid_machine_time[wp]:
  "handle_event e \<lbrace>valid_machine_time :: det_state \<Rightarrow> _\<rbrace>"
  apply (case_tac e; (solves \<open>wpsimp\<close>)?; simp)
  subgoal for syscall
   apply (case_tac syscall; simp)
            apply (wpsimp wp: hoare_drop_imps)+
   done
  done

lemma charge_budget_ready_if_schedulable[wp]:
  "\<lbrace>cur_sc_chargeable
    and active_sc_valid_refills
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and current_time_bounded
    and (\<lambda>s. unat consumed + unat MAX_PERIOD \<le> unat max_time)
    and cur_sc_offset_ready 0\<rbrace>
   charge_budget consumed x
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  apply (wpsimp wp: assert_inv)
           apply (wpsimp wp: is_schedulable_wp)
          apply wpsimp
         apply wpsimp
        apply (rule_tac Q="\<lambda>_. cur_sc_chargeable and active_sc_valid_refills
                               and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))"
               in hoare_post_imp)
         apply (clarsimp simp: schedulable_def2 ct_ready_if_schedulable_def)
         apply (intro conjI allI impI)
           apply (fastforce elim: cur_sc_chargeable_when_ct_active_sc)
          apply (clarsimp simp: ct_in_state_def vs_all_heap_simps tcb_at_kh_simps is_blocked_thread_state_defs)
         apply (clarsimp simp: tcb_at_kh_simps)
        apply wpsimp
      apply (wpsimp wp: refill_budget_check_round_robin_active_sc_valid_refills
                        refill_budget_check_active_sc_valid_refills)
     apply (wpsimp wp: is_round_robin_wp)
    apply wpsimp
   apply wpsimp
  apply (fastforce simp: vs_all_heap_simps obj_at_def cur_sc_chargeable_def split: if_splits)
  done

lemma check_budget_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and cur_sc_chargeable and active_sc_valid_refills
    and cur_sc_active and current_time_bounded
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. unat (consumed_time s) + unat MAX_PERIOD \<le> unat max_time)\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply wpsimp
  apply (clarsimp simp: vs_all_heap_simps refill_ready_no_overflow_def)
  done

end

crunches handle_no_fault, reply_from_kernel
  for cur_sc_more_than_ready[wp]: cur_sc_more_than_ready

lemma
  if_sporadic_cur_sc_assert_refill_unblock_check_cur_sc_more_than_ready[wp]:
  "if_sporadic_cur_sc_assert_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_more_than_ready s\<rbrace>"
  and if_sporadic_cur_sc_test_refill_unblock_check_cur_sc_more_than_ready[wp]:
  "if_sporadic_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_more_than_ready s\<rbrace>"
  and if_sporadic_active_cur_sc_test_refill_unblock_check_cur_sc_more_than_ready[wp]:
  "if_sporadic_active_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_more_than_ready s\<rbrace>"
  unfolding if_cond_refill_unblock_check_def maybeM_def by wpsimp+

lemma restart_thread_if_no_fault_cur_sc_more_than_ready[wp]:
  "restart_thread_if_no_fault tp \<lbrace> cur_sc_more_than_ready \<rbrace>"
  unfolding restart_thread_if_no_fault_def by wpsimp

lemma cancel_all_signals_cur_sc_more_than_ready[wp]:
  "cancel_all_signals ntfnptr \<lbrace> cur_sc_more_than_ready \<rbrace>"
  unfolding cancel_all_signals_def by (wpsimp wp: mapM_x_wp' hoare_drop_imp)

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

crunches test_possible_switch_to, maybe_donate_sc
  for cur_sc_more_than_ready[wp]: "cur_sc_more_than_ready"
  (wp: crunch_wps simp: crunch_simps)

lemma restart_cur_sc_more_than_ready[wp]:
  "restart thread \<lbrace>cur_sc_more_than_ready\<rbrace>"
  unfolding restart_def if_cond_refill_unblock_check_def
  by (wpsimp wp: gts_wp hoare_vcg_all_lift hoare_drop_imps)

lemma update_waiting_ntfn_cur_sc_more_than_ready[wp]:
  "update_waiting_ntfn ntfnptr queue bound_tcb sc_ptr badge \<lbrace>cur_sc_more_than_ready\<rbrace>"
  unfolding update_waiting_ntfn_def if_cond_refill_unblock_check_def
  by (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps)

lemma send_ipc_cur_sc_more_than_ready[wp]:
  "send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding send_ipc_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)+

crunches handle_timeout
  for cur_sc_more_than_ready[wp]: "cur_sc_more_than_ready :: det_state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma do_reply_transfer_cur_sc_more_than_ready[wp]:
  "do_reply_transfer sender reply grant \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding do_reply_transfer_def
  apply (wpsimp wp: get_tcb_obj_ref_wp)
  by (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)+

lemma handle_fault_cur_sc_more_than_ready[wp]:
  "handle_fault thread ex \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_fault_def
  by (wpsimp wp: syscall_valid simp: send_fault_ipc_def)

lemma send_signal_cur_sc_more_than_ready[wp]:
  "send_signal ntfnptr badge
   \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding send_signal_def if_cond_refill_unblock_check_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)+

lemma sched_context_zero_refill_max_cur_sc_more_than_ready[wp]:
  "sched_context_zero_refill_max scp \<lbrace>cur_sc_more_than_ready\<rbrace>"
  apply (clarsimp simp: sched_context_zero_refill_max_def set_refills_def)
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: cur_sc_more_than_ready_def vs_all_heap_simps active_sc_def obj_at_def)
  done

lemma sched_context_bind_tcb_cur_sc_more_than_ready[wp]:
  "sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>cur_sc_more_than_ready\<rbrace>"
  unfolding sched_context_bind_tcb_def by wpsimp

crunches suspend, bind_notification, maybe_sched_context_unbind_tcb,
         maybe_sched_context_bind_tcb
  for cur_sc_more_than_ready[wp]: cur_sc_more_than_ready
  (wp: crunch_wps hoare_vcg_if_lift2 simp: crunch_simps ignore: update_sched_context)

lemma sched_context_yield_to_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. sc_ptr \<noteq> cur_sc s)\<rbrace>
   sched_context_yield_to sc_ptr args
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding sched_context_yield_to_def
  by (wpsimp wp: assert_inv hoare_drop_imp)

lemma update_sched_context_cur_sc_more_than_ready:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. sc_ptr \<noteq> cur_sc s \<or> consumed_time s = 0)\<rbrace>
   update_sched_context sc_ptr f
   \<lbrace>\<lambda>yb. cur_sc_more_than_ready\<rbrace>"
  unfolding refill_update_def
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: cur_sc_more_than_ready_def vs_all_heap_simps)

lemma maybe_add_empty_tail_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. sc_ptr \<noteq> cur_sc s \<or> consumed_time s = 0)\<rbrace>
   maybe_add_empty_tail sc_ptr
   \<lbrace>\<lambda>yb. cur_sc_more_than_ready\<rbrace>"
  unfolding maybe_add_empty_tail_def refill_add_tail_def get_refills_def
  apply (wpsimp wp: update_sched_context_cur_sc_more_than_ready is_round_robin_wp set_refills_wp)
  done

lemma refill_update_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. sc_ptr \<noteq> cur_sc s \<or> consumed_time s = 0)\<rbrace>
   refill_update sc_ptr new_period new_budget new_max_refills
   \<lbrace>\<lambda>yb. cur_sc_more_than_ready\<rbrace>"
  unfolding refill_update_def set_refills_def refill_add_tail_def update_refill_hd_def get_refills_def
            update_refill_tl_def
  apply (wpsimp wp: update_sched_context_cur_sc_more_than_ready hoare_vcg_imp_lift'
                    hoare_vcg_disj_lift get_refills_wp hoare_vcg_all_lift)
  done

lemma refill_new_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and (\<lambda>s. sc_ptr \<noteq> cur_sc s \<or> consumed_time s = 0)\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>yb. cur_sc_more_than_ready\<rbrace>"
  unfolding refill_new_def
  by (wpsimp wp: update_sched_context_cur_sc_more_than_ready)

lemma invoke_sched_context_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready
    and valid_sched_context_inv iv
    and (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. sctcb = Some (cur_thread s)) (cur_sc s) s)\<rbrace>
   invoke_sched_context iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding invoke_sched_context_def
  apply (cases iv; wpsimp)
  by (clarsimp simp: sc_at_kh_simps vs_all_heap_simps)

lemma commit_time_zero_consumed_time[wp]:
  "\<lbrace>\<top>\<rbrace> commit_time \<lbrace>\<lambda>_ s. consumed_time s = 0\<rbrace>"
  unfolding commit_time_def
  by wpsimp

lemma invoke_sched_control_configure_flags_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready
    and (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. sctcb = Some (cur_thread s)) (cur_sc s) s)\<rbrace>
   invoke_sched_control_configure_flags iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding invoke_sched_control_configure_flags_def
  apply (cases iv; simp)
  apply wpsimp
         apply (rule_tac Q="\<lambda>_ s. consumed_time s = 0" in hoare_strengthen_post[rotated])
          apply clarsimp
         apply wpsimp+
       apply (rule_tac Q="\<lambda>_. cur_sc_more_than_ready" in hoare_strengthen_post[rotated])
        apply (clarsimp split: if_split)
       apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_disj_lift)+
  by (clarsimp simp: sc_at_kh_simps vs_all_heap_simps obj_at_def)

crunches update_work_units, reset_work_units
  for is_cur_domain_expired[wp]: "\<lambda>s. P (is_cur_domain_expired s)"
  (simp: is_cur_domain_expired_def)

lemma preemption_point_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s :: det_state. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>, -"
  apply (clarsimp simp: preemption_point_def)
  apply (clarsimp simp: validE_R_def)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply (clarsimp simp: validE_R_def[symmetric])
  apply (rule OR_choiceE_E_weak_wp)
  apply (rule alternativeE_R_wp[where P=Q and P'=Q for Q, simplified pred_conj_def, simplified]
         ; (solves wpsimp)?)
  apply (clarsimp simp: validE_R_def)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<top>\<top>" in hoare_vcg_seqE)
   apply (rule hoare_seq_ext_skipE, wpsimp)
   apply wpsimp
   apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  apply wpsimp
  done

lemma preemption_point_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_ s :: det_state. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)\<rbrace>"
  (is "valid ?pre _ _")
  apply (clarsimp simp: preemption_point_def)
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply (rule valid_validE)
  apply (rule OR_choiceE_weak_wp)
  apply (rule alternative_valid; (solves wpsimp)?)
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp)+
  apply wpsimp
  done

lemma cur_sc_active_offset_ready_and_sufficient_implies_cur_sc_more_than_ready:
  "(cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
   \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
   \<Longrightarrow> cur_sc_more_than_ready s"
  apply (clarsimp simp: cur_sc_more_than_ready_def)
  done

lemma cur_sc_active_implies_cur_sc_offset_ready_rewrite:
  "(cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
   = (cur_sc s \<noteq> idle_sc_ptr
      \<longrightarrow> cur_sc_active s
      \<longrightarrow> pred_map (refill_ready_no_overflow_sc (consumed_time s) (cur_time s)) (sc_refill_cfgs_of s) (cur_sc s))"
  by fastforce

lemma cur_sc_active_implies_cur_sc_offset_sufficient_rewrite:
  "(cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
   = (cur_sc s \<noteq> idle_sc_ptr
      \<longrightarrow> cur_sc_active s
      \<longrightarrow> is_refill_sufficient (consumed_time s) (cur_sc s) s)"
  by fastforce

lemma reset_untyped_cap_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   reset_untyped_cap slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (clarsimp simp: reset_untyped_cap_def)
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp)
  apply clarsimp
  apply (intro conjI impI; (solves wpsimp)?)
    apply (rule hoare_seq_ext_skipE)
     apply (subst cur_sc_active_implies_cur_sc_offset_ready_rewrite)+
     apply (rule hoare_validE_conj)
      apply (rule valid_validE)
      apply (rule hoare_weaken_pre)
       apply (rule hoare_vcg_imp_lift')
        apply wpsimp
       apply wpsimp
      apply fastforce
     apply wpsimp
    apply wpsimp
   apply (rule hoare_seq_ext_skipE)
    apply (subst cur_sc_active_implies_cur_sc_offset_ready_rewrite)+
    apply (rule hoare_validE_conj)
     apply (rule valid_validE)
     apply (rule hoare_weaken_pre)
      apply (rule hoare_vcg_imp_lift')
       apply wpsimp
      apply wpsimp
     apply fastforce
    apply wpsimp
   apply wpsimp
  apply (rule hoare_seq_ext_skipE)
   apply (subst cur_sc_active_implies_cur_sc_offset_ready_rewrite)+
   apply (rule hoare_validE_conj)
    apply (rule valid_validE)
    apply (rule hoare_weaken_pre)
     apply (rule hoare_vcg_imp_lift')
      apply wpsimp
     apply wpsimp
    apply fastforce
   apply wpsimp
  apply wpsimp
  apply (rule_tac Q="?pre" in hoare_weaken_preE[rotated], simp)
  apply (rule valid_validE)
  apply (rule hoare_strengthen_post)
   apply (rule mapME_x_wp_inv)
   apply (rule validE_valid)
   apply (rule hoare_seq_ext_skipE, wpsimp)+
   apply wpsimp+
  done

lemma reset_untyped_cap_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   reset_untyped_cap slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>, -")
  supply if_split[split del]
  apply (clarsimp simp: reset_untyped_cap_def)
  apply (clarsimp simp: validE_R_def)
  apply (rule hoare_seq_ext_skipE)
   apply wpsimp
  apply (split if_splits)
  apply (intro conjI)
   apply wpsimp
  apply clarsimp
  apply (rule_tac B="\<lambda>_ s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated])
   apply (subst cur_sc_active_implies_cur_sc_offset_sufficient_rewrite)+
   apply (rule hoare_weaken_preE)
    apply (rule hoare_vcg_imp_liftE)
     apply wpsimp
    apply wpsimp
   apply fastforce
  apply (wpsimp wp: mapME_x_wp_inv')
  done

lemma invoke_untyped_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   invoke_untyped iv
   \<lbrace>\<lambda>_ s  :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: invoke_untyped_def)
  apply (cases iv; simp)
  apply (clarsimp simp: validE_R_def whenE_def)
  apply (intro conjI impI)
   apply (rule validE_valid)
   apply (rule hoare_seq_ext_skipE, wpsimp)
   apply (rule valid_validE)
   apply (subst cur_sc_active_implies_cur_sc_offset_ready_rewrite)+
   apply (wpsimp wp: mapM_x_wp_inv)+
      apply (rule hoare_vcg_imp_lift')
       apply wpsimp
      apply wpsimp
     apply wpsimp
    apply wpsimp
   apply fastforce
  apply (subst cur_sc_active_implies_cur_sc_offset_ready_rewrite)+
  apply (wpsimp wp: mapM_x_wp_inv)+
     apply (rule hoare_vcg_imp_lift')
      apply wpsimp+
  done

lemma invoke_untyped_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   invoke_untyped iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  apply (clarsimp simp: invoke_untyped_def)
  apply (cases iv; simp)
  apply (clarsimp simp: validE_R_def whenE_def)
  apply (intro conjI impI)
  apply (rule hoare_seq_ext_skipE, wpsimp)
   apply (wpsimp wp: mapM_x_wp_inv)
      apply (subst cur_sc_active_implies_cur_sc_offset_sufficient_rewrite)+
       apply (rule hoare_vcg_imp_lift')
       apply wpsimp
      apply wpsimp
     apply wpsimp
    apply wpsimp
   apply fastforce
  apply (subst cur_sc_active_implies_cur_sc_offset_sufficient_rewrite)+
  apply (wpsimp wp: mapM_x_wp_inv)+
     apply (rule hoare_vcg_imp_lift')
      apply wpsimp
     apply wpsimp
    apply wpsimp
   apply wpsimp
  apply fastforce
  done

lemma invoke_untyped_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s
        \<and> valid_machine_time s\<rbrace>
   invoke_untyped iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>, -"
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)"
              and E="\<top>\<top>"
               in hoare_post_impErr)
    apply wpsimp
   apply wpsimp
   apply (clarsimp simp: cur_sc_more_than_ready_def)
  apply simp
  done

crunches cancel_badged_sends, restart
  for cur_sc_more_than_ready[wp]: cur_sc_more_than_ready
  (wp: filterM_preserved)

crunches update_restart_pc, cancel_ipc,
         sched_context_unbind_all_tcbs, set_thread_state, test_possible_switch_to
  for cur_sc_offset_ready[wp]: "\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s"
  and cur_sc_offset_sufficient[wp]: "\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s"
  (wp: mapM_x_wp)

lemma refill_unblock_check_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. scp \<noteq> cur_sc s \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   refill_unblock_check scp
   \<lbrace>\<lambda>_ s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  unfolding refill_unblock_check_defs merge_refill_def
  apply (wpsimp wp: whileLoop_wp' update_sched_context_wp get_refills_wp)
        apply (clarsimp simp: vs_all_heap_simps obj_at_def refill_ready_no_overflow_def
                       split: if_split_asm)
       apply (wpsimp wp: update_sched_context_wp get_refills_wp)+
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)
  done

lemma refill_unblock_check_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. scp \<noteq> cur_sc s \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   refill_unblock_check scp
   \<lbrace>\<lambda>_ s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding refill_unblock_check_defs
  apply (rule_tac Q="\<lambda>_ s. scp \<noteq> cur_sc s \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)"
         in hoare_strengthen_post)
  apply (wpsimp wp: whileLoop_wp' update_sched_context_wp get_refills_wp)
        apply (clarsimp simp: vs_all_heap_simps split: if_split_asm)
       apply (wpsimp wp: update_sched_context_wp get_refills_wp)+
  apply (clarsimp simp: vs_all_heap_simps obj_at_def)+
  done

lemma
  if_sporadic_cur_sc_assert_refill_unblock_check_cur_sc_offset_ready[wp]:
  "if_sporadic_cur_sc_assert_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and if_sporadic_cur_sc_assert_refill_unblock_check_cur_sc_offset_sufficient[wp]:
  "if_sporadic_cur_sc_assert_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  and if_sporadic_cur_sc_test_refill_unblock_check_cur_sc_offset_ready[wp]:
  "if_sporadic_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and if_sporadic_cur_sc_test_refill_unblock_check_cur_sc_offset_sufficient[wp]:
  "if_sporadic_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  and if_sporadic_active_cur_sc_test_refill_unblock_check_cur_sc_offset_ready[wp]:
  "if_sporadic_active_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and if_sporadic_active_cur_sc_test_refill_unblock_check_cur_sc_offset_sufficient[wp]:
  "if_sporadic_active_cur_sc_test_refill_unblock_check scopt
   \<lbrace>\<lambda> s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding if_cond_refill_unblock_check_def maybeM_def by wpsimp+

lemma
  restart_thread_if_no_fault_cur_sc_offset_ready[wp]:
  "restart_thread_if_no_fault t \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and restart_thread_if_no_fault_cur_sc_offset_sufficient[wp]:
  "restart_thread_if_no_fault t \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding restart_thread_if_no_fault_def by wpsimp+

lemma
  cancel_all_ipc_cur_sc_offset_ready[wp]:
  "cancel_all_ipc ep \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and cancel_all_ipc_offset_sufficient[wp]:
  "cancel_all_ipc ep \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding cancel_all_ipc_def by (wpsimp wp: mapM_x_wp' gts_wp get_simple_ko_wp)+

lemma
  cancel_all_signals_cur_sc_offset_ready[wp]:
  "cancel_all_signals np \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and cancel_all_signals_offset_sufficient[wp]:
  "cancel_all_signals np \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding cancel_all_signals_def by (wpsimp wp: mapM_x_wp' gts_wp get_simple_ko_wp)+

lemma
  restart_cur_sc_offset_ready[wp]:
  "restart tp \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  and restart_offset_sufficient[wp]:
  "restart tp \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding restart_def by (wpsimp wp: | wp (once) hoare_drop_imp)+

lemma fast_finalise_cur_sc_offset_ready[wp]:
  "fast_finalise cap final
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
  apply (wpsimp wp: gts_wp get_simple_ko_wp)
  done

lemma fast_finalise_cur_sc_offset_sufficient[wp]:
  "fast_finalise cap final
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
  apply (wpsimp wp: gts_wp get_simple_ko_wp)
  done

crunches deleting_irq_handler, bind_notification
  for cur_sc_offset_ready[wp]: "\<lambda>s. cur_sc_active s
                                    \<longrightarrow> cur_sc_offset_ready (consumed_time s) (s::det_state)"
  and cur_sc_offset_sufficient[wp]: "\<lambda>s. cur_sc_active s
                                          \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) (s::det_state)"
  (wp: mapM_x_wp thread_get_wp gts_wp simp: crunch_simps get_tcb_obj_ref_def)

lemma sched_context_zero_refill_max_cur_sc_offset_ready[wp]:
  "sched_context_zero_refill_max scp
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: sched_context_zero_refill_max_def set_refills_def)
  apply (wpsimp wp: update_sched_context_wp)
  apply (fastforce simp: vs_all_heap_simps active_sc_def obj_at_def)
  done

lemma sched_context_zero_refill_max_cur_sc_offset_sufficient[wp]:
  "sched_context_zero_refill_max scp
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: sched_context_zero_refill_max_def set_refills_def)
  apply (wpsimp wp: update_sched_context_wp)
  apply (fastforce simp: vs_all_heap_simps active_sc_def obj_at_def)
  done

lemma finalise_cap_cur_sc_offset_ready[wp]:
  "finalise_cap cap final
   \<lbrace>\<lambda>s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
  apply (wpsimp wp: gts_wp get_simple_ko_wp)
  done

lemma finalise_cap_cur_sc_offset_sufficient[wp]:
  "finalise_cap cap final
   \<lbrace>\<lambda>s  :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
  apply (wpsimp wp: gts_wp get_simple_ko_wp)
  done

lemma rec_del_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   rec_del slot
   \<lbrace>\<lambda>_ s  :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (rule validE_valid)
  apply (rule_tac Q="\<lambda>_. ?pre" and E="\<lambda>_. ?pre" in hoare_post_impErr)
    apply (rule rec_del_preservationE, wpsimp+)
  done

lemma rec_del_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   rec_del slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>, -")
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_. ?pre" and E="\<top>\<top>" in hoare_post_impErr)
    apply (rule rec_del_preservationE, wpsimp+)
  done

lemma cap_revoke_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   cap_revoke slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>")
  apply (rule validE_valid)
  apply (rule_tac Q="\<lambda>_. ?pre" and E="\<lambda>_. ?pre" in hoare_post_impErr)
    apply (rule cap_revoke_preservationE)
     apply (clarsimp simp: cap_delete_def)
     apply (wpsimp wp: rec_del_cur_sc_active_implies_cur_sc_offset_ready)+
  done

lemma cap_revoke_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   cap_revoke slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>, -")
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_. ?pre" and E="\<top>\<top>" in hoare_post_impErr)
    apply (rule cap_revoke_preservationE)
     apply (clarsimp simp: cap_delete_def)
     apply wpsimp+
  done

lemma install_tcb_frame_cap_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: install_tcb_frame_cap_def cap_delete_def)
  apply (cases buffer; clarsimp)
   apply wpsimp
  apply (rule validE_valid)
  apply (rule hoare_seq_ext_skipE, wpsimp simp: cap_delete_def)
  apply (rule hoare_seq_ext_skipE, wpsimp simp: cap_delete_def)
  apply (rule hoare_seq_ext_skipE, wpsimp wp: check_cap_inv)
  apply wpsimp
  done

lemma install_tcb_frame_cap_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>_ s  :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  apply (clarsimp simp: install_tcb_frame_cap_def cap_delete_def)
  apply (cases buffer; clarsimp)
   apply wpsimp
  apply (clarsimp simp: validE_R_def)
  apply (rule hoare_seq_ext_skipE, wpsimp simp: cap_delete_def)
  apply (rule hoare_seq_ext_skipE, wpsimp simp: cap_delete_def)
  apply (rule hoare_seq_ext_skipE, wpsimp wp: check_cap_inv)
  apply wpsimp
  done

lemma install_tcb_cap_cur_sc_active_implies_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   install_tcb_cap target slot n buffer
   \<lbrace>\<lambda>_ s  :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: install_tcb_cap_def)
  apply (wpsimp simp: cap_delete_def
                  wp: check_cap_inv)
  done

lemma install_tcb_cap_cur_sc_active_implies_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   install_tcb_cap target slot n buffer
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  apply (clarsimp simp: install_tcb_cap_def)
  apply (wpsimp simp: cap_delete_def
                  wp: check_cap_inv)
  done

lemma maybe_sched_context_unbind_tcb_cur_sc_offset_ready[wp]:
  "maybe_sched_context_unbind_tcb target
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: maybe_sched_context_unbind_tcb_def get_tcb_obj_ref_def
                        sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (clarsimp simp: maybeM_def)
  apply (case_tac sc_ptr_opt; clarsimp)
  apply (clarsimp simp: maybe_sched_context_unbind_tcb_def get_tcb_obj_ref_def
                        sched_context_unbind_tcb_def)
  apply wpsimp
  done

lemma maybe_sched_context_unbind_tcb_cur_sc_offset_sufficient[wp]:
  "maybe_sched_context_unbind_tcb target
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: maybe_sched_context_unbind_tcb_def get_tcb_obj_ref_def
                        sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (clarsimp simp: maybeM_def)
  apply (case_tac sc_ptr_opt; clarsimp)
  apply (clarsimp simp: maybe_sched_context_unbind_tcb_def get_tcb_obj_ref_def
                        sched_context_unbind_tcb_def)
  apply wpsimp
  done

lemma maybe_sched_context_bind_tcb_cur_sc_offset_ready[wp]:
  "maybe_sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: maybe_sched_context_bind_tcb_def sched_context_bind_tcb_def)
  apply wpsimp
  done

lemma maybe_sched_context_bind_tcb_cur_sc_offset_sufficient[wp]:
  "maybe_sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: maybe_sched_context_bind_tcb_def sched_context_bind_tcb_def)
  apply wpsimp
  done

lemma invoke_tcb_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  supply if_split [split del]
  apply (cases iv; (solves \<open>wpsimp wp: mapM_x_wp_inv\<close>)?, clarsimp?)
   apply (rule validE_valid)
   apply (rule hoare_seq_ext_skipE, wpsimp)+
   apply wpsimp
  apply (rename_tac ntfnpt_opt)
  apply (case_tac ntfnpt_opt; wpsimp)
  done

lemma invoke_tcb_cur_sc_offset_sufficient[wp]:
  "\<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  supply if_split [split del]
  apply (cases iv; (solves \<open>wpsimp wp: mapM_x_wp_inv\<close>)?, clarsimp?)
  apply (clarsimp simp: validE_R_def)
   apply (rule hoare_seq_ext_skipE, wpsimp)+
   apply wpsimp
  apply (rename_tac ntfnpt_opt)
  apply (case_tac ntfnpt_opt; wpsimp)
  done

lemma invoke_tcb_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s
        \<and> valid_machine_time s\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>, -"
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)"
              and E="\<top>\<top>"
               in hoare_post_impErr)
    apply wpsimp
   apply wpsimp
   apply (clarsimp simp: cur_sc_more_than_ready_def)
  apply simp
  done

crunches cancel_badged_sends
  for cur_sc_offset_ready[wp]: "\<lambda>s :: det_state. cur_sc_active s
                                                 \<longrightarrow> cur_sc_offset_ready (consumed_time s) s"
  and cur_sc_offset_sufficient[wp]:
         "\<lambda>s :: det_state. cur_sc_active s
                           \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s"
  (wp: filterM_preserved simp: crunch_simps)

lemma invoke_cnode_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   invoke_cnode iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (clarsimp simp: invoke_cnode_def cap_delete_def)
  apply (cases iv; clarsimp)
       apply (wpsimp simp: cap_delete_def | intro conjI impI)+
  done

lemma invoke_cnode_cur_sc_more_than_sufficient[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)\<rbrace>
   invoke_cnode iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>, -"
  apply (clarsimp simp: invoke_cnode_def cap_delete_def)
  apply (cases iv; clarsimp)
       apply (wpsimp simp: cap_delete_def | intro conjI impI)+
  done

lemma invoke_cnode_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s
        \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   invoke_cnode iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_more_than_ready s\<rbrace>, -"
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)"
              and E="\<top>\<top>"
               in hoare_post_impErr)
    apply wpsimp
   apply wpsimp
   apply (clarsimp simp: cur_sc_more_than_ready_def)
  apply simp
  done

lemma invoke_irq_handler_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   invoke_irq_handler iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>"
  apply (cases iv; wpsimp)
  done

lemma invoke_irq_handler_cur_sc_more_than_sufficient[wp]:
  "invoke_irq_handler iv
   \<lbrace>\<lambda>s :: det_state. cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  apply (cases iv; wpsimp)
  done

lemma invoke_irq_handler_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
        \<and> cur_sc_offset_sufficient (consumed_time s) s \<and> valid_machine_time s\<rbrace>
   invoke_irq_handler iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)"
               in hoare_strengthen_post)
   apply wpsimp
  apply (clarsimp simp: cur_sc_more_than_ready_def)
  done

 lemma perform_invocation_cur_sc_more_than_ready[wp]:
  "\<lbrace>(\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)
    and valid_invocation iv and cur_sc_active and valid_machine_time
    and (\<lambda>s. sc_tcb_sc_at (\<lambda>sctcb. sctcb = Some (cur_thread s)) (cur_sc s) s)\<rbrace>
   perform_invocation block call can_donate iv
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>, -"
  apply (cases iv; wpsimp; clarsimp simp: cur_sc_more_than_ready_def)
  done

lemma check_budget_true':
  "\<lbrace>P\<rbrace> check_budget \<lbrace>\<lambda>rv s. rv \<longrightarrow> P s \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding check_budget_def
  apply (wpsimp wp: gts_wp hoare_vcg_all_lift)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  done

lemma check_budget_restart_true':
  "\<lbrace>P\<rbrace> check_budget_restart \<lbrace>\<lambda>rv s. rv \<longrightarrow> P s \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>"
  unfolding check_budget_restart_def check_budget_def
  apply (wpsimp wp: gts_wp hoare_vcg_all_lift)
  apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
  done

 lemma handle_invocation_cur_sc_more_than_ready[wp]:
  "\<lbrace>(\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)
    and valid_machine_time and invs and schact_is_rct and cur_sc_active\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>, -"
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid simp: cap_cap_slot_fold sc_at_kh_simps
         | wp (once) hoare_drop_imps)+
  apply (clarsimp simp: cur_sc_more_than_ready_def cong: conj_cong)
  apply (fastforce dest: sym_ref_tcb_sc invs_sym_refs invs_strengthen_cur_sc_tcb_are_bound
                   simp: vs_all_heap_simps)
  done

crunches complete_signal, do_nbrecv_failed_transfer, maybe_return_sc
  for cur_sc_more_than_ready[wp]: "cur_sc_more_than_ready :: det_state \<Rightarrow> _"
  (wp: crunch_wps hoare_vcg_all_lift simp: crunch_simps ignore: set_object update_sched_context)

lemma receive_ipc_cur_sc_more_than_ready[wp]:
  "receive_ipc thread cap is_blocking reply_cap \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding receive_ipc_def
  apply wpsimp
  apply (wpsimp wp: hoare_drop_imp)
  apply (wpsimp wp: hoare_vcg_imp_lift')
  apply (rule_tac Q="\<lambda>_. cur_sc_more_than_ready" in hoare_strengthen_post)
  apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)+
  done

lemma receive_signal_cur_sc_more_than_ready[wp]:
  "receive_signal thread cap is_blocking \<lbrace>cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding receive_signal_def by (wpsimp wp: hoare_drop_imp)

crunches handle_recv
  for cur_sc_more_than_ready[wp]: "cur_sc_more_than_ready :: det_state \<Rightarrow> _"
  (wp: crunch_wps hoare_vcg_all_lift simp: crunch_simps ignore: set_object)

lemma charge_budget_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<top>\<rbrace> charge_budget consumed canTimeout \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding charge_budget_def
  by (rule_tac Q="\<lambda>_ s. consumed_time s = 0" in hoare_strengthen_post;
      wpsimp wp: hoare_drop_imp)

lemma check_budget_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>
   check_budget
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_def
  apply wpsimp
  apply (clarsimp simp: cur_sc_more_than_ready_def)
  by (clarsimp simp: vs_all_heap_simps obj_at_def refill_sufficient_def)

lemma check_budget_restart_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding check_budget_restart_def
  by (wpsimp wp: hoare_drop_imp)

lemma check_budget_restart_true_cur_sc_more_than_ready:
  "\<lbrace>\<lambda>s. cur_sc_offset_ready (consumed_time s) s\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv s. rv \<longrightarrow> cur_sc_more_than_ready (s :: det_state)\<rbrace>"
  unfolding check_budget_restart_def
  by (wpsimp wp: hoare_drop_imp)

lemmas check_budget_restart_true_schact_is_rct[wp] = check_budget_restart_true[where P=schact_is_rct]

lemma handle_yield_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<top>\<rbrace> handle_yield \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_yield_def
  by wpsimp

lemma handle_interrupt_cur_sc_more_than_ready[wp]:
  "\<lbrace>cur_sc_more_than_ready and invs\<rbrace>
   handle_interrupt y
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_more_than_ready s\<rbrace>"
  unfolding handle_interrupt_def get_irq_state_def get_irq_slot_def
  by (wpsimp wp: get_cap_wp send_signal_cur_sc_more_than_ready)

method handle_event_cur_sc_more_than_ready_syscall
  = (subst validE_R_def
     , rule_tac B="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                         \<and> cur_sc_active s
                         \<and> valid_machine_time s
                         \<and> invs s
                         \<and> schact_is_rct s"
             in hoare_vcg_seqE[rotated]
     , wpsimp
     , rule_tac B="\<lambda>rv s. (rv \<longrightarrow> ((cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                                    \<and> cur_sc_offset_sufficient (consumed_time s) s
                                    \<and> cur_sc_active s
                                    \<and> valid_machine_time s
                                    \<and> invs s
                                    \<and> schact_is_rct s))
                          \<and> (\<not> rv \<longrightarrow> cur_sc_more_than_ready s)"
             in hoare_vcg_seqE[rotated]
     , subst liftE_validE
     , intro hoare_vcg_conj_lift_pre_fix
     , rule hoare_strengthen_post
     , rule check_budget_restart_true'
     , simp
     , wpsimp wp: check_budget_restart_cur_sc_more_than_ready hoare_drop_imps
     , clarsimp simp: whenE_def
     , intro conjI impI
     ; wpsimp simp: cur_sc_more_than_ready_def)

lemma handle_event_cur_sc_more_than_ready[wp]:
  "\<lbrace>(\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s) and cur_sc_active
    and valid_machine_time
    and invs
    and schact_is_rct\<rbrace>
   handle_event e
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>, -"
  apply (cases e; (solves \<open>wpsimp\<close>)?; simp)

  subgoal for syscall
    by (case_tac syscall; simp add: handle_call_def handle_send_def
        ; handle_event_cur_sc_more_than_ready_syscall)

   apply (subst validE_R_def)
   apply (subst liftE_validE)
   apply (rule hoare_seq_ext_skip, wpsimp)
   apply (rule_tac B="\<lambda>_ s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                            \<and> cur_sc_active s
                            \<and> valid_machine_time s
                            \<and> invs s
                            \<and> schact_is_rct s"
                in hoare_seq_ext[rotated])
    apply wpsimp
   apply (rule_tac B="\<lambda>_. cur_sc_more_than_ready and invs" in hoare_seq_ext[rotated])
    apply wpsimp
   apply wpsimp
  apply wpsimp
  apply (clarsimp simp: cur_sc_more_than_ready_def)
  done

lemma perform_invocation_cur_sc_offset_ready[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   perform_invocation blocking calling can_donate iv
   -, \<lbrace>\<lambda>rv s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) (s::det_state)\<rbrace>"
  apply (cases iv; wpsimp)
  done

lemma handle_invocation_cur_sc_offset_readyE_E[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   -, \<lbrace>\<lambda>rv s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) (s::det_state)\<rbrace>"
  apply (clarsimp simp: handle_invocation_def)
  apply (wpsimp wp: syscall_valid)
  by (rule hoare_drop_imps) wpsimp+

lemma handle_event_cur_sc_offset_readyE_E[wp]:
  "\<lbrace>\<lambda>s. (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s) \<and> valid_machine_time s\<rbrace>
   handle_event e
   -, \<lbrace>\<lambda>rv s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) (s::det_state)\<rbrace>"
  apply (case_tac e; (solves \<open>wpsimp\<close>)?; simp)
  apply (rename_tac syscall)
  apply (case_tac syscall; simp add: handle_send_def handle_call_def; (solves \<open>wpsimp\<close>)?)
       by (wpsimp wp: check_budget_restart_true)+

end

lemma heap_refs_inv_sc_tcb:
  "\<lbrakk>heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s); kheap s scp = Some (SchedContext sc n);
    sc_tcb sc = Some tp\<rbrakk>
   \<Longrightarrow> \<exists>tcb. kheap s tp = Some (TCB tcb) \<and> tcb_sched_context tcb = Some scp"
  by (fastforce simp: vs_all_heap_simps heap_refs_inv_def  heap_refs_retract_at_def
                      heap_refs_retract_def)

lemma sched_context_resume_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s \<and> sc_ptr \<noteq> idle_sc_ptr
        \<and> (if sc_ptr = cur_sc s
           then (cur_sc_active s \<longrightarrow> is_refill_ready (cur_sc s) s
                                     \<and> is_refill_sufficient 0 (cur_sc s) s)
           else heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_ s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: sched_context_resume_def is_schedulable_def thread_get_def postpone_def
                        get_sc_obj_ref_def)
  apply (wpsimp wp: tcb_release_enqueue_wp tcb_sched_action_wp)
  apply (clarsimp simp: vs_all_heap_simps obj_at_def in_queue_2_def)
  apply (intro conjI impI allI; fastforce?)
  apply (case_tac "sc_ptr = cur_sc s"; (solves \<open>simp\<close>)?)
  apply (prop_tac "y \<noteq> t")
   apply (metis (no_types, hide_lams) kernel_object.simps(2) option.simps(1)
                                      heap_refs_inv_sc_tcb)
  apply (prop_tac "t \<notin> set (release_queue s)", blast)
  apply (simp add: set_tcb_release_enqueue_upd_insert)
  done

lemma sched_context_resume_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s \<and> sc_ptr \<noteq> idle_sc_ptr
        \<and> (if sc_ptr = cur_sc s
           then (cur_sc_active s
                 \<longrightarrow> (consumed_time s \<noteq> 0
                      \<longrightarrow> (is_refill_ready (cur_sc s) s \<and> is_refill_sufficient 0 (cur_sc s) s)))
           else heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (rule hoare_weaken_pre)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply (wpsimp wp: sched_context_resume_cur_sc_not_in_release_q)
   apply wpsimp
  apply (fastforce split: if_splits)
  done

lemma refill_unblock_check_cur_sc_is_refill_ready[wp]:
  "\<lbrace>\<lambda>s. is_refill_ready (cur_sc s) s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_ s. is_refill_ready (cur_sc s) s\<rbrace>"
  by (rule hoare_lift_concrete_Pf[where f=cur_sc]; wpsimp)

lemma refill_unblock_check_cur_sc_is_refill_sufficient[wp]:
  "unat MIN_BUDGET + unat usage \<le> unat max_time \<Longrightarrow>
   \<lbrace>\<lambda>s. is_refill_sufficient usage (cur_sc s) s \<and> valid_refills (cur_sc s) s\<rbrace>
   refill_unblock_check sc_ptr
   \<lbrace>\<lambda>_ s. is_refill_sufficient usage (cur_sc s) s\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (rule hoare_lift_Pf2[where f=cur_sc])
    apply (wpsimp wp: refill_unblock_check_is_refill_sufficient)
   apply wpsimp
  apply fastforce
  done

crunches refill_unblock_check, refill_update, refill_new
  for valid_machine_time[wp]: "valid_machine_time"
  (wp: crunch_wps)

context DetSchedSchedule_AI begin

crunches tcb_sched_action, tcb_release_remove, reschedule_required
  for ntfn_at_ppred[wp]: "\<lambda>s. ntfn_at_ppred proj P ntfn_ptr s"
  (wp: crunch_wps)

lemma sched_context_donate_ntfn_at_ppred[wp]:
  "sched_context_donate a tcb_ptr \<lbrace>\<lambda>s. ntfn_at_ppred proj P ntfn_ptr s\<rbrace>"
  apply (clarsimp simp: sched_context_donate_def test_reschedule_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (rule hoare_when_cases, simp)
   apply (rule hoare_seq_ext_skip, wpsimp wp: update_sched_context_wp set_tcb_obj_ref_wp)+
    apply (fastforce simp: ntfn_at_ppred_def obj_at_def)
   apply (rule hoare_seq_ext_skip, wpsimp wp: update_sched_context_wp set_tcb_obj_ref_wp)+
   apply wpsimp
  apply (wpsimp wp: set_tcb_obj_ref_wp update_sched_context_wp)
  apply (fastforce simp: ntfn_at_ppred_def obj_at_def)
  done

lemma ex_nonz_cap_to_ntfn_sc:
  "\<lbrakk>ntfn_at_ppred ntfn_sc (\<lambda>f. f = Some sc_ptr) ntfn_ptr s; invs s;
    sc_at sc_ptr s\<rbrakk>
   \<Longrightarrow> ex_nonz_cap_to sc_ptr s"
  apply (clarsimp simp: obj_at_def is_sc_obj_def)
  apply (rule if_live_then_nonz_capD2)
    apply fastforce
   apply (clarsimp simp: obj_at_def is_sc_obj_def)
   apply fastforce
  apply (rename_tac ko n, case_tac ko; clarsimp)
  apply (clarsimp simp: live_def live_sc_def ntfn_at_ppred_def obj_at_def)
  apply (frule invs_sym_refs)
  apply (prop_tac "(sc_ptr, NTFNSchedContext) \<in> state_refs_of s ntfn_ptr")
   apply (clarsimp simp: state_refs_of_def)
  apply (prop_tac "(ntfn_ptr, SCNtfn) \<in> state_refs_of s sc_ptr")
   apply (clarsimp simp: sym_refs_def)
   apply fastforce
  apply (fastforce simp: state_refs_of_def)
  done

lemma maybe_donate_sc_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> invs s
        \<and> (cur_sc_active s \<and> cur_sc s \<noteq> idle_sc_ptr
           \<longrightarrow> is_refill_ready (cur_sc s) s \<and> is_refill_sufficient 0 (cur_sc s) s)
        \<and> not_in_release_q tcb_ptr s \<and> ex_nonz_cap_to tcb_ptr s\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_ s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  supply refill_unblock_check_cur_sc_budget_sufficient[wp del]
  apply (clarsimp simp: maybe_donate_sc_def maybeM_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases; (solves \<open>simp\<close>)?)
  apply (rule hoare_seq_ext[OF _ get_sk_obj_ref_sp], rename_tac sc_ptr)
  apply (clarsimp simp: maybeM_def get_sc_obj_ref_def)
  apply (case_tac sc_ptr; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_when_cases; (solves \<open>simp\<close>)?)
  apply (rule_tac B="\<lambda>_ s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
                           \<and> sc_not_in_release_q (cur_sc s) s
                           \<and> (cur_sc_active s \<and> cur_sc s  \<noteq> idle_sc_ptr
                              \<longrightarrow> is_refill_ready (cur_sc s) s \<and> is_refill_sufficient 0 (cur_sc s) s)
                           \<and> not_in_release_q tcb_ptr s
                           \<and> ntfn_at_ppred ntfn_sc (\<lambda>f. f = Some a) ntfn_ptr s
                           \<and> invs s
                           \<and> ex_nonz_cap_to tcb_ptr s"
               in hoare_seq_ext[rotated])
   apply ((wpsimp wp: sched_context_donate_sc_not_in_release_q sched_context_donate_invs
           | wps)+)[1]
   apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps is_tcb_def is_sc_obj_def)
   apply (intro conjI impI)
    apply (fastforce intro: ex_nonz_cap_to_ntfn_sc valid_objs_valid_sched_context_size
                      simp: obj_at_def is_sc_obj_def)
   apply (fastforce intro: valid_objs_valid_sched_context_size)
  apply (wpsimp wp: sched_context_resume_cur_sc_not_in_release_q)+
  apply (rename_tac ntfn_sc_ptr sc s)
  apply (subgoal_tac "ntfn_sc_ptr \<noteq> idle_sc_ptr")
   apply fastforce
  apply (frule_tac scp=ntfn_sc_ptr in ex_nonz_cap_to_not_idle_sc_ptr)
   apply (rule ex_nonz_cap_to_ntfn_sc)
     apply fastforce
    apply fastforce
   apply (clarsimp simp: ntfn_at_ppred_def obj_at_def)
   apply (rename_tac ntfn)
   apply (prop_tac "valid_ntfn ntfn s")
    apply (frule invs_valid_objs)
    apply (fastforce simp: valid_objs_def valid_obj_def)
   apply (clarsimp simp: valid_ntfn_def obj_at_def )
  apply fastforce
  done

end

lemma cur_sc_in_release_q_imp_zero_consumed_lift:
   "\<lbrakk>f \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>;
     \<And>P. \<lbrace>\<lambda>s. P (consumed_time s)\<rbrace> f \<lbrace>\<lambda>_ s. P (consumed_time s)\<rbrace>\<rbrakk>
   \<Longrightarrow> f \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule_tac Q="\<lambda>s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                         \<or> consumed_time s = 0"
               in hoare_weaken_pre[rotated], blast)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
  apply (rule hoare_vcg_disj_lift)
   apply wpsimp
  by fast

lemma cur_sc_more_than_ready_imp_cur_sc_ready_and_sufficient[elim]:
  "\<lbrakk>cur_sc_more_than_ready s; consumed_time s \<noteq> 0; cur_sc_active s; current_time_bounded s;
    cur_sc s \<noteq> idle_sc_ptr\<rbrakk>
   \<Longrightarrow> is_refill_ready (cur_sc s) s \<and> is_refill_sufficient 0 (cur_sc s) s"
  apply (clarsimp simp: cur_sc_more_than_ready_def is_refill_ready_def is_refill_sufficient_def
                        refill_ready_def vs_all_heap_simps refill_sufficient_def
                        refill_ready_no_overflow_def refill_capacity_def)
  apply (intro conjI)
   apply (simp add: word_le_nat_alt)
   apply (prop_tac "unat (cur_time s + kernelWCET_ticks)
                    = unat (cur_time s) + unat kernelWCET_ticks")
    using cur_time_no_overflow unat_plus_simple apply blast
   apply linarith
  apply (clarsimp split: if_splits)
  by (meson linorder_not_less order_trans_rules(23) plus_minus_no_overflow_ab word_diff_ls'(4)
            word_le_less_eq)

context DetSchedSchedule_AI begin

lemma maybe_donate_sc_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
        \<and> cur_sc_in_release_q_imp_zero_consumed s
        \<and> cur_sc_more_than_ready s
        \<and> not_in_release_q tcb_ptr s \<and> current_time_bounded s \<and> ex_nonz_cap_to tcb_ptr s
        \<and> invs s\<rbrace>
   maybe_donate_sc tcb_ptr ntfn_ptr
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule hoare_weaken_pre)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply (wpsimp wp: maybe_donate_sc_cur_sc_not_in_release_q)+
  apply (rule cur_sc_more_than_ready_imp_cur_sc_ready_and_sufficient; blast?)
  done

lemma update_waiting_ntfn_cur_sc_in_release_q_imp_zero_consumed:
  "ntfn_obj ntfn = WaitingNtfn queue \<Longrightarrow>
  \<lbrace>\<lambda>s. ko_at (Notification ntfn) ntfnptr s
       \<and> st_tcb_at ((=) (BlockedOnNotification ntfnptr)) (hd queue) s
       \<and> heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
       \<and> cur_sc_in_release_q_imp_zero_consumed s
       \<and> cur_sc_more_than_ready s
       \<and> tcb_at (hd queue) s \<and> not_in_release_q (hd queue) s \<and> current_time_bounded s
       \<and> ex_nonz_cap_to ntfnptr s \<and> invs s\<rbrace>
   update_waiting_ntfn ntfnptr queue (ntfn_bound_tcb ntfn) (ntfn_sc ntfn) badge
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  supply if_split[split del] if_cong[cong]
  apply (clarsimp simp: update_waiting_ntfn_def)
  apply (wpsimp wp: set_thread_state_invs set_ntfn_minor_invs Arch.set_simple_ko_ioports
                    maybe_donate_sc_cur_sc_in_release_q_imp_zero_consumed
                    refill_unblock_check_active_sc_valid_refills maybeM_inv
              simp: invs_def valid_state_def valid_pspace_def)
  apply (prop_tac "valid_ntfn ntfn s")
   apply (fastforce simp: valid_objs_def valid_obj_def obj_at_def)
  apply (cases queue; clarsimp)
  apply (intro conjI)
       apply (clarsimp simp: pred_tcb_at_def obj_at_def)
       apply (erule (1) if_live_then_nonz_capD2)
       apply (fastforce simp: live_def
                       split: thread_state.splits)
      apply (clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def)
     apply (clarsimp simp: replies_blocked_def pred_tcb_at_def obj_at_def)
    apply (fastforce intro: update_waiting_notification_sym_refs_helper
                      simp: obj_at_def valid_ntfn_def)
   apply (clarsimp elim!: fault_tcbs_valid_states_not_fault_tcb_states
                          pred_tcb_weakenE
                    simp: pred_neg_def)
   apply (case_tac "itcb_state tcb"; clarsimp)
  apply (fastforce simp: valid_ntfn_def pred_tcb_at_def obj_at_def valid_bound_obj_def is_tcb_def
                  split: list.splits option.splits)
  done

lemma cancel_ipc_heap_refs_retract_sc_tcbs_of[wp]:
  "cancel_ipc tptr \<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding cancel_ipc_def
  by (wpsimp wp: gts_wp')

lemma send_signal_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. invs s
        \<and> valid_release_q s
        \<and> cur_sc_in_release_q_imp_zero_consumed s
        \<and> cur_sc_more_than_ready s
        \<and> current_time_bounded s
        \<and> ex_nonz_cap_to ntfnptr s\<rbrace>
   send_signal ntfnptr badge
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding send_signal_def
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp], rename_tac ntfn)
  apply (case_tac "ntfn_obj ntfn"; clarsimp?, (solves \<open>wpsimp\<close> )?)
    apply (case_tac "ntfn_bound_tcb ntfn"; clarsimp?, (solves \<open>wpsimp\<close>)?)

   apply (find_goal \<open>match premises in \<open>_ = WaitingNtfn _ \<close> \<Rightarrow> \<open>-\<close>\<close>)
   apply (rename_tac queue)
   apply (wpsimp wp: update_waiting_ntfn_cur_sc_in_release_q_imp_zero_consumed)
   apply (prop_tac "queue \<noteq> []")
    apply (drule invs_valid_objs)
    apply (simp add: valid_objs_def valid_obj_def valid_ntfn_def obj_at_def)
    apply (drule_tac A="dom (kheap s)" and x=ntfnptr in bspec)
     apply (clarsimp simp: obj_at_def)
    apply (simp add: valid_objs_def valid_obj_def valid_ntfn_def)
   apply (intro conjI)
     apply (frule invs_sym_refs)
     apply (frule invs_valid_objs)
     apply (clarsimp simp: obj_at_def)
     apply (frule_tac q=queue in st_in_waitingntfn; blast?)
     apply (prop_tac "hd queue \<in> set queue", simp)
     apply (drule_tac x="hd queue" in bspec, simp)
     apply (clarsimp simp: pred_tcb_at_def obj_at_def)
    apply (drule invs_valid_objs)
    apply (frule_tac ntfnptr=ntfnptr and ntfn=ntfn in waiting_ntfn_list_tcb_at; blast?)
    apply (clarsimp simp: valid_objs_def valid_obj_def valid_ntfn_def)
   apply (clarsimp simp: obj_at_def valid_ntfn_def)
   apply (frule st_in_waitingntfn; blast?, fastforce?)
   apply (clarsimp simp: valid_sched_def valid_release_q_def in_release_q_def)
   apply (drule_tac x="hd queue" in bspec, simp)
   apply (fastforce simp: pred_tcb_at_def obj_at_def vs_all_heap_simps)

  apply (rename_tac ntfn_tcb_ptr)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (wpsimp wp: maybe_donate_sc_cur_sc_in_release_q_imp_zero_consumed
                    sts_cancel_ipc_Running_invs cancel_ipc_invs_st_tcb_at cancel_ipc_cap_to
                    cancel_ipc_simple_except_awaiting_reply)
  apply (clarsimp simp: pred_tcb_at_def obj_at_def is_tcb_def cong: conj_cong)
  apply (intro conjI; fastforce?)
   apply (erule valid_release_q_not_in_release_q_not_runnable)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def receive_blocked_def
                  split: thread_state.splits)
  apply (rule if_live_then_nonz_capD2; fastforce?)
  apply (clarsimp simp: live_def)
  apply (case_tac "tcb_state tcb"; clarsimp simp: receive_blocked_def)
  done

lemma handle_interrupt_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. invs s \<and> valid_release_q s
        \<and> cur_sc_in_release_q_imp_zero_consumed s
        \<and> cur_sc_more_than_ready s
        \<and> current_time_bounded s\<rbrace>
   handle_interrupt irq
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding handle_interrupt_def get_irq_state_def get_irq_slot_def
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (case_tac st; (clarsimp simp: bind_assoc)?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (wpsimp wp: send_signal_cur_sc_in_release_q_imp_zero_consumed get_cap_wp)
  apply (clarsimp simp: cte_wp_at_def ex_nonz_cap_to_def)
  apply (case_tac cap; clarsimp?)
  by fastforce

end

lemma update_timestamp_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. ct_not_in_release_q s \<and> cur_sc_chargeable s \<and> valid_release_q s\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding update_time_stamp_def cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule_tac Q="\<lambda>_ s. ct_not_in_release_q s \<and> cur_sc_chargeable s \<and> valid_release_q s"
               in hoare_strengthen_post[rotated])
   apply (clarsimp simp: vs_all_heap_simps cur_sc_chargeable_def)
   apply (prop_tac "t = cur_thread s")
    apply (fastforce simp: valid_release_q_def in_queue_2_def vs_all_heap_simps)
   apply fastforce
  apply wpsimp
  done

lemma delete_objects_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "delete_objects ptr bits \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding delete_objects_def
  apply (wpsimp simp: detype_def cur_sc_in_release_q_imp_zero_consumed_def)
  apply (clarsimp simp: vs_all_heap_simps split: if_splits)
  done

lemma preemption_point_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. ct_not_in_release_q s \<and> cur_sc_chargeable s \<and> valid_release_q s\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_vcg_all_lift
                    update_timestamp_cur_sc_in_release_q_imp_zero_consumed
         | wp (once) hoare_drop_imps)+
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def cur_sc_chargeable_def)
  apply (prop_tac "t = cur_thread s")
   apply (fastforce simp: valid_release_q_def in_queue_2_def vs_all_heap_simps)+
  done

lemma preemption_point_ct_not_in_release_q[wp]:
  "preemption_point \<lbrace>ct_not_in_release_q\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

lemma preemption_point_cur_sc_chargeable[wp]:
  "preemption_point \<lbrace>cur_sc_chargeable\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

lemma preemption_point_cur_sc_not_in_release_q[wp]:
  "preemption_point \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: preemption_point_def)
  apply (wpsimp wp: OR_choiceE_weak_wp hoare_drop_imps)
  done

lemma delete_objects_cur_sc_not_in_release_q[wp]:
  "delete_objects ptr bits \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  unfolding delete_objects_def
  apply (wpsimp simp: detype_def cur_sc_chargeable_def pred_neg_def)
  apply (clarsimp simp: vs_all_heap_simps split: if_splits)
  done

lemma (in DetSchedSchedule_AI) reset_untyped_cap_cur_sc_not_in_release_q[wp]:
  "reset_untyped_cap src_slot \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: reset_untyped_cap_def)
  apply (wpsimp wp: mapME_x_wp_inv hoare_drop_imps)
  done

(* FIXME: prove this in the locales *)
lemma tcbs_of_kh_foldr_opt:
  "tcbs_of_kh (foldr (\<lambda>p kh a. if a = p then f a else kh a) ps m)
   = (\<lambda>x. if x \<in> set ps then case_option None tcb_of (f x) else tcbs_of_kh m x)"
  by (induct ps) (auto simp: tcb_heap.upd)

(* FIXME RT: generalise upd and pred_map_upds lemmas in locales *)
lemma pred_map_upd_stronger:
  "pred_map P (\<lambda>r. if Q r then f r else tcbs_of_kh m r)
   = (\<lambda>x. if Q x then \<exists>y. f x = Some y \<and> P y else pred_map P (tcbs_of_kh m) x)"
  by (auto simp: pred_map_simps)

lemma retype_region_not_pred_map_tcbs_of:
  assumes "\<forall>d. \<not> P (proj (default_tcb d))"
  shows "retype_region ptr numObjects o_bits obj dev
         \<lbrace>\<lambda>s. \<not> pred_map P (map_project proj (tcbs_of s)) t\<rbrace>"
  unfolding retype_region_def pred_map_compose'
  apply (wpsimp)
  apply (clarsimp simp: tcbs_of_kh_foldr_opt map_set_in)
  using assms
  apply (cases obj; clarsimp simp: default_object_def tcb_heap.all_simps
                                   pred_map_upd_stronger split: if_splits)
  done

lemmas retype_region_no_pred_map_tcb_scps_of[wp] =
  retype_region_not_pred_map_tcbs_of[where proj=tcb_sched_context
                                           , unfolded tcb_scps_of_tcbs_def[symmetric]]

lemma retype_region_not_pred_map_tcb_scps_of[wp]:
  "retype_region ptr numObjects o_bits obj dev \<lbrace>\<lambda>s. \<not> pred_map_eq (Some scp) (tcb_scps_of s) t\<rbrace>"
  apply (simp only: pred_map_eq_def)
  apply (wpsimp simp: default_tcb_def)
  done

crunches retype_region
  for consumed_time[wp]: "\<lambda>s. P (consumed_time s)"

lemma retype_region_cur_sc_not_in_release_q[wp]:
  "retype_region ptr numObjects o_bits type dev \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (rule hoare_vcg_all_lift)
  apply (wpsimp wp: hoare_vcg_imp_lift')
    apply ((wpsimp | wps)+)[1]
   apply (wpsimp wp: hoare_vcg_imp_lift')+
  done

lemma retype_region_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "retype_region ptr numObjects o_bits type dev \<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule hoare_vcg_all_lift)
  apply (wpsimp wp: hoare_vcg_imp_lift')
    apply ((wpsimp | wps)+)[1]
   apply (wpsimp wp: hoare_vcg_imp_lift')+
  done

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

lemma invoke_untyped_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>
   invoke_untyped ui
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. sc_not_in_release_q (cur_sc s) s" in hoare_strengthen_post[rotated])
   apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (wpsimp simp: invoke_untyped_def
                  wp: mapM_x_wp_inv)
  done

lemma reply_push_cur_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q sc_ptr s \<and> not_in_release_q callee s\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q sc_ptr s\<rbrace>"
  apply (clarsimp simp: reply_push_def bind_sc_reply_def when_def)
  apply (rule hoare_seq_ext_skip, wpsimp wp: get_simple_ko_wp)+
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip, wpsimp wp: get_simple_ko_wp)+
  apply (wpsimp wp: sched_context_donate_sc_not_in_release_q get_simple_ko_wp)
  done

lemma send_ipc_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q sc_ptr s \<and> valid_release_q s \<and> not_in_release_q thread s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) thread\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q sc_ptr s\<rbrace>"
  unfolding send_ipc_def
  supply if_split[split del]
  apply (rule hoare_seq_ext[OF _ get_simple_ko_inv])
  apply (case_tac "\<forall>dest queue. ep \<noteq> RecvEP (dest # queue)"; clarsimp)
   apply (case_tac "\<exists>q. ep = RecvEP q", elim exE, (case_tac q; simp))
   apply (case_tac ep; simp; wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp]
         , simp add: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply ((case_tac recv_state; clarsimp), rename_tac ep_ptr reply_opt)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule_tac B="\<lambda>_ s. sc_not_in_release_q sc_ptr s
                           \<and> valid_release_q s
                           \<and> not_in_release_q thread s
                           \<and> (ep_ptr \<noteq> None \<longrightarrow> st_tcb_at ((=) Inactive) dest s)
                           \<and> not_in_release_q dest s
                           \<and> thread \<noteq> dest"
               in hoare_seq_ext[rotated])
   apply (clarsimp simp: maybeM_def)
   apply (case_tac ep_ptr; clarsimp?)
    apply wpsimp
    apply (fastforce simp: valid_release_q_def vs_all_heap_simps in_release_q_def
                           receive_blocked_def)
   apply (wpsimp wp: reply_unlink_tcb.valid_sched_lemmas simp: tcb_sts.pred_map_simps)
   apply (fastforce simp: valid_release_q_def vs_all_heap_simps in_release_q_def
                          receive_blocked_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (rule hoare_if)
    apply (rule hoare_if)
     apply (wpsimp wp: reply_push_st_tcb_at_Inactive reply_push_cur_sc_not_in_release_q)
    apply (wpsimp wp: set_thread_state_valid_release_q hoare_vcg_const_imp_lift sts_obj_at_neq
                simp: pred_tcb_at_def)
   apply (clarsimp simp: when_def; (solves \<open>wpsimp\<close>)?)
   apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
   apply (rule hoare_seq_ext[OF _ gsc_sp])
   apply (wpsimp wp: sched_context_donate_sc_not_in_release_q)
  apply wpsimp
  done

lemma send_ipc_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s \<and> valid_release_q s \<and> not_in_release_q thread s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) thread\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (rule hoare_weaken_pre)
  by (wpsimp wp: send_ipc_sc_not_in_release_q | wps)+

lemma handle_timeout_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s \<and> valid_release_q s \<and> not_in_release_q tptr s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) tptr\<rbrace>
   handle_timeout tptr ex
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  unfolding handle_timeout_def send_fault_ipc_def
  by (wpsimp wp: send_ipc_cur_sc_not_in_release_q)

lemma send_ipc_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s \<and> valid_release_q s \<and> not_in_release_q thread s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) thread\<rbrace>
   send_ipc block call badge can_grant can_grant_reply can_donate thread epptr
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule hoare_weaken_pre)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply (rule send_ipc_cur_sc_not_in_release_q)
   apply wpsimp+
  done

lemma handle_timeout_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s \<and> valid_release_q s \<and> not_in_release_q tptr s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) tptr\<rbrace>
   handle_timeout tptr ex
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding handle_timeout_def send_fault_ipc_def
  by (wpsimp wp: send_ipc_cur_sc_in_release_q_imp_zero_consumed)

lemma reply_remove_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q sc_ptr s \<and> not_in_release_q caller s\<rbrace>
   reply_remove caller r
   \<lbrace>\<lambda>_ s. sc_not_in_release_q sc_ptr s\<rbrace>"
  unfolding reply_remove_def
  by (wpsimp wp: sched_context_donate_sc_not_in_release_q get_simple_ko_wp | intro conjI impI)+

lemma reply_remove_cur_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s \<and> not_in_release_q caller s\<rbrace>
   reply_remove caller r
   \<lbrace>\<lambda>_ s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (rule hoare_weaken_pre)
  by (wpsimp | wps)+

lemma reply_remove_valid_release_q:
  "\<lbrace>\<lambda>s. valid_release_q s \<and> ipc_queued_thread caller s\<rbrace>
   reply_remove caller r
   \<lbrace>\<lambda>_ s :: det_state. valid_release_q s\<rbrace>"
  supply if_split[split del]
  apply (simp add: reply_remove_def valid_sched_def)
  apply (repeat 3 \<open>rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, simp?\<close>)
  apply (wpsimp wp: reply_unlink_tcb_valid_release_q)
  apply (prop_tac "not_in_release_q caller s")
   apply (clarsimp simp: valid_release_q_def in_release_q_def vs_all_heap_simps)
   apply (drule_tac x=caller in bspec, simp)
   apply (case_tac "tcb_state y"; clarsimp?)
  by fast

lemma postpone_cur_sc_not_in_release_q_other:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> cur_sc s \<noteq> scp \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>
   postpone scp
   \<lbrace>\<lambda>_ s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  unfolding postpone_def
  apply (wpsimp wp: tcb_release_enqueue_wp tcb_sched_action_wp simp: get_sc_obj_ref_def obj_at_def)
  apply (clarsimp simp: heap_refs_inv_defs vs_all_heap_simps)
  apply (prop_tac "y \<noteq> t")
   apply (fastforce simp: heap_refs_inv_defs vs_all_heap_simps)
  apply (simp add: set_tcb_release_enqueue_upd_insert in_queue_2_def)
  done

lemma reply_remove_heap_refs_retract_sc_tcbs[wp]:
  "reply_remove caller reply \<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding reply_remove_def
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>, (simp only: K_bind_def)?)+
  apply (rule hoare_seq_ext_skip; (solves \<open>wpsimp\<close>)?)
  apply (case_tac r_sc_opt, wpsimp, simp)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext[OF _ gsc_sp]
         , clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule hoare_seq_ext_skip, wpsimp)
  by (wpsimp wp: sched_context_donate_sc_tcbs_of_retract)

lemma reply_remove_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s \<and> not_in_release_q caller s\<rbrace>
   reply_remove caller reply
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule hoare_weaken_pre)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply wpsimp
   apply wpsimp
  by (clarsimp simp: in_release_q_def not_in_release_q_def)

lemma strengthen_cur_sc_offset_ready:
  "cur_sc_offset_ready (consumed_time s) s \<Longrightarrow> cur_sc s \<noteq> idle_sc_ptr
   \<Longrightarrow> current_time_bounded s \<Longrightarrow> is_refill_ready (cur_sc s) s"
  unfolding is_refill_ready_def cur_sc_offset_ready_def
  apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps refill_ready_def)
  apply (subst word_le_nat_alt)
  apply (erule order_trans[OF le_add1, OF order_trans])
  apply (subst unat_add_lem', overflow_hammer)
   apply (clarsimp simp: current_time_bounded_def, clarsimp)
  done

lemma strengthen_cur_sc_offset_sufficient:
  "cur_sc_offset_sufficient (consumed_time s) s \<Longrightarrow> cur_sc s \<noteq> idle_sc_ptr
   \<Longrightarrow> is_refill_sufficient 0 (cur_sc s) s"
  unfolding is_refill_ready_def cur_sc_offset_ready_def
  apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps refill_ready_def)
  apply (clarsimp simp: refill_capacity_def refill_sufficient_def split: if_splits)
  apply (erule order_trans)
  apply (overflow_hammer, fastforce)
  done

lemma do_reply_transfer_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
        \<and> valid_release_q s \<and> active_sc_valid_refills s \<and> cur_sc_active s
        \<and> cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s
        \<and> current_time_bounded s
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (simp add: do_reply_transfer_def maybeM_def)
  apply (rule hoare_seq_ext[OF _ grt_sp])
  apply (case_tac recv_opt, wpsimp, clarsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rename_tac receiver state)
  apply (case_tac "\<forall>r'. state \<noteq> BlockedOnReply r'", solves \<open>wpsimp\<close>,
         clarsimp simp: if_cond_refill_unblock_check_def)
  apply (rule hoare_seq_ext[OF _ assert_sp])
  apply (rule_tac S="r'=reply" in hoare_gen_asm''
         ; clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule_tac B="\<lambda>_ s. sc_not_in_release_q (cur_sc s) s
                           \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
                           \<and> valid_release_q s \<and> active_sc_valid_refills s \<and> cur_sc_active s
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
                           \<and> current_time_bounded s
                           \<and> not_in_release_q receiver s \<and> cur_sc s \<noteq> idle_sc_ptr"
           in hoare_seq_ext[rotated])
   apply (wpsimp wp: reply_remove_tcb_scps_of_retract reply_remove_valid_release_q
                     reply_remove_heap_refs_retract_sc_tcbs
               simp: heap_refs_inv_def)
   apply (fastforce simp: vs_all_heap_simps in_release_q_def valid_sched_def valid_release_q_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: refill_unblock_check_valid_release_q
                     refill_unblock_check_active_sc_valid_refills)
   apply (rule conjI; clarsimp simp: tcb_at_kh_simps(3) obj_at_def)
   apply (clarsimp simp: heap_refs_inv_def2 pred_map_eq)
  apply (rule hoare_seq_ext[OF _ thread_get_inv])
  apply (rule hoare_seq_ext_skip)
   apply (case_tac fault; clarsimp?)
    apply (wpsimp wp: set_thread_state_valid_release_q)
   apply (rule hoare_seq_ext_skip, wpsimp wp: thread_set_no_change_tcb_sched_context)+
   apply ((wpsimp wp: set_thread_state_valid_release_q)+)[1]
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rename_tac sc_opt')
  apply (case_tac "runnable state \<longrightarrow> sc_opt' = None"
         ; clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
   apply wpsimp
  apply (rename_tac scp)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_if)
   apply (wpsimp wp: handle_timeout_cur_sc_not_in_release_q)
   apply (clarsimp simp: vs_all_heap_simps receive_blocked_def) \<comment> \<open>kheap s receiver = Some (TCB y)\<close>
   apply (case_tac "tcb_state y"; clarsimp?)
  apply (wpsimp wp: postpone_cur_sc_not_in_release_q_other)
  apply (frule strengthen_cur_sc_offset_sufficient[rotated])
  apply fastforce
  apply (frule strengthen_cur_sc_offset_ready[rotated], fastforce+)
  apply (clarsimp simp: obj_at_def vs_all_heap_simps refill_ready_no_overflow_def
                        refill_sufficient_def refill_ready_def refill_capacity_def
                 split: if_splits)
  done

lemma do_reply_transfer_consumed_time[wp]:
  "do_reply_transfer sender reply grant \<lbrace>\<lambda>s :: det_state. consumed_time s = 0\<rbrace>"
  apply (simp add: do_reply_transfer_def maybeM_def)
  apply (rule hoare_seq_ext[OF _ grt_sp])
  apply (case_tac recv_opt, wpsimp, clarsimp)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rename_tac receiver state)
  apply (case_tac "\<forall>r'. state \<noteq> BlockedOnReply r'", solves \<open>wpsimp\<close>, clarsimp)
  apply (rule hoare_seq_ext[OF _ assert_sp])
  apply (rule_tac S="r'=reply" in hoare_gen_asm''
         ; clarsimp simp: obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (rule_tac B="\<lambda>_ s. consumed_time s = 0" in hoare_seq_ext[rotated])
   apply wpsimp
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext_skip, wpsimp wp: maybeM_inv)
  apply (rule hoare_seq_ext_skip)
  apply (case_tac fault; clarsimp?; (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext[OF _ gts_sp])
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (case_tac "runnable state \<longrightarrow> sc_opt = None"
         ; clarsimp simp: pred_conj_def obj_at_kh_kheap_simps pred_map_eq_normalise)
  apply (clarsimp simp: when_def, intro conjI impI; (solves \<open>wpsimp\<close>)?)
  apply (rule_tac B="\<lambda>_ s. consumed_time s = 0" in hoare_seq_ext[rotated])
   apply wpsimp
  apply wpsimp
  done

lemma do_reply_transfer_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> heap_refs_inv (tcb_scps_of s) (sc_tcbs_of s)
        \<and> valid_release_q s \<and> active_sc_valid_refills s \<and> cur_sc_active s
        \<and> cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s
        \<and> current_time_bounded s
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   do_reply_transfer sender reply grant
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   by (wpsimp wp: hoare_vcg_disj_lift do_reply_transfer_sc_not_in_release_q
                  do_reply_transfer_consumed_time)+

end

lemma commit_time_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "commit_time \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding commit_time_def
  by wpsimp

lemma refill_update_is_refill_ready[wp]:
  "\<lbrace>is_refill_ready sc_ptr and current_time_bounded and K(MIN_BUDGET \<le> new_budget)\<rbrace>
   refill_update sc_ptr' new_period new_budget new_max_refills
   \<lbrace>\<lambda>_. is_refill_ready sc_ptr\<rbrace>"
  unfolding refill_update_def set_refills_def refill_add_tail_def update_refill_hd_def get_refills_def
            update_refill_tl_def
  apply (wpsimp wp: update_sched_context_wp get_refills_wp)
  apply (intro conjI impI allI
         ; (clarsimp simp: vs_all_heap_simps refill_ready_def obj_at_def)?
         ; (erule cur_time_no_overflow)?)
  done

context DetSchedSchedule_AI begin

lemma refill_update_cur_sc_is_refill_ready[wp]:
  "\<lbrace>\<lambda>s. is_refill_ready (cur_sc s) s \<and> current_time_bounded s \<and> MIN_BUDGET \<le> new_budget\<rbrace>
   refill_update sc_ptr' new_period new_budget new_max_refills
   \<lbrace>\<lambda>_ s. is_refill_ready (cur_sc s) s\<rbrace>"
  by (rule hoare_lift_concrete_Pf_pre_conj[where f=cur_sc]; wpsimp)

lemma refill_new_cur_sc_is_refill_ready[wp]:
  "\<lbrace>\<lambda>s. current_time_bounded s \<and> (sc_ptr \<noteq> cur_sc s \<longrightarrow> is_refill_ready (cur_sc s) s)\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>_ s. is_refill_ready (cur_sc s) s\<rbrace>"
  unfolding refill_new_def
  apply (rule hoare_weaken_pre)
  apply (rule hoare_lift_Pf3[where f=cur_sc];
         wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: vs_all_heap_simps refill_ready_def obj_at_def)
  apply (erule cur_time_no_overflow)
  done

lemma refill_update_cur_sc_is_refill_sufficient[wp]:
  "\<lbrace>\<lambda>s. is_refill_sufficient 0 (cur_sc s) s \<and> MIN_BUDGET \<le> new_budget\<rbrace>
   refill_update sc_ptr' new_period new_budget new_max_refills
   \<lbrace>\<lambda>_ s. is_refill_sufficient 0 (cur_sc s) s\<rbrace>"
  by (rule hoare_lift_concrete_Pf_pre_conj[where f=cur_sc]; wpsimp)

lemma refill_new_cur_sc_is_refill_sufficient[wp]:
  "\<lbrace>\<lambda>s. if sc_ptr = cur_sc s
        then MIN_BUDGET \<le> budget
        else is_refill_sufficient 0 (cur_sc s) s\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>_ s. is_refill_sufficient 0 (cur_sc s) s\<rbrace>"
  unfolding refill_new_def
  apply (rule hoare_weaken_pre)
  apply (rule hoare_lift_Pf3[where f=cur_sc];
         wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: vs_all_heap_simps refill_sufficient_def refill_capacity_def obj_at_def)

end

crunches commit_time, refill_update, refill_new
  for ex_nonz_cap_to[wp]: "ex_nonz_cap_to ref"
  (wp: hoare_drop_imps simp: crunch_simps)

lemma commit_time_cur_sc_more_than_ready[wp]:
  "\<lbrace>\<top>\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. cur_sc_more_than_ready\<rbrace>"
  unfolding commit_time_def
  by wpsimp

lemma cancel_all_ipc_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_ipc epptr
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  apply (clarsimp simp: cancel_all_ipc_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep; case_tac "ep = IdleEP"; (solves wpsimp)?)
  apply (clarsimp simp: endpoint.case_eq_if)
  apply (rule hoare_seq_ext[OF _ get_epq_sp])
  apply (rule hoare_seq_ext, wpsimp)
   apply (rule hoare_strengthen_post[where Q="\<lambda>_. current_time_bounded and active_sc_valid_refills"])
    apply (wpsimp wp: mapM_x_wp' gts_wp)
   apply wpsimp+
  done

lemma cancel_all_signals_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and current_time_bounded\<rbrace>
   cancel_all_signals ntfnp
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  apply (clarsimp simp: cancel_all_signals_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (case_tac "ntfn_obj ntfn"; (solves wpsimp)?)
   apply (rule hoare_strengthen_post[where Q="\<lambda>_. active_sc_valid_refills and current_time_bounded"])
    apply (wpsimp wp: mapM_x_wp' gts_wp)
   apply wpsimp+
  done

lemma sched_context_zero_refill_max_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and current_time_bounded\<rbrace>
   sched_context_zero_refill_max scp
   \<lbrace>\<lambda>_. active_sc_valid_refills\<rbrace>"
  unfolding sched_context_zero_refill_max_def
  apply (wpsimp wp: update_sched_context_wp)
  by (clarsimp simp: obj_at_def vs_all_heap_simps active_sc_valid_refills_def active_sc_def)

context DetSchedSchedule_AI_handle_hypervisor_fault_det_ext begin

crunches refill_new, refill_update
  for ct_in_state[wp]: "ct_in_state P"
  (wp: crunch_wps)

lemma invoke_sched_control_configure_flags_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>invs
    and valid_sched_control_inv iv
    and cur_sc_in_release_q_imp_zero_consumed
    and cur_sc_more_than_ready
    and current_time_bounded
    and cur_sc_tcb_are_bound and ct_active and cur_sc_tcb_are_bound\<rbrace>
   invoke_sched_control_configure_flags iv
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  supply if_split[split del]
  apply (cases iv, simp)
  apply (rename_tac sc_ptr budget period mrefills badge flags)
  apply (simp add: invoke_sched_control_configure_flags_def)
  apply (rule_tac B="\<lambda>_ s. invs s
                           \<and> cur_sc_in_release_q_imp_zero_consumed s
                           \<and> cur_sc_more_than_ready s
                           \<and> current_time_bounded s
                           \<and> ex_nonz_cap_to sc_ptr s
                           \<and> sc_tcb_sc_at bound (cur_sc s) s \<and> ex_nonz_cap_to sc_ptr s
                           \<and> ct_active s \<and> cur_sc_tcb_are_bound s"
               in hoare_seq_ext[rotated])
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp wp: update_sc_badge_invs')
    apply (frule invs_valid_global_refs)
    apply (frule invs_valid_objs)
    using idle_sc_no_ex_cap apply blast
   apply (wpsimp wp: update_sched_context_wp)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps split: if_splits)
   apply (drule invs_sym_refs)
   apply (fastforce dest: sym_ref_tcb_sc)

  apply (rule hoare_seq_ext_skip)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply (wpsimp wp: update_sc_sporadic_invs')
    apply (frule invs_valid_global_refs)
    apply (frule invs_valid_objs)
    using idle_sc_no_ex_cap apply blast
   apply (wpsimp wp: update_sched_context_wp)
   apply (clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps split: if_splits)

  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule_tac B="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                           \<and> cur_sc_more_than_ready s
                           \<and> current_time_bounded s
                           \<and> (cur_sc s = sc_ptr \<longrightarrow> consumed_time s = 0)
                           \<and> heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
                           \<and> ex_nonz_cap_to sc_ptr s \<and> ct_active s \<and> invs s
                           \<and> cur_sc_tcb_are_bound s"
         in hoare_seq_ext)
   apply wpsimp
       apply (wpsimp wp: sched_context_resume_cur_sc_in_release_q_imp_zero_consumed split: if_splits)
      apply (wpsimp wp: gts_wp)
     apply wpsimp
    apply (rule_tac Q="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                             \<and> cur_sc_more_than_ready s
                             \<and> heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
                             \<and> current_time_bounded s \<and> ex_nonz_cap_to sc_ptr s
                             \<and> ct_active s \<and> invs s \<and> cur_sc_tcb_are_bound s"
           in hoare_strengthen_post[rotated])
     apply (clarsimp simp: cur_sc_more_than_ready_def split: if_splits)
     apply (intro conjI impI allI)
        apply (rule cur_sc_not_idle_sc_ptr; fastforce)
       apply (rule strengthen_cur_sc_offset_ready)
         apply fastforce
        apply (rule cur_sc_not_idle_sc_ptr; fastforce)
       apply fastforce
      apply (rule strengthen_cur_sc_offset_sufficient)
       apply fastforce
      apply (rule cur_sc_not_idle_sc_ptr; fastforce)
     apply (rule ex_nonz_cap_to_not_idle_sc_ptr; fastforce)
    apply (wpsimp wp: refill_update_invs)
   apply simp
   apply (prop_tac "sc_ptr \<noteq> idle_sc_ptr")
    apply (rule ex_nonz_cap_to_not_idle_sc_ptr; fastforce)
   apply simp
  apply (wpsimp wp: hoare_vcg_imp_lift)
       apply (strengthen invs_retract_sc_tcbs)
       apply (wpsimp wp: commit_time_invs tcb_sched_action_wp tcb_release_remove_wp
                         commit_time_sc_refill_max_sc_at hoare_vcg_imp_lift)
      apply wpsimp
     apply (rule_tac Q="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                              \<and> cur_sc_more_than_ready s
                              \<and> invs s
                              \<and> current_time_bounded s \<and> ct_active s \<and> cur_sc_tcb_are_bound s
                              \<and> ex_nonz_cap_to sc_ptr s"
            in hoare_strengthen_post[rotated])
      apply (clarsimp split: if_split)
     apply wpsimp
    apply (wpsimp wp: tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed)
   apply wpsimp
  apply (fastforce split: if_split simp: sc_at_pred_n_def obj_at_def)
  done

lemma sched_context_bind_tcb_helper_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t
        \<and> (\<forall>t\<in> set (release_queue s). pred_map bound (tcb_scps_of s) t)
        \<and> pred_map_eq None (tcb_scps_of s) tcb_ptr
        \<and> cur_sc_in_release_q_imp_zero_consumed s\<rbrace>
   do y \<leftarrow> set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr);
      set_sc_obj_ref sc_tcb_update sc_ptr (Some tcb_ptr)
   od
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (wpsimp wp: set_object_wp update_sched_context_wp simp: set_tcb_obj_ref_def obj_at_def)
  apply (prop_tac "not_in_release_q tcb_ptr s")
   apply (fastforce simp: in_release_q_def vs_all_heap_simps)
  apply (fastforce simp: not_in_release_q_def in_release_q_def tcb_scps.p.p.simps vs_all_heap_simps
                         heap_refs_retract_def cur_sc_in_release_q_imp_zero_consumed_def
                         pred_map_eq_def pred_map_def)
  done

lemma sched_context_bind_tcb_helper_heap_refs_retract_sc_tcbs:
  "\<lbrace>\<lambda>s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
        \<and> pred_map_eq None (tcb_scps_of s) tcb_ptr \<and>  pred_map_eq None (sc_tcbs_of s) sc_ptr\<rbrace>
   do y \<leftarrow> set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr);
      set_sc_obj_ref sc_tcb_update sc_ptr (Some tcb_ptr)
   od
   \<lbrace>\<lambda>_ s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (wpsimp wp: set_object_wp update_sched_context_wp simp: set_tcb_obj_ref_def obj_at_def)
  by (fastforce simp: heap_refs_inv_def heap_refs_retract_def vs_all_heap_simps
                      heap_refs_retract_at_def pred_map_eq_def pred_map_simps)

lemma sched_context_bind_tcb_helper_heap_refs_retract_tcb_scps:
  "\<lbrace>\<lambda>s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)
        \<and> pred_map_eq None (tcb_scps_of s) tcb_ptr \<and> pred_map_eq None (sc_tcbs_of s) sc_ptr\<rbrace>
   do y \<leftarrow> set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr);
      set_sc_obj_ref sc_tcb_update sc_ptr (Some tcb_ptr)
   od
   \<lbrace>\<lambda>_ s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)\<rbrace>"
  apply (wpsimp wp: set_object_wp update_sched_context_wp simp: set_tcb_obj_ref_def obj_at_def)
  by (fastforce simp: heap_refs_inv_def heap_refs_retract_def vs_all_heap_simps
                      heap_refs_retract_at_def pred_map_eq_def pred_map_simps)

lemma sched_context_bind_tcb_cur_sc_in_release_q_imp_zero_consumed_helper:
  "\<lbrace>\<lambda>s. pred_map_eq None (tcb_scps_of s) tcb_ptr \<and>  pred_map_eq None (sc_tcbs_of s) sc_ptr
        \<and> cur_sc_in_release_q_imp_zero_consumed s
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)
        \<and> (\<forall>t\<in> set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
        \<and> current_time_bounded s \<and> sc_ptr \<noteq> idle_sc_ptr
        \<and> (if sc_ptr = cur_sc s
           then cur_sc_more_than_ready s
           else heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   do y \<leftarrow> set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr);
      set_sc_obj_ref sc_tcb_update sc_ptr (Some tcb_ptr)
   od
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
          \<and> current_time_bounded s \<and> sc_ptr \<noteq> idle_sc_ptr
          \<and> (if sc_ptr = cur_sc s
             then cur_sc_more_than_ready s
             else heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>"
  apply (clarsimp split: if_splits)
  apply (intro hoare_vcg_conj_lift_pre_fix)

   \<comment> \<open>sc_ptr = cur_sc s in postcondition\<close>
   apply (rule hoare_weaken_pre)
    apply (rule hoare_vcg_imp_lift')
     apply wpsimp
    apply (rule hoare_vcg_conj_lift)
     apply (rule sched_context_bind_tcb_helper_cur_sc_in_release_q_imp_zero_consumed)
    apply wpsimp
   apply clarsimp

  \<comment> \<open>sc_ptr \<noteq> cur_sc s in postcondition\<close>
  apply (rule hoare_weaken_pre)
   apply (rule hoare_vcg_imp_lift')
    apply wpsimp
   apply (rule hoare_vcg_conj_lift)
    apply (rule sched_context_bind_tcb_helper_cur_sc_in_release_q_imp_zero_consumed)
   apply (rule hoare_vcg_conj_lift, wpsimp)

   apply (rule hoare_vcg_conj_lift)
    apply wpsimp
   apply (clarsimp simp: heap_refs_inv_def)
   apply (rule hoare_vcg_conj_lift)

    apply (rule sched_context_bind_tcb_helper_heap_refs_retract_sc_tcbs)
   apply (rule sched_context_bind_tcb_helper_heap_refs_retract_tcb_scps)
  apply (clarsimp simp: heap_refs_inv_def)
  done

lemma sched_context_resume_cur_sc_in_release_q_imp_zero_consumed_not_cur_sc:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> sc_ptr \<noteq> cur_sc s \<and> sc_ptr \<noteq> idle_sc_ptr \<and> heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   sched_context_resume sc_ptr
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (rule hoare_weaken_pre)
  apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                           \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply (wpsimp wp: sched_context_resume_cur_sc_not_in_release_q)
   apply wpsimp
  apply (fastforce split: if_splits)
  done

lemma sched_context_bind_tcb_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. pred_map_eq None (tcb_scps_of s) tcb_ptr \<and> pred_map_eq None (sc_tcbs_of s) sc_ptr
        \<and> cur_sc_in_release_q_imp_zero_consumed s
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)
        \<and> (\<forall>t\<in> set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
        \<and> current_time_bounded s
        \<and> sc_ptr \<noteq> idle_sc_ptr
        \<and> (if sc_ptr = cur_sc s
           then cur_sc_more_than_ready s
           else heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  supply if_split[split del]
  apply (simp add: sched_context_bind_tcb_def if_cond_refill_unblock_check_def)

  \<comment> \<open>split off the setting functions from the start of the definition
      so that sched_context_bind_tcb_cur_sc_in_release_q_imp_zero_consumed_helper can be used\<close>
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext[rotated])
   apply (rule sched_context_bind_tcb_cur_sc_in_release_q_imp_zero_consumed_helper)
  apply (clarsimp simp: maybeM_def bind_assoc)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rename_tac curscp)
  apply (rule_tac P="K (sc_ptr = curscp)" in hoare_pre_tautI; simp)
   apply (rule hoare_gen_asm', clarsimp)
   apply (wpsimp wp: sched_context_resume_cur_sc_in_release_q_imp_zero_consumed)
   apply (rule cur_sc_more_than_ready_imp_cur_sc_ready_and_sufficient; blast?)
  apply (rule_tac Q="(\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s \<and> current_time_bounded s
                      \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
                      \<and> (\<exists>n. ko_at (SchedContext x n) sc_ptr s))
                     and (\<lambda>s. cur_sc s = curscp) and K (sc_ptr \<noteq> curscp)
                     and K( sc_ptr \<noteq> idle_sc_ptr)"
         in hoare_weaken_pre[rotated])
   apply (clarsimp simp: pred_neg_def)
  apply (wpsimp wp: sched_context_resume_cur_sc_in_release_q_imp_zero_consumed_not_cur_sc)
  apply (clarsimp simp: heap_refs_inv_def split: if_splits)
  done

lemma sched_context_yield_to_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> current_time_bounded s
        \<and> sc_ptr \<noteq> idle_sc_ptr
        \<and> (if sc_ptr = cur_sc s
           then cur_sc_more_than_ready s
           else heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   sched_context_yield_to sc_ptr args
   \<lbrace>\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  unfolding sched_context_yield_to_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp simp: get_sc_obj_ref_def complete_yield_to_def set_tcb_obj_ref_def
                   wp: update_sched_context_wp set_object_wp hoare_drop_imps)
  apply clarsimp
  apply (rule_tac B="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s" in hoare_seq_ext[rotated])
   apply (wpsimp wp: sched_context_resume_cur_sc_in_release_q_imp_zero_consumed)
   apply (clarsimp simp: heap_refs_inv_def cur_sc_more_than_ready_def)
  using strengthen_cur_sc_offset_ready strengthen_cur_sc_offset_sufficient apply blast
  apply (rule hoare_seq_ext_skip)
   apply (rule hoare_seq_ext_skip, wpsimp)+
   apply (rule hoare_if; (solves \<open>wpsimp\<close>)?)
  apply wpsimp
  done

lemma sched_context_unbind_tcb_cur_sc_not_in_release_q[wp]:
  "sched_context_unbind_tcb sc_ptr \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext_skip, wpsimp wp: tcb_release_remove_wp)+
   apply (clarsimp simp: vs_all_heap_simps in_queue_2_def)
   using tcb_sched_act_set_simps(3) apply blast
  apply (wpsimp wp: set_object_wp
              simp: set_tcb_obj_ref_def)
  apply (clarsimp simp: vs_all_heap_simps in_queue_2_def split: if_splits)
  done

lemma sched_context_unbind_tcb_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "sched_context_unbind_tcb sc_ptr \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (rule cur_sc_in_release_q_imp_zero_consumed_lift)
  by wpsimp+

lemma invoke_sched_context_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> invs s
        \<and> valid_release_q s
        \<and> cur_sc_more_than_ready s
        \<and> current_time_bounded s
        \<and> valid_sched_context_inv i s\<rbrace>
   invoke_sched_context i
   \<lbrace>\<lambda>rv. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (cases i; wpsimp simp: invoke_sched_context_def sched_context_unbind_all_tcbs_def)
   apply (frule invs_valid_global_refs)
   apply (frule idle_sc_no_ex_cap; fastforce?)
   apply (fastforce simp: obj_at_kh_kheap_simps vs_all_heap_simps valid_release_q_def pred_neg_def
                          is_blocked_on_reply_def)
  apply (frule invs_valid_global_refs)
  apply (frule idle_sc_no_ex_cap; fastforce?)
  done

lemma cancel_ipc_heap_refs_inv_sc_tcbs[wp]:
  "cancel_ipc tptr \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  by (wpsimp simp: heap_refs_inv_def)

lemma ex_nonz_cap_to_tcb_sched_context:
  "\<lbrakk>bound_sc_tcb_at ((=) (Some sc_ptr)) thread s; invs s; tcb_at thread s; ex_nonz_cap_to thread s\<rbrakk>
   \<Longrightarrow> ex_nonz_cap_to sc_ptr s"
   apply (clarsimp simp: obj_at_def is_tcb_def)
   apply (rename_tac ko, case_tac ko; clarsimp)
   apply (rename_tac tcb)
   apply (prop_tac "valid_tcb thread tcb s")
    apply (frule invs_valid_objs)
    apply (fastforce simp: valid_objs_def valid_obj_def)
   apply (prop_tac "sc_at sc_ptr s")
    apply (clarsimp simp: pred_tcb_at_def obj_at_def valid_tcb_def valid_bound_obj_def
                   split: option.splits)
   apply (clarsimp simp: live_def is_sc_obj_def obj_at_def)
   apply (rule if_live_then_nonz_capD2; fastforce?)
   apply (clarsimp simp: live_def live_sc_def pred_tcb_at_def obj_at_def)
   apply (rename_tac ko n, case_tac ko; clarsimp)
   apply (clarsimp simp: live_def live_sc_def pred_tcb_at_def obj_at_def)
   apply (frule invs_sym_refs)
   apply (elim disjE)
    apply (frule invs_sym_refs)
    apply (frule_tac tp=thread in sym_ref_tcb_sc; fastforce?)
     apply (erule sym)
    apply fastforce
   apply (frule invs_valid_idle)
   apply (clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def)
   apply (prop_tac "ex_nonz_cap_to idle_thread_ptr s")
    apply (rule if_live_then_nonz_capD2; fastforce?)
    apply (clarsimp simp: live_def)
    apply (prop_tac "thread \<noteq> idle_thread_ptr")
     apply (frule invs_valid_global_refs)
     apply (frule idle_no_ex_cap; fastforce)
    apply (frule invs_sym_refs)
    apply (frule_tac tp=thread in sym_ref_tcb_sc)
      apply fastforce
     apply (erule sym)
    apply fastforce
   apply (frule invs_valid_global_refs)
   apply (frule idle_no_ex_cap)
   apply fastforce
  apply fastforce
  done

lemma restart_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
        \<and> current_time_bounded s
        \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s
                               \<and> cur_sc_offset_sufficient (consumed_time s) s)
        \<and> ex_nonz_cap_to thread s
        \<and> tcb_at thread s
        \<and> invs s\<rbrace>
   restart thread
   \<lbrace>\<lambda>_ s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: restart_def test_possible_switch_to_def if_cond_refill_unblock_check_def)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp simp: heap_refs_inv_def\<close>)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases, simp)
  apply (rule_tac R1="\<lambda>s. \<forall>sc_ptr. sc_opt = Some sc_ptr \<longrightarrow> sc_ptr \<noteq> idle_sc_ptr"
               in hoare_pre_add[THEN iffD2, simplified pred_conj_def])
   apply (intro conjI impI allI)
   apply (rename_tac sc_ptr)
   apply (rule_tac scp=sc_ptr in ex_nonz_cap_to_not_idle_sc_ptr)
    apply fastforce
   apply (fastforce intro: ex_nonz_cap_to_tcb_sched_context)
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: cancel_ipc_cap_to)
  apply (rule_tac B="\<lambda>_ s. bound_sc_tcb_at ((=) sc_opt) thread s
                           \<and> sc_not_in_release_q (cur_sc s) s
                           \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
                           \<and> current_time_bounded s
                           \<and> (cur_sc_active s
                              \<longrightarrow> cur_sc_offset_ready (consumed_time s) s
                                  \<and> cur_sc_offset_sufficient (consumed_time s) s)
                           \<and> ex_nonz_cap_to thread s \<and> tcb_at thread s
                           \<and> (\<forall>sc_ptr. sc_opt = Some sc_ptr \<longrightarrow> sc_ptr \<noteq> idle_sc_ptr)"
               in hoare_seq_ext[rotated])
   apply wpsimp
  apply (rule hoare_seq_ext_skip)
   apply wpsimp
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  apply (wpsimp wp: sched_context_resume_cur_sc_not_in_release_q)
  apply (intro conjI impI)
    apply (rename_tac sc_opt)
    apply (clarsimp simp: when_def)
    apply (rule strengthen_cur_sc_offset_ready)
      apply fastforce
     apply fastforce
    apply fastforce
   apply (rule strengthen_cur_sc_offset_sufficient, fastforce+)
  apply (clarsimp simp: heap_refs_inv_def)
  done

crunches restart
  for consumed_time[wp]: "\<lambda>s. P (consumed_time s)"
  (wp: crunch_wps simp: crunch_simps)

lemma restart_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
        \<and> cur_sc_more_than_ready s
        \<and> current_time_bounded s
        \<and> invs s \<and> ex_nonz_cap_to thread s \<and> tcb_at thread s\<rbrace>
   restart thread
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding cur_sc_in_release_q_imp_zero_consumed_def
  apply (rule hoare_weaken_pre)
   apply (rule_tac Q="\<lambda>_ s. (\<forall>t. heap_ref_eq (cur_sc s) t (tcb_scps_of s) \<longrightarrow> (\<not> in_release_q t s))
                            \<or> consumed_time s = 0"
               in hoare_strengthen_post[rotated], blast)
   apply (rule hoare_vcg_disj_lift)
    apply (rule restart_cur_sc_not_in_release_q)
   apply wpsimp
  apply (clarsimp simp: cur_sc_more_than_ready_def)
  done

lemma suspend_cur_sc_not_in_release_q[wp]:
  "suspend thread \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  unfolding suspend_def sched_context_cancel_yield_to_def maybeM_def
  apply (wpsimp wp: tcb_release_remove_wp simp: update_restart_pc_def)
  apply (clarsimp simp: in_release_q_def not_in_release_q_def in_queue_2_def split: if_splits)
  using tcb_sched_act_set_simps(3) by blast

lemma suspend_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "suspend thread \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  apply (rule cur_sc_in_release_q_imp_zero_consumed_lift)
   by wpsimp+

lemma unbind_from_sc_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "unbind_from_sc tcb_ptr \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding unbind_from_sc_def maybeM_def complete_yield_to_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac sc_ptr_opt; clarsimp?)
  apply (rule hoare_seq_ext_skip, wpsimp)+
  apply (case_tac "sc_yield_from sc"; clarsimp?)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac x; clarsimp?)
  apply (rule hoare_seq_ext_skip, wpsimp)+
  apply wpsimp
  done

crunches cancel_all_ipc, cancel_all_signals, sched_context_unbind_all_tcbs
  for cur_sc_in_release_q_imp_zero_consumed[wp]: "\<lambda>s :: det_state. cur_sc_in_release_q_imp_zero_consumed s"
  (wp: crunch_wps)

crunches cancel_all_ipc, cancel_all_signals
  for release_q[wp]: "\<lambda>s. P (release_queue s)"
  and heap_refs_inv_sc_tcb[wp]: "\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
  (wp: crunch_wps)

lemma sched_context_unbind_tcb_heap_refs_retract_tcb_scps[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>_ s. heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s) \<rbrace>"
  apply (clarsimp simp: heap_refs_inv_def)
  apply (clarsimp simp: sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext[OF _ assert_opt_sp])
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp simp: obj_at_def\<close>)+
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred update_sc_tcb_valid_sched_pred
                    get_sc_obj_ref_wp)
  apply (clarsimp simp: obj_at_def heap_upd_def)
  apply (prop_tac "heap_ref_eq tptr sc_ptr (sc_tcbs_of s)")
   apply (clarsimp simp: vs_all_heap_simps)
  apply (fastforce simp: heap_refs_inv_def heap_refs_retract_def vs_all_heap_simps
                         heap_refs_retract_at_def pred_map_eq_def pred_map_simps)
  done

lemma sched_context_unbind_tcb_heap_refs_retract_sc_tcbs[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>_ s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (clarsimp simp: sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext[OF _ get_sched_context_sp])
  apply (rule hoare_seq_ext[OF _ assert_opt_sp])
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp simp: obj_at_def\<close>)+
  apply (wpsimp wp: set_tcb_sched_context_valid_sched_pred update_sc_tcb_valid_sched_pred
                    get_sc_obj_ref_wp)
  apply (clarsimp simp: obj_at_def heap_upd_def)
  apply (prop_tac "heap_ref_eq tptr sc_ptr (sc_tcbs_of s)")
   apply (clarsimp simp: vs_all_heap_simps)
  apply (prop_tac "heap_ref_eq sc_ptr tptr (tcb_scps_of s)")
   apply (fastforce simp: heap_refs_inv_def heap_refs_retract_def vs_all_heap_simps
                          heap_refs_retract_at_def pred_map_eq_def pred_map_simps)
  apply (clarsimp simp: heap_refs_inv_def heap_refs_retract_def vs_all_heap_simps
                        heap_refs_retract_at_def pred_map_eq_def pred_map_simps)
  by (metis kernel_object.simps(2) option.sel)

lemma sched_context_unbind_tcb_heap_refs_inv_sc_tcbs[wp]:
  "sched_context_unbind_tcb sc_ptr \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  by (wpsimp simp: heap_refs_inv_def)+

lemma reply_remove_heap_refs_inv_sc_tcbs[wp]:
  "reply_remove caller r \<lbrace>\<lambda>s :: det_state. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding reply_remove_def
  apply (clarsimp simp: heap_refs_inv_def)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)+
  apply (rule hoare_seq_ext_skip)
   apply (case_tac r_sc_opt; clarsimp?)
   apply (rule hoare_seq_ext_skip, wpsimp)
   apply (rule hoare_seq_ext[OF _ gsc_sp])
   apply (rule_tac B="\<lambda>_ s. heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
                            \<and> heap_refs_retract (tcb_scps_of s) (sc_tcbs_of s)
                            \<and> bound_sc_tcb_at ((=) caller_sc) caller s"
           in hoare_seq_ext[rotated])
    apply wpsimp
   apply (clarsimp simp: when_def)
   apply ((wpsimp wp: sched_context_donate_sc_tcbs_of_retract
                      sched_context_donate_tcb_scps_of_retract
           | intro conjI impI)+)[1]
    apply (clarsimp simp: vs_all_heap_simps obj_at_kh_kheap_simps)
   apply wpsimp+
  done

lemma sched_context_donate_release_q_bound_to_sc_helper:
  "do y <- set_sc_obj_ref sc_tcb_update sc_ptr (Some tcb_ptr);
      set_tcb_obj_ref tcb_sched_context_update tcb_ptr (Some sc_ptr)
   od
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
   apply (wpsimp wp: update_sched_context_wp set_object_wp simp: set_tcb_obj_ref_def)
   apply (clarsimp simp: vs_all_heap_simps pred_map_simps)
   by (metis kernel_object.distinct(17) ko_at_fold option.sel)

lemma sched_context_donate_release_q_bound_to_sc[wp]:
  "sched_context_donate sc_ptr tcb_ptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  unfolding sched_context_donate_def
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (clarsimp simp: when_def
         ; (intro conjI impI)?
         ; (solves \<open>wpsimp wp: sched_context_donate_release_q_bound_to_sc_helper\<close>)?)
  apply (rule hoare_seq_ext_skip
         ; (solves \<open>wpsimp wp: sched_context_donate_release_q_bound_to_sc_helper\<close>)?)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)+
  apply (rule_tac B="\<lambda>_ s. sc_tcb_sc_at ((=) from_opt) sc_ptr s
                           \<and> (\<forall>t\<in>set (release_queue s).
                                  pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
                           \<and> not_in_release_q from_tptr s"
            in hoare_seq_ext[rotated])
   apply (wpsimp wp: tcb_release_remove_wp)
   apply (intro conjI)
    using tcb_sched_act_set_simps(3) apply blast
   using tcb_sched_act_in_queues_2_simps(3) apply blast
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: set_object_wp simp: set_tcb_obj_ref_def)
   apply (clarsimp simp: vs_all_heap_simps pred_map_simps not_in_release_q_def)
  apply (wpsimp wp: test_reschedule_wp)
  done

lemma reply_remove_release_q_bound_to_sc[wp]:
  "\<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)\<rbrace>
   reply_remove caller r
   \<lbrace>\<lambda>_ s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  apply (clarsimp simp: reply_remove_def)
  by (rule hoare_seq_ext_skip; (solves \<open>wpsimp\<close>)?)+

lemma cancel_all_ipc_release_q_not_blocked_on_reply[wp]:
  "cancel_all_ipc epptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<forall>t\<in>set (release_queue s).
                           st_tcb_at (not is_blocked_on_reply) t s"
         in hoare_strengthen_post[rotated])
   apply (clarsimp simp: obj_at_kh_kheap_simps)
  apply (wpsimp wp: hoare_vcg_ball_lift2 hoare_vcg_all_lift cancel_all_ipc_st_tcb_at
              simp: pred_neg_def)
  apply (fastforce simp: vs_all_heap_simps pred_tcb_at_def obj_at_def)
  done

lemma cancel_all_ipc_release_q_bound_to_sc[wp]:
  "cancel_all_ipc epptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  unfolding cancel_all_ipc_def restart_thread_if_no_fault_def
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)
  by (case_tac ep; wpsimp wp: hoare_vcg_ball_lift2 gts_wp' mapM_x_wp')

lemma cancel_all_signals_release_q_not_blocked_on_reply[wp]:
  "cancel_all_signals nftnptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<forall>t\<in>set (release_queue s).
                            st_tcb_at (not is_blocked_on_reply) t s"
         in hoare_strengthen_post[rotated])
   apply (clarsimp simp: obj_at_kh_kheap_simps)
  apply (wpsimp wp: hoare_vcg_ball_lift2 hoare_vcg_all_lift cancel_all_signals_st_tcb_at'
              simp: pred_neg_def)
  apply (fastforce simp: vs_all_heap_simps pred_tcb_at_def obj_at_def)
  done

lemma cancel_all_signals_release_q_bound_to_sc[wp]:
  "cancel_all_signals nftnptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  unfolding cancel_all_signals_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac "ntfn_obj ntfn"; clarsimp?)
  apply (wpsimp wp: hoare_vcg_ball_lift2 mapM_x_wp'
              simp: cancel_all_signals_def mapM_x_wp')
  done

lemma cancel_ipc_not_release_q_not_blocked_on_reply[wp]:
  "cancel_ipc tptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<forall>t\<in>set (release_queue s).
                             st_tcb_at (not is_blocked_on_reply) t s"
         in hoare_strengthen_post[rotated])
  apply (clarsimp simp: obj_at_kh_kheap_simps)
  apply (wpsimp wp: hoare_vcg_ball_lift2 hoare_vcg_all_lift cancel_ipc_st_tcb_at
              simp: pred_neg_def)
  apply (fastforce simp: vs_all_heap_simps pred_tcb_at_def obj_at_def)
  done

lemma reply_remove_release_q_not_blocked_on_reply[wp]:
  "reply_remove caller r
   \<lbrace>\<lambda>s :: det_state. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. \<forall>t\<in>set (release_queue s).
                            st_tcb_at (not is_blocked_on_reply) t s"
         in hoare_strengthen_post[rotated])
   apply (clarsimp simp: obj_at_kh_kheap_simps)
  apply (wpsimp wp: reply_remove_not_in_release_q[simplified not_in_release_q_def]
                    hoare_vcg_ball_lift2 hoare_vcg_all_lift
              simp: pred_neg_def)
  apply (fastforce simp: vs_all_heap_simps pred_tcb_at_def obj_at_def)
  done

lemma sched_context_unbind_tcb_release_q_not_blocked_on_reply[wp]:
  "sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  by (wpsimp wp: hoare_vcg_ball_lift2
                 sched_context_unbind_tcb_not_in_release_queue[simplified not_in_release_q_def])

lemma sched_context_unbind_tcb_release_q_bound_to_sc[wp]:
  "sched_context_unbind_tcb sc_ptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  apply (clarsimp simp: sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp\<close>)+
  apply (rule_tac B="\<lambda>_ s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t
                           \<and>  not_in_release_q tptr s"
            in hoare_seq_ext[rotated])
   apply (wpsimp wp: tcb_release_remove_wp)
   apply (intro conjI impI)
    apply (clarsimp simp: vs_all_heap_simps)
    using tcb_sched_act_set_simps(3) apply blast
   using tcb_sched_act_in_queues_2_simps(3) apply blast
  apply (wpsimp wp: update_sched_context_wp set_object_wp
              simp: set_tcb_obj_ref_def)
  apply (fastforce simp: vs_all_heap_simps obj_at_def pred_map_simps not_in_release_q_2_def
                  split: if_splits)
  done

abbreviation (input) cur_sc_in_release_q_imp_zero_consumed_pred where
  "cur_sc_in_release_q_imp_zero_consumed_pred s \<equiv>
    sc_not_in_release_q (cur_sc s) s
    \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)
    \<and> (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
    \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"

lemma fast_finalise_release_q_not_blocked_on_reply[wp]:
  "fast_finalise cap final
   \<lbrace>\<lambda>s :: det_state. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
   apply wpsimp
   apply (clarsimp simp: pred_neg_def)
  apply (wpsimp wp: gts_wp' get_simple_ko_wp cancel_all_ipc_valid_sched cancel_all_ipc_invs)
  done

lemma sched_context_cancel_yield_to_release_q_not_blocked_on_reply[wp]:
  "sched_context_cancel_yield_to thread
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (clarsimp simp: sched_context_cancel_yield_to_def)
  apply (wpsimp wp: hoare_vcg_ball_lift2 get_tcb_obj_ref_wp simp: pred_neg_def)
  done

crunches update_restart_pc
  for release_q[wp]: "\<lambda>s. P (release_queue s)"
  and tcb_sts_of[wp]: "\<lambda>s. P (tcb_sts_of s)"

lemma suspend_release_q_not_blocked_on_reply[wp]:
  "suspend thread
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (clarsimp simp: suspend_def)
  apply (rule hoare_seq_ext_skip, solves \<open>wpsimp simp: update_restart_pc_def\<close>)+
  apply (rule hoare_seq_ext_skip)
   apply (wpsimp wp: hoare_vcg_ball_lift2 simp: vs_all_heap_simps)
  apply (wpsimp wp: tcb_release_remove_wp)
   apply (wpsimp wp: hoare_vcg_ball_lift2 set_thread_state_pred_map_tcb_sts_of)
  apply (clarsimp simp: pred_neg_def)
  using tcb_sched_act_set_simps(3) apply blast
  done

lemma unbind_from_sc_release_q_not_blocked_on_reply[wp]:
  "unbind_from_sc tcb_ptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  unfolding unbind_from_sc_def maybeM_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift simp: pred_neg_def)

lemma unbind_from_sc_heap_refs_inv_sc_tcbs[wp]:
  "unbind_from_sc tcb_ptr \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding unbind_from_sc_def maybeM_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift)

lemma unbind_from_sc_release_q_bound_to_sc[wp]:
  "unbind_from_sc tcb_ptr
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  unfolding unbind_from_sc_def maybeM_def
  by (wpsimp wp: hoare_drop_imps hoare_vcg_all_lift)

lemma suspend_heap_refs_inv_sc_tcbs[wp]:
  "suspend thread \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (clarsimp simp: suspend_def sched_context_cancel_yield_to_def)
  apply (rule hoare_seq_ext_skip, wpsimp simp: update_restart_pc_def)+
  by wpsimp

lemma suspend_release_q_bound_to_sc[wp]:
  "suspend thread
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  apply (clarsimp simp: suspend_def maybeM_def sched_context_cancel_yield_to_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip, wpsimp)
   apply (wpsimp wp: tcb_release_remove_wp  simp: update_restart_pc_def)
   using tcb_sched_act_set_simps(3) apply blast
  done

crunches cap_delete_one
  for release_q_not_blocked_on_reply[wp]:
          "\<lambda>s :: det_state. \<forall>t\<in>set (release_queue s).
                                                pred_map (not is_blocked_on_reply) (tcb_sts_of s) t"
  and release_q_bound_to_sc[wp]:
          "\<lambda>s :: det_state. (\<forall>t\<in>set (release_queue s).
                                                pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)"
  and heap_refs_inv_sc_tcbs_of[wp]: "\<lambda>s :: det_state. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
  (simp: crunch_simps wp: crunch_wps)

lemma finalise_cap_release_q_not_blocked_on_reply[wp]:
  "finalise_cap cap final
   \<lbrace>\<lambda>s :: det_state. \<forall>x\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) x\<rbrace>"
  supply pred_neg_simp[simp del]
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
    apply (wpsimp wp: gts_wp' get_simple_ko_wp)
   apply (wpsimp simp: deleting_irq_handler_def sched_context_unbind_all_tcbs_def)+
  done

lemma finalise_cap_release_q_bound_to_sc[wp]:
  "\<lbrace>\<lambda>s. (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)\<rbrace>
   finalise_cap cap final
   \<lbrace>\<lambda>_ s :: det_state. (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)\<rbrace>"
  supply pred_neg_simp[simp del]
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
    apply (wpsimp wp: gts_wp' get_simple_ko_wp)
   apply (wpsimp simp: deleting_irq_handler_def sched_context_unbind_all_tcbs_def)+
  done

lemma finalise_cap_heap_refs_inv_sc_tcbs_of[wp]:
  "finalise_cap cap final \<lbrace>\<lambda>s :: det_state. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
    apply (wpsimp wp: gts_wp' get_simple_ko_wp)
   apply (wpsimp simp: deleting_irq_handler_def sched_context_unbind_all_tcbs_def)+
  done

crunches cancel_all_ipc, cancel_all_signals, reply_remove, cancel_ipc
  for cur_sc_not_in_release_q[wp]: "\<lambda>s :: det_state. sc_not_in_release_q (cur_sc s) s"
  (wp: crunch_wps simp: crunch_simps)

lemma unbind_from_sc_cur_sc_not_in_release_q[wp]:
  "unbind_from_sc tcb_pr \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (clarsimp simp: unbind_from_sc_def sched_context_unbind_tcb_def)
  apply (rule hoare_seq_ext_skip, wpsimp)+
  apply wpsimp
  done

lemma fast_finalise_cur_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)\<rbrace>
   fast_finalise cap final
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
  apply (wpsimp wp: gts_wp' get_simple_ko_wp cancel_all_ipc_valid_sched cancel_all_ipc_invs)
  apply (fastforce simp: not_in_release_q_def vs_all_heap_simps in_release_q_def pred_neg_def
                         is_blocked_on_reply_def)
  done

crunches cap_delete_one
  for cur_sc_not_in_release_q[wp]: "\<lambda>s :: det_state. sc_not_in_release_q (cur_sc s) s"
  (wp: crunch_wps simp: crunch_simps)

lemma finalise_cap_cur_sc_not_in_release_q[wp]:
  "\<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)\<rbrace>
   finalise_cap cap final
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  apply (cases cap; (clarsimp simp: when_def, intro conjI impI)?; (solves \<open>wpsimp\<close>)?)
    apply (wpsimp wp: gts_wp get_simple_ko_wp hoare_vcg_imp_lift')
    apply (clarsimp simp: valid_release_q_def in_release_q_def vs_all_heap_simps pred_neg_def
                          is_blocked_on_reply_def pred_tcb_at_def obj_at_def)
    apply (metis kernel_object.inject(2) option.inject)
   apply (wpsimp simp: deleting_irq_handler_def sched_context_unbind_all_tcbs_def)+
  done

lemma preemption_point_release_q_not_blocked_on_reply[wp]:
  "preemption_point
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  apply (wpsimp wp: preemption_point_inv)
  done

lemma preemption_point_release_q_bound_to_sc[wp]:
  "preemption_point \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  apply (wpsimp wp: preemption_point_inv)
  done

lemma preemption_point_heap_refs_inv_sc_tcbs_of[wp]:
  "preemption_point \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  apply (wpsimp wp: preemption_point_inv)
  done

lemma rec_del_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   rec_del slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  apply (clarsimp simp: validE_R_def)
  apply (rule rec_del_preservationE, wpsimp+)
  done

lemma cap_delete_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   cap_delete slot
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  unfolding cap_delete_def
  by (wpsimp wp: rec_del_preservation[where P="\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s"])

lemma cap_revoke_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   cap_revoke ptr
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  apply (clarsimp simp: validE_R_def)
  apply (rule  cap_revoke_preservationE, wpsimp+)
  done

lemma cancel_badged_sends_cur_sc_not_in_release_q[wp]:
  "cancel_badged_sends epptr badge \<lbrace>\<lambda>s. sc_not_in_release_q (cur_sc s) s\<rbrace>"
  unfolding cancel_badged_sends_def restart_thread_if_no_fault_def
  by (wpsimp wp: filterM_preserved get_simple_ko_wp)+

lemma cancel_badged_sends_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "cancel_badged_sends epptr badge \<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding cancel_badged_sends_def restart_thread_if_no_fault_def
  by (wpsimp wp: filterM_preserved get_simple_ko_wp)+

lemma cancel_badged_sends_release_q_not_blocked_on_reply[wp]:
  "cancel_badged_sends epptr badge
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t\<rbrace>"
  unfolding cancel_badged_sends_def restart_thread_if_no_fault_def
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (case_tac ep; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_seq_ext_skip; (solves \<open>wpsimp\<close>)?)
  apply (rule filterM_preserved)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (rule hoare_if; (clarsimp simp: bind_assoc)?, (solves \<open>wpsimp\<close>)?)
  apply (rule hoare_seq_ext_skip; (solves \<open>wpsimp\<close>)?)+
  apply (rule hoare_if
         ; wpsimp wp: hoare_vcg_ball_lift2 hoare_vcg_all_lift set_thread_state_pred_map_tcb_sts_of
                simp: pred_neg_def is_blocked_on_reply_def)
  done

lemma cancel_badged_sends_heap_refs_inv_sc_tcbs[wp]:
  "cancel_badged_sends epptr badge \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding cancel_badged_sends_def restart_thread_if_no_fault_def
  by (wpsimp wp: filterM_preserved get_simple_ko_wp)

lemma cancel_badged_sends_release_q_bound_to_sc[wp]:
  "cancel_badged_sends epptr badge
   \<lbrace>\<lambda>s. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>"
  unfolding cancel_badged_sends_def restart_thread_if_no_fault_def
  by (wpsimp wp: filterM_preserved get_simple_ko_wp)

lemma install_tcb_frame_cap_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  unfolding install_tcb_frame_cap_def
  supply pred_neg_simp[simp del]
  apply (cases buffer; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed_pred"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated])
   apply wpsimp
  apply (rule hoare_seq_ext_skipE, wpsimp wp: thread_set_wp)
   apply (clarsimp simp: vs_all_heap_simps in_release_q_def get_tcb_def
                         cur_sc_in_release_q_imp_zero_consumed_def)
   apply (case_tac "kheap s target"; clarsimp?)
   apply (rename_tac obj) \<comment> \<open>kheap s target = obj\<close>
   apply (case_tac obj; (clarsimp split: if_splits)?)
   apply (fastforce simp: vs_all_heap_simps heap_refs_inv_def heap_refs_retract_def
                          heap_refs_retract_at_def)
  apply (wpsimp wp: check_cap_inv)
  done

lemma rec_del_release_q_bound_to_sc[wp]:
  "\<lbrace>\<lambda>s. (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)\<rbrace>
   rec_del slot
   \<lbrace>\<lambda>_ s :: det_state. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>, -"
  (is "\<lbrace>?pre\<rbrace> _ \<lbrace>_\<rbrace>, -")
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>_. ?pre" in hoare_post_impErr)
  apply (rule rec_del_preservationE, wpsimp+)
  done

lemma install_tcb_cap_release_q_bound_to_sc[wp]:
  "\<lbrace>\<lambda>s. (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
        \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)\<rbrace>
   install_tcb_cap target slot n slot_opt
   \<lbrace>\<lambda>_ s :: det_state. \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t\<rbrace>, -"
  unfolding install_tcb_cap_def
  apply (cases slot_opt; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (wpsimp wp: check_cap_inv
              simp: cap_delete_def)
  done

lemma install_tcb_cap_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   install_tcb_cap target slot n buffer
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  unfolding install_tcb_cap_def
  apply (cases buffer; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed_pred"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated])
   apply wpsimp
  apply (wpsimp wp: check_cap_inv)
  done

lemma valid_release_q_imp_not_blocked_on_reply[elim!]:
  "valid_release_q s
   \<Longrightarrow> \<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t"
  by (fastforce simp: valid_release_q_def in_release_q_def vs_all_heap_simps pred_neg_def
                      is_blocked_on_reply_def)

lemma valid_release_q_imp_bound_to_sc[elim!]:
  "valid_release_q s
   \<Longrightarrow> \<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t"
  by (fastforce simp: valid_release_q_def in_release_q_def vs_all_heap_simps)

crunches maybe_sched_context_unbind_tcb
  for cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
                "\<lambda>s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s"
  (wp: crunch_wps)

lemma install_tcb_cap_cur_sc_not_in_release_q:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   install_tcb_cap target slot n buffer
   \<lbrace>\<lambda>_ s :: det_state. sc_not_in_release_q (cur_sc s) s\<rbrace>, -"
  unfolding install_tcb_cap_def
  apply (cases buffer; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed_pred"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated])
   apply wpsimp
  apply (wpsimp wp: check_cap_inv)
  done

lemma install_tcb_cap_release_q_not_blocked_on_reply[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   install_tcb_cap target slot n buffer
   \<lbrace>\<lambda>_ s :: det_state. (\<forall>t\<in>set (release_queue s).
                                       pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)\<rbrace>, -"
  unfolding install_tcb_cap_def
  apply (cases buffer; clarsimp?, (solves \<open>wpsimp\<close>)?)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed_pred"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated])
   apply wpsimp
  apply (wpsimp wp: check_cap_inv)
  done

crunches sched_context_yield_to, sched_context_bind_tcb,
         cancel_badged_sends, restart, maybe_sched_context_unbind_tcb, maybe_sched_context_bind_tcb,
         sched_context_bind_tcb, bind_notification, send_signal
  for cur_sc[wp]: "\<lambda>s. P (cur_sc s)"
  (wp: crunch_wps check_cap_inv filterM_preserved simp: crunch_simps)

crunches install_tcb_cap, install_tcb_frame_cap, do_reply_transfer, invoke_irq_handler, awaken,
         check_domain_time, if_cond_refill_unblock_check, activate_thread, handle_fault, handle_recv,
         handle_yield, handle_interrupt, preemption_path
  for cur_sc[wp]: "\<lambda>s :: det_state. P (cur_sc s)"
  (wp: crunch_wps check_cap_inv  preemption_point_inv hoare_vcg_all_lift simp: crunch_simps)

crunches perform_invocation
  for cur_sc[wp]: "\<lambda>s :: det_state. P (cur_sc s)"
  (wp: crunch_wps preemption_point_inv check_cap_inv filterM_preserved cap_revoke_preservation
   simp: crunch_simps)

lemma invoke_tcb_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> cur_sc_in_release_q_imp_zero_consumed_pred s
        \<and> current_time_bounded s
        \<and> invs s
        \<and> cur_sc_more_than_ready s
        \<and> valid_sched s \<and> valid_machine_time s
        \<and> tcb_inv_wf iv s
        \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
        \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
        \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>, -"
  apply (cases iv; clarsimp?, (solves \<open>wpsimp\<close>)?)

       apply ((wpsimp wp: liftE_wp | intro conjI)+)[1]

      \<comment> \<open>iv = CopyRegisters\<close>
      apply (rename_tac dest src suspend_source resume_target transfer_frame transfer_integer transfer_arch)
      apply (clarsimp simp: validE_R_def)
      apply (rule_tac B="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                               \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
                               \<and> cur_sc_more_than_ready s
                               \<and> current_time_bounded s \<and> invs s \<and> cur_sc s \<noteq> idle_sc_ptr
                               \<and> ex_nonz_cap_to dest s \<and> tcb_at dest s"
                   in hoare_seq_ext[rotated])
       apply (wpsimp wp : suspend_invs)
       apply (frule invs_valid_global_refs)
       apply (frule idle_no_ex_cap)
        apply fastforce
       apply (frule invs_valid_idle)
       apply (frule idle_thread_idle_thread_ptr)
       apply fastforce
      apply (rule_tac B="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s" in hoare_seq_ext[rotated])
       apply wpsimp

      apply (rule hoare_seq_ext_skip, wpsimp wp: mapM_x_wp[where S="set frame_registers"])
      apply (rule hoare_seq_ext_skip, wpsimp wp: mapM_x_wp[where S="set gpRegisters"])
      apply wpsimp

    \<comment> \<open>iv = ThreadControlCaps\<close>
    apply (clarsimp simp: validE_R_def)
    apply (rule_tac Q="cur_sc_in_release_q_imp_zero_consumed_pred" in hoare_weaken_preE[rotated])
     apply simp
    apply (rule hoare_seq_ext_skipE, wpsimp)+
    apply wpsimp
    apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)

   \<comment> \<open>iv = NotificationControl\<close>
   apply (find_goal \<open>match premises in "_ = NotificationControl _ _" \<Rightarrow> \<open>-\<close>\<close>)
   apply (rename_tac tcb ntfnptr_opt)
   apply (case_tac ntfnptr_opt; wpsimp simp: bind_notification_def)

  \<comment> \<open>iv = ThreadControlSched\<close>
  supply pred_neg_simp[simp del]
  apply (rename_tac target a b fault_handler mcp priority sc)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac Q="\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s
                         \<and> invs s \<and> valid_machine_time s
                         \<and> current_time_bounded s
                         \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                         \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
                         \<and> (case sc of None \<Rightarrow> \<lambda>_. True
                                     | Some None \<Rightarrow> \<lambda>s. True
                                     | Some (Some scptr) \<Rightarrow> (bound_sc_tcb_at ((=) None) target)
                                                             and sc_tcb_sc_at ((=) None) scptr) s
                         \<and> cur_sc s \<noteq> idle_sc_ptr"
               in hoare_weaken_preE[rotated])
   apply (simp add: valid_sched_def)
   apply (clarsimp split: option.splits)

  apply (rename_tac target a b fault_handler mcp priority sc)
  apply (clarsimp simp: validE_R_def)
  apply (rule_tac B="\<lambda>_ s. (sc_not_in_release_q (cur_sc s) s
                            \<and> (\<forall>t\<in>set (release_queue s). pred_map (not is_blocked_on_reply) (tcb_sts_of s) t)
                            \<and> (\<forall>t\<in>set (release_queue s). pred_map (\<lambda>a. \<exists>y. a = Some y) (tcb_scps_of s) t)
                            \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
                           \<and> valid_machine_time s
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> current_time_bounded s
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_sufficient (consumed_time s) s)
                           \<and> (case sc of None \<Rightarrow> \<lambda>_. True
                                       | Some None \<Rightarrow> \<lambda>s. True
                                       | Some (Some scptr) \<Rightarrow> (bound_sc_tcb_at ((=) None) target)
                                                               and sc_tcb_sc_at ((=) None) scptr
                                                               and K (scptr \<noteq> idle_sc_ptr)) s
                           \<and> cur_sc s \<noteq> idle_sc_ptr"
               in hoare_vcg_seqE[rotated])
   apply (rule hoare_weaken_preE)
    apply (subst validE_R_def[symmetric])
    apply (rule hoare_vcg_conj_lift_R)
     apply wpsimp
    apply (wpsimp wp: hoare_case_option_wp install_tcb_cap_sc_tcb_sc_at)+
   apply (clarsimp split: option.splits)
   apply (intro conjI impI)
    apply (clarsimp simp: pred_tcb_at_def obj_at_def is_tcb_def)
   apply (frule invs_valid_idle)
   apply (clarsimp simp: valid_idle_def pred_tcb_at_def obj_at_def sc_at_pred_n_def)
  apply (rule hoare_seq_ext_skipE, wpsimp wp: thread_set_wp simp: set_mcpriority_def)
   apply (clarsimp split: option.splits)
   apply (fastforce simp: pred_tcb_at_def sc_at_pred_n_def obj_at_def get_tcb_def
                   split: option.splits)
  apply (rule hoare_seq_ext_skipE, wpsimp wp: hoare_case_option_wp)
   apply (clarsimp split: option.splits)

  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed"
              and E="\<top>\<top>"
               in hoare_vcg_seqE[rotated]
         ; (solves \<open>wpsimp\<close>)?)
  apply (subst liftE_validE)
  apply (clarsimp simp: maybe_sched_context_unbind_tcb_def get_tcb_obj_ref_def maybeM_def)
  apply (case_tac sc; clarsimp?, (solves \<open>wpsimp\<close>)?)
   apply wpsimp
   apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (rename_tac sc_ptr_opt)
  apply (case_tac sc_ptr_opt; clarsimp)
   apply (wpsimp wp: hoare_drop_imps)
   apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)

  apply (clarsimp simp: maybe_sched_context_bind_tcb_def)
  apply (rule hoare_seq_ext[OF _ gsc_sp])
  apply (rule hoare_when_cases; (solves \<open>wpsimp\<close>)?)
   apply wpsimp
   apply (fastforce simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply wpsimp
  apply (fastforce simp: pred_tcb_at_def sc_at_pred_n_def obj_at_def vs_all_heap_simps pred_neg_def
                         is_blocked_on_reply_def
                         cur_sc_in_release_q_imp_zero_consumed_def cur_sc_more_than_ready_def)
  done

lemma invoke_cnode_cur_sc_in_release_q_imp_zero_consumed_pred[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   invoke_cnode i
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>, -"
  unfolding invoke_cnode_def
  supply pred_neg_simp[simp del]
  apply (cases i; clarsimp)
       apply wpsimp
      apply wpsimp
     apply (clarsimp simp: validE_R_def)
     apply (rule cap_revoke_preservationE
            , (wpsimp simp: cap_delete_def | intro conjI impI)+)
  done

lemma invoke_irq_handler_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed_pred s\<rbrace>
   invoke_irq_handler iv
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (rule_tac Q="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed_pred s"
               in hoare_strengthen_post[rotated])
   apply (simp add: cur_sc_in_release_q_imp_zero_consumed_def)
  by (case_tac iv; wpsimp?)

lemma cur_sc_chargeable_cur_sc_in_release_q_imp_zero_consumed:
  "cur_sc_chargeable s
   \<Longrightarrow> valid_sched s \<Longrightarrow> ct_not_in_release_q s \<Longrightarrow> cur_sc_in_release_q_imp_zero_consumed s"
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (drule cur_sc_chargeableD[simplified tcb_at_kh_simps pred_map_eq_normalise], simp)
  apply (erule disjE)
   apply clarsimp
  apply (prop_tac "not_in_release_q t s")
   apply (erule valid_release_q_not_in_release_q_not_runnable[OF valid_sched_valid_release_q])
   apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
  apply clarsimp
  done

lemma perform_invocation_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> cur_sc_more_than_ready s
        \<and> valid_sched s \<and> valid_machine_time s
        \<and> invs s \<and> cur_sc_tcb_are_bound s
        \<and> current_time_bounded s
        \<and> ct_not_in_release_q s
        \<and> ct_active s
        \<and> cur_sc_active s
        \<and> cur_sc_tcb_are_bound s
        \<and> valid_invocation iv s
        \<and> cur_sc_offset_ready (consumed_time s) s
        \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   perform_invocation block call can_donate iv
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>, -" (is "\<lbrace>?P\<rbrace> _ \<lbrace>_\<rbrace>, -")
  apply (cases iv; simp, (solves \<open>wpsimp\<close>)?)
        apply wpsimp
        apply (fastforce dest!: invs_strengthen_cur_sc_tcb_only_sym_bound
                                cur_sc_tcb_only_sym_bound_cur_sc_not_in_release_q)
       apply (wpsimp wp: send_ipc_cur_sc_in_release_q_imp_zero_consumed)
       apply (fastforce simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps
                              receive_blocked_def)
      apply (wpsimp wp: send_signal_cur_sc_in_release_q_imp_zero_consumed)
     apply (wpsimp wp: do_reply_transfer_cur_sc_in_release_q_imp_zero_consumed)
     apply (intro conjI; fastforce?)
     apply (rule cur_sc_not_idle_sc_ptr; fastforce)
    apply wpsimp
    apply (intro conjI)
       apply (fastforce dest!: invs_strengthen_cur_sc_tcb_only_sym_bound
                               cur_sc_tcb_only_sym_bound_cur_sc_not_in_release_q)
      apply (fastforce intro!: valid_release_q_imp_not_blocked_on_reply)
     apply (fastforce intro!: valid_release_q_imp_bound_to_sc)
    apply (rule cur_sc_not_idle_sc_ptr; fastforce)
   apply wpsimp
    apply (clarsimp simp: validE_R_def)
    apply (rule_tac P'="?P"
                and Q'="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed_pred"
                and E'="\<top>\<top>"
                 in validE_weaken[rotated]; simp)
     apply wpsimp
     apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
    apply wpsimp
    apply (fastforce dest!: invs_strengthen_cur_sc_tcb_only_sym_bound
                            cur_sc_tcb_only_sym_bound_cur_sc_not_in_release_q
                    intro!: valid_release_q_imp_not_blocked_on_reply
                            valid_release_q_imp_bound_to_sc)
   apply wpsimp
  apply wpsimp
  apply (fastforce dest!: invs_strengthen_cur_sc_tcb_only_sym_bound
                          cur_sc_tcb_only_sym_bound_cur_sc_not_in_release_q
                  intro!: valid_release_q_imp_not_blocked_on_reply
                          valid_release_q_imp_bound_to_sc)
  done

crunches handle_no_fault
  for cur_sc_in_release_q_imp_zero_consumed[wp]: "cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _"

lemma handle_fault_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> valid_release_q s
        \<and> not_in_release_q thread s
        \<and> \<not> pred_map receive_blocked (tcb_sts_of s) thread\<rbrace>
   handle_fault thread ex
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_fault_def
  by (wpsimp simp: send_fault_ipc_def
               wp: send_ipc_cur_sc_in_release_q_imp_zero_consumed)

lemma ct_active_not_receive_blocked_helper:
  "ct_active s \<Longrightarrow> ct_in_state' receive_blocked s \<Longrightarrow> False"
  by (fastforce simp: ct_in_state_def vs_all_heap_simps tcb_at_kh_simps receive_blocked_def)

lemma handle_invocation_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
    \<and> cur_sc_more_than_ready s
    \<and> valid_sched s \<and> valid_machine_time s
    \<and> invs s \<and> cur_sc_tcb_are_bound s
    \<and> current_time_bounded s
    \<and> ct_not_in_release_q s
    \<and> cur_sc_active s
    \<and> ct_active s
    \<and> cur_sc_tcb_are_bound s
    \<and> cur_sc_offset_ready (consumed_time s) s
    \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>, -"
  supply if_split [split del]
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid)
         apply (wpsimp wp: hoare_drop_imp, clarsimp)
        apply (wpsimp wp: perform_invocation_cur_sc_in_release_q_imp_zero_consumed, clarsimp)
       apply (wpsimp wp: set_thread_state_runnable_valid_sched set_thread_state_ct_in_state)
      apply wpsimp
     apply (wpsimp simp: cap_cap_slot_fold)
    apply wpsimp
   apply wpsimp
  apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def runnable_eq_active
                         vs_all_heap_simps receive_blocked_def is_tcb_def
                  split: if_splits)
  done

lemma charge_budget_consumed_time_equals_zero[wp]:
  "\<lbrace>\<top>\<rbrace> charge_budget consumed canTimeout \<lbrace>\<lambda>_ s :: det_state. consumed_time s = 0\<rbrace>"
  unfolding charge_budget_def
  by (wpsimp wp: hoare_drop_imps)

lemma charge_budget_cur_sc_in_release_q_imp_zero_consumed_True[wp]:
  "\<lbrace>\<top>\<rbrace>
   charge_budget consumed canTimeout
   \<lbrace>\<lambda>_ s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def)
  apply (wpsimp wp: hoare_vcg_all_lift hoare_drop_imps)
  done

lemma check_budget_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "check_budget \<lbrace>\<lambda>s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (clarsimp simp: check_budget_def get_sc_refill_capacity_def bind_assoc)
  by wpsimp

lemma check_budget_restart_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "check_budget_restart \<lbrace>\<lambda>s :: det_state. cur_sc_in_release_q_imp_zero_consumed s\<rbrace>"
  apply (clarsimp simp: check_budget_restart_def)
  by wpsimp

lemma handle_yield_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<top>\<rbrace>
   handle_yield
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_yield_def
  by wpsimp

crunches do_nbrecv_failed_transfer, lookup_reply, schedule_tcb, test_reschedule
  for cur_sc_in_release_q_imp_zero_consumed[wp]: cur_sc_in_release_q_imp_zero_consumed
  (wp: hoare_vcg_all_lift crunch_wps)

lemma complete_signal_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed and cur_sc_more_than_ready and not_in_release_q tptr
    and current_time_bounded and ex_nonz_cap_to tptr and tcb_at tptr and invs\<rbrace>
   complete_signal ntfnptr tptr
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: complete_signal_def)
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (case_tac "ntfn_obj ntfn"; simp)
  apply (rule hoare_seq_ext_skip)
   apply (clarsimp simp: pred_conj_def)
   apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
   apply (wpsimp simp: as_user_def
                   wp: set_object_wp get_object_wp)
   apply (clarsimp simp: obj_at_def get_tcb_def)
  apply (wpsimp simp: get_tcb_obj_ref_def wp: thread_get_wp)
     apply (rule hoare_strengthen_post[where Q="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed and invs
                                                    and tcb_at tptr"])
      apply (wpsimp wp: maybe_donate_sc_cur_sc_in_release_q_imp_zero_consumed abs_typ_at_lifts)
     apply (clarsimp simp: obj_at_def)
    apply (wpsimp wp: set_ntfn_minor_invs simp: as_user_def set_object_def get_object_def)+
  apply (intro conjI impI allI)
    apply (clarsimp simp: obj_at_def is_tcb)
   apply (fastforce simp: invs_def valid_state_def valid_pspace_def valid_bound_obj_def
                          valid_obj_def valid_ntfn_def is_tcb obj_at_def is_sc_obj_def
                   elim!: valid_objsE
                   split: option.splits)
  apply (fastforce simp: invs_def valid_state_def valid_pspace_def live_def live_ntfn_def
                         tcb_cap_cases_def is_tcb obj_at_def
                 intro!: ex_cap_to_after_update
                  elim!: if_live_then_nonz_capD)
  done

lemma set_tcb_sc_Some_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed and not_in_release_q tptr\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr (Some scptr)
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
   apply (wpsimp wp: valid_sched_wp)
   by (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def vs_all_heap_simps)

lemma maybe_return_sc_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>
   maybe_return_sc ntfn_ptr tcb_ptr
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
  unfolding maybe_return_sc_def
   apply (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
   by (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def vs_all_heap_simps)

lemma set_tcb_sc_None_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed\<rbrace>
   set_tcb_obj_ref tcb_sched_context_update tptr None
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed\<rbrace>"
   apply (wpsimp wp: valid_sched_wp)
   by (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def vs_all_heap_simps)

lemma sched_context_donate_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed and not_in_release_q tptr\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  unfolding sched_context_donate_def
  by (wpsimp wp: tcb_release_remove_cur_sc_in_release_q_imp_zero_consumed get_sc_obj_ref_wp)

lemma reply_push_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed and valid_release_q and not_in_release_q caller\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  apply (wpsimp wp: get_simple_ko_wp)
            apply (rule_tac Q="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed
                                   and valid_release_q
                                   and (\<lambda>s. pred_map_eq sc_callee (tcb_scps_of s) callee)"
                   in hoare_strengthen_post[rotated])
             apply (clarsimp split: if_split simp: pred_map_eq_normalise)
             apply (frule (1) valid_release_q_no_sc_not_in_release_q, simp)
            apply (wpsimp wp: set_thread_state_valid_release_q, clarsimp)
           apply (wpsimp wp: assert_inv get_tcb_obj_ref_wp)+
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  done

lemma sorted_release_q_not_in_release_q_update:
  "\<lbrakk>tcb_at t s; not_in_release_q t s; valid_release_q s\<rbrakk>
    \<Longrightarrow>
     sorted_release_q (s\<lparr> kheap := (kheap s(t \<mapsto> TCB tcb)) \<rparr>) = sorted_release_q s"
  apply (unfold not_in_release_q_def sorted_release_q_2_def)
  apply (prop_tac "release_queue (s\<lparr>kheap := (\<lambda>x. if x = t then Some (TCB tcb) else kheap s x)\<rparr>) = release_queue s")
   apply simp
  apply (simp only: fun_upd_def[symmetric])
  apply (rule sorted_wrt_img_ord_eq_lift)
  apply (drule (1) in_release_q_has_ready_time)
  apply (clarsimp simp: obj_at_def is_tcb split: option.splits)
  by (auto intro!: map_eqI
             simp: fun_upd_def vs_all_heap_simps tcb_ready_times_defs
                   map_project_simps opt_map_simps map_join_simps
            split: if_splits)

lemma valid_release_q_not_in_release_q_update:
  "\<lbrakk>valid_release_q s; not_in_release_q t s; tcb_at t s\<rbrakk> \<Longrightarrow>
   valid_release_q (s\<lparr> kheap := (kheap s(t \<mapsto> TCB tcb)) \<rparr>) "
  apply (frule (2) sorted_release_q_not_in_release_q_update[where tcb=tcb])
  apply (clarsimp simp add: valid_release_q_def)
   by (fastforce simp: not_in_release_q_def vs_all_heap_simps)

lemma maybe_return_sc_valid_release_q[wp]:
  "\<lbrace>valid_release_q and (\<lambda>s. tp \<notin> set (release_queue s))\<rbrace>
   maybe_return_sc np tp
   \<lbrace>\<lambda>_. valid_release_q\<rbrace>"
  unfolding maybe_return_sc_def
  apply (wpsimp wp: set_tcb_obj_ref_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
  apply (frule_tac tcb="tcb_sched_context_update Map.empty tcba"
         in valid_release_q_not_in_release_q_update[simplified not_in_release_q_def])
     apply simp
    apply (clarsimp simp: obj_at_def is_tcb)
   apply clarsimp
  apply (clarsimp simp: fun_upd_def)
  done

lemma maybe_return_sc_heap_refs_inv[wp]:
  "maybe_return_sc ntfn_ptr thread \<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding maybe_return_sc_def
  apply (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
  apply (clarsimp simp: heap_refs_inv_def)
  apply (frule heap_refs_retract_heap_ref_inj[where heap="tcb_scps_of s" for s])
  by (fastforce simp: heap_refs_inv_def heap_refs_retract_def heap_refs_retract_at_def
                      heap_refs_inj_def heap_refs_inj_at_ref_def heap_refs_inj_at_def
                      pred_map_eq_def pred_map_def vs_all_heap_simps heap_upd_def obj_at_def)

lemma maybe_return_sc_st_tcb_at[wp]:
  "maybe_return_sc ntfn_ptr tcb_ptr \<lbrace>\<lambda>s. Q (st_tcb_at P t s)\<rbrace>"
  by (wpsimp wp: maybe_return_sc_pred_tcb_at)

lemma valid_release_q_ipc_queued_thread_state_not_in_release_q:
  "\<lbrakk>valid_release_q s; st_tcb_at ipc_queued_thread_state tp s\<rbrakk>
   \<Longrightarrow> not_in_release_q tp s"
  apply (erule valid_release_q_not_in_release_q_not_runnable[where t=tp])
  apply (clarsimp simp add: st_tcb_at_def obj_at_def ipc_queued_thread_state_def2)
  by (rename_tac tcb; case_tac "tcb_state tcb"; clarsimp)

lemma receive_ipc_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>cur_sc_in_release_q_imp_zero_consumed and valid_sched
    and scheduler_act_not thread and not_queued thread and not_in_release_q thread
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and cur_sc_more_than_ready and current_time_bounded
    and (\<lambda>s. thread = cur_thread s) and invs
    and st_tcb_at active thread\<rbrace>
   receive_ipc thread cap is_blocking reply_cap
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  unfolding receive_ipc_def if_cond_refill_unblock_check_def
  apply (cases cap; simp)
  apply (rule hoare_seq_ext_skip)
   apply (cases reply_cap; simp add: bind_assoc)
   apply (rule hoare_seq_ext[OF _ grt_sp])
   apply wpsimp
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep)
  apply (rule hoare_seq_ext[OF _ gbn_sp])
  apply (case_tac ep; simp; (solves \<open>wpsimp wp: get_simple_ko_wp
                                          simp: current_time_bounded_def heap_refs_inv_def\<close>)?)

    apply (find_goal \<open>match premises in "_ = IdleEP" \<Rightarrow> \<open>-\<close>\<close>)
    apply (wpsimp wp: get_simple_ko_wp complete_signal_cur_sc_in_release_q_imp_zero_consumed)
    apply (fastforce dest: invs_cur
                    intro: runnable_nonz_cap_to
                     simp: current_time_bounded_def runnable_eq_active cur_tcb_def)

   apply (find_goal \<open>match premises in "_ = RecvEP _" \<Rightarrow> \<open>-\<close>\<close>)
   apply (wpsimp wp: get_simple_ko_wp thread_get_inv hoare_drop_imps
                     complete_signal_cur_sc_in_release_q_imp_zero_consumed)
   apply (fastforce intro: runnable_nonz_cap_to simp: runnable_eq_active current_time_bounded_def)

  apply (rule hoare_seq_ext_skip, wpsimp)
   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
  apply (rule hoare_if)
   apply (wpsimp wp: refill_unblock_check_valid_release_q
                     complete_signal_cur_sc_in_release_q_imp_zero_consumed)
    apply (fastforce dest: invs_cur
                    intro: runnable_nonz_cap_to
                     simp: current_time_bounded_def runnable_eq_active cur_tcb_def)
  apply (rename_tac qs ntfn)
  apply (wpsimp wp: thread_get_wp')
              apply (rule_tac Q="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                                      \<and> valid_release_q s \<and> not_in_release_q (hd qs) s
                                      \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
                    in hoare_post_imp)
              apply clarsimp
             apply (wpsimp wp: refill_unblock_check_valid_release_q
                               complete_signal_cur_sc_in_release_q_imp_zero_consumed)
            apply (wpsimp+)[3]
          apply (wpsimp wp: get_tcb_obj_ref_wp)
         (* do_ipc_transfer *)
         apply (rule_tac Q="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s \<and> thread = cur_thread s
                                  \<and> valid_release_q s \<and> not_in_release_q (hd qs) s
                                  \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
                in hoare_post_imp)
          apply (clarsimp split: if_split option.splits)
          apply (rename_tac scp sc n t)
          apply (prop_tac "heap_ref_eq scp (hd qs) (tcb_scps_of s)")
           apply (clarsimp simp: obj_at_def vs_all_heap_simps)
          apply (drule heap_refs_inv_inv)
          apply (clarsimp simp: heap_refs_inv_def2 pred_map_eq)
         apply wpsimp
        apply wpsimp
       apply (wpsimp wp: gts_wp)
      (* set_endpoint *)
      apply (rule_tac Q="\<lambda>_ s. st_tcb_at is_blocked_on_send (hd qs) s
                               \<longrightarrow> cur_sc_in_release_q_imp_zero_consumed s \<and> thread = cur_thread s
                                   \<and> valid_release_q s \<and> not_in_release_q (hd qs) s
                                   \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
             in hoare_post_imp)
       apply (clarsimp simp: st_tcb_at_def obj_at_def)
      apply (wpsimp+)[3]
      (* maybe_return_sc *)
      apply (wpsimp wp: hoare_vcg_imp_lift')
     apply wpsimp
    apply (rule hoare_drop_imp)
    apply (wpsimp wp : hoare_vcg_imp_lift')
   apply wpsimp
  apply (clarsimp cong: conj_cong
                 split: if_splits)
  apply (frule valid_sched_valid_release_q)
  apply (fastforce simp: pred_tcb_at_def obj_at_def is_blocked_on_send_def in_release_q_def
                         valid_release_q_def vs_all_heap_simps )
  done

crunches as_user
  for valid_ntfn[wp]: "valid_ntfn ntfn"

lemma receive_signal_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> heap_refs_retract (sc_tcbs_of s) (tcb_scps_of s)
        \<and> cur_sc_more_than_ready s
        \<and> not_in_release_q thread s
        \<and> current_time_bounded s \<and> invs s \<and> thread = cur_thread s \<and> st_tcb_at runnable thread s\<rbrace>
   receive_signal thread cap is_blocking
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  unfolding receive_signal_def
  apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift)
       apply (wpsimp wp: maybe_donate_sc_cur_sc_in_release_q_imp_zero_consumed get_simple_ko_wp
                         set_ntfn_minor_invs as_user_obj_at_trivial hoare_vcg_imp_lift')+
  apply (intro conjI impI)
     apply (fastforce intro: runnable_nonz_cap_to
                       simp: runnable_eq_active)
    apply (clarsimp simp: obj_at_def)
   apply (clarsimp simp: obj_at_def)
   apply (frule invs_valid_objs)
   apply (frule valid_objs_valid_ntfn)
    apply fastforce
   apply (clarsimp simp: valid_ntfn_def valid_bound_obj_def)
  apply (rule if_live_then_nonz_capD2)
    apply fastforce
   apply (fastforce simp: obj_at_def)
  apply (clarsimp simp: live_def live_ntfn_def)
  done

lemma handle_recv_cur_sc_in_release_q_imp_zero_consumed[wp]:
  "\<lbrace>\<lambda>s. cur_sc_in_release_q_imp_zero_consumed s
        \<and> ct_active s
        \<and> valid_sched s
        \<and> invs s
        \<and> cur_sc_more_than_ready s
        \<and> current_time_bounded s
        \<and> ct_not_in_release_q s
        \<and> scheduler_act_sane s
        \<and> ct_not_queued s \<and> invs s\<rbrace>
   handle_recv is_blocking can_reply
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_recv_def Let_def
  apply (wpsimp wp: get_sk_obj_ref_wp)
     apply (rule_tac Q'="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                               \<and> valid_sched s
                               \<and> invs s\<and> thread = cur_thread s
                               \<and> cur_sc_more_than_ready s
                               \<and> current_time_bounded s
                               \<and> not_in_release_q thread s \<and> scheduler_act_not thread s \<and> not_queued thread s
                               \<and> \<not> pred_map receive_blocked (tcb_sts_of s) thread
                               \<and> heap_refs_inj_at thread (tcb_scps_of s) \<and> invs s \<and> ct_active s"
               in hoare_post_imp_R[rotated])
      apply (clarsimp simp: current_time_bounded_def valid_sched_valid_release_q ct_in_state_def
                            runnable_eq_active)
     apply wpsimp+
  apply (fastforce dest: valid_sched_valid_release_q ct_active_not_receive_blocked_helper
                         heap_refs_injD sym_refs_inj_tcb_scps invs_sym_refs)
  done

lemma cur_sc_tcb_are_bound_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrakk>cur_sc_tcb_are_bound s; sym_refs (state_refs_of s); ct_not_in_release_q s\<rbrakk>
   \<Longrightarrow> cur_sc_in_release_q_imp_zero_consumed s"
  apply (clarsimp simp: cur_sc_in_release_q_imp_zero_consumed_def vs_all_heap_simps)
  apply (prop_tac "t = cur_thread s")
   apply (frule_tac tp="cur_thread s" in sym_ref_tcb_sc; blast?)
   using sym_ref_tcb_sc apply force
  apply force
  done

method cur_sc_in_release_q_imp_zero_consumed_syscall_single for e
  = clarsimp simp: validE_R_def,
    rule_tac Q="\<lambda>s. invs s \<and> valid_sched s \<and> schact_is_rct s \<and> ct_not_queued s
                           \<and> ct_not_in_release_q s \<and> valid_machine_time s \<and> cur_sc_active s
                           \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
                           \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                           \<and> consumed_time_bounded s"
           in hoare_weaken_preE[rotated], simp,
    rule_tac B="\<lambda>_s. invs s \<and> valid_sched s \<and> schact_is_rct s \<and> ct_not_queued s
                            \<and> ct_not_in_release_q s \<and> valid_machine_time s \<and> cur_sc_active s
                            \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
                            \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                            \<and> consumed_time_bounded s \<and> current_time_bounded s"
          in hoare_vcg_seqE[rotated],
    wpsimp wp: update_time_stamp_current_time_bounded hoare_vcg_disj_lift,
    wpsimp simp: handle_call_def handle_send_def,
    ((wpsimp simp: imp_conjR
               wp: hoare_vcg_conj_lift check_budget_restart_true_cur_sc_more_than_ready
      | wp check_budget_restart_true check_budget_restart_false)+)[1],
    wpsimp wp: update_timestamp_cur_sc_in_release_q_imp_zero_consumed
         cong: conj_cong,
    (rename_tac s)?,
    prop_tac "cur_sc_tcb_are_bound s",
    rule invs_strengthen_cur_sc_tcb_are_bound, fastforce+,
    drule invs_sym_refs,
    ((intro conjI impI; blast?)?,
    (rule cur_sc_tcb_are_bound_cur_sc_in_release_q_imp_zero_consumed; fastforce?),
    (fastforce simp: runnable_eq_active ct_in_state_def pred_tcb_at_def obj_at_def
                     current_time_bounded_def)?,
    (clarsimp simp: current_time_bounded_def)?),
    fastforce?

method cur_sc_in_release_q_imp_zero_consumed_syscall_combined for e
  = clarsimp simp: validE_R_def,
    rule_tac B="\<lambda>_ s. cur_sc_in_release_q_imp_zero_consumed s
                      \<and> invs s
                      \<and> valid_sched s
                      \<and> schact_is_rct s
                      \<and> ct_not_queued s
                      \<and> ct_not_in_release_q s
                      \<and> valid_machine_time s
                      \<and> cur_sc_active s
                      \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
                      \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                      \<and> consumed_time_bounded s
                      \<and> current_time_bounded s"
          in hoare_vcg_seqE[rotated],
    wpsimp wp: update_timestamp_cur_sc_in_release_q_imp_zero_consumed
               update_time_stamp_current_time_bounded hoare_vcg_disj_lift,
    fastforce dest: invs_cur_sc_chargeableE,
    clarsimp simp: current_time_bounded_2_def,
    wpsimp wp: handle_invocation_valid_sched
               check_budget_restart_cur_sc_in_release_q_imp_zero_consumed
                check_budget_restart_true_cur_sc_more_than_ready,
    ((wpsimp simp: imp_conjR
               wp: hoare_vcg_conj_lift check_budget_restart_true_cur_sc_more_than_ready
      | wp check_budget_restart_true check_budget_restart_false
           handle_invocation_current_time_bounded)+),
    clarsimp cong: conj_cong,
    (intro conjI impI;
     (solves \<open>clarsimp simp: current_time_bounded_def schact_is_rct_def ct_in_state_def
                             pred_tcb_at_def obj_at_def\<close>)?),
    (rule invs_strengthen_cur_sc_tcb_are_bound; fastforce+),
    clarsimp simp: schedulable_def2,
    intro conjI impI,
    clarsimp simp: pred_tcb_at_def obj_at_def ct_in_state_def,
    clarsimp simp: sc_at_pred_n_def obj_at_def vs_all_heap_simps active_sc_def,
    prop_tac "cur_sc_tcb_are_bound s",
    rule invs_strengthen_cur_sc_tcb_are_bound, fastforce+,
    clarsimp simp: vs_all_heap_simps ct_in_state_def pred_tcb_at_def obj_at_def

lemma handle_event_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>\<lambda>s. invs s
        \<and> valid_sched s
        \<and> schact_is_rct s
        \<and> ct_not_queued s
        \<and> ct_not_in_release_q s
        \<and> valid_machine_time s
        \<and> cur_sc_active s
        \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
        \<and> cur_sc_offset_ready (consumed_time s) s
        \<and> consumed_time_bounded s\<rbrace>
   handle_event e
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>, -"
  apply (cases e; simp)

       subgoal for syscall
         by (case_tac syscall, simp_all;
             (cur_sc_in_release_q_imp_zero_consumed_syscall_single e)? ,
             (cur_sc_in_release_q_imp_zero_consumed_syscall_combined e)?) \<comment> \<open>takes 30 seconds or so\<close>

      apply (wpsimp wp: check_budget_restart_if_lift
                        update_timestamp_cur_sc_in_release_q_imp_zero_consumed)
      apply (fastforce dest: invs_cur_sc_chargeableE valid_sched_valid_release_q
                             ct_active_not_receive_blocked_helper
                       simp: ct_in_state_def pred_tcb_at_def obj_at_def vs_all_heap_simps
                             receive_blocked_def)
     apply (wpsimp wp: check_budget_restart_if_lift
                       update_timestamp_cur_sc_in_release_q_imp_zero_consumed)
     apply (fastforce dest: invs_cur_sc_chargeableE valid_sched_valid_release_q
                            ct_active_not_receive_blocked_helper
                      simp: ct_in_state_def pred_tcb_at_def obj_at_def vs_all_heap_simps
                            receive_blocked_def)

    subgoal \<comment>\<open>handle_interrupt\<close>
      apply (clarsimp simp: validE_R_def)
       apply (rule_tac Q="\<lambda>s. invs s \<and> valid_sched s \<and> schact_is_rct s \<and> ct_not_queued s
                              \<and> ct_not_in_release_q s \<and> valid_machine_time s \<and> cur_sc_active s
                              \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
                              \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                              \<and> consumed_time_bounded s"
                    in hoare_weaken_pre[rotated], simp)
      apply (rule hoare_seq_ext_skip, wpsimp simp: ct_in_state_def)
      apply (rule_tac B="\<lambda>_s. invs s \<and> valid_sched s \<and> schact_is_rct s \<and> ct_not_queued s
                              \<and> ct_not_in_release_q s \<and> valid_machine_time s \<and> cur_sc_active s
                              \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
                              \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
                              \<and> consumed_time_bounded s \<and> current_time_bounded s"
                   in hoare_seq_ext[rotated])
       apply (wpsimp wp: update_time_stamp_current_time_bounded hoare_vcg_disj_lift)
      apply (wpsimp wp: handle_interrupt_cur_sc_in_release_q_imp_zero_consumed)
       apply (strengthen valid_sched_active_sc_valid_refills valid_sched_valid_release_q)
       apply (wpsimp wp: hoare_drop_imp hoare_vcg_all_lift
                         check_budget_cur_sc_in_release_q_imp_zero_consumed
                         check_budget_valid_sched)
      apply (clarsimp cong: conj_cong)
      apply (prop_tac "cur_sc_tcb_are_bound s")
       apply (rule invs_strengthen_cur_sc_tcb_are_bound, fastforce+)
      apply (intro conjI impI; blast?)
         apply (rule cur_sc_tcb_are_bound_cur_sc_in_release_q_imp_zero_consumed; assumption?)
         apply (erule invs_sym_refs)
        apply (erule schact_is_rct_sane)
       apply (rule invs_cur_sc_chargeableE; assumption?)
      apply (rule ct_not_blocked_cur_sc_not_blocked)
       apply (rule invs_cur_sc_chargeableE; assumption?)
      apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def)
      done

   apply (wpsimp wp: check_budget_restart_if_lift
                     update_timestamp_cur_sc_in_release_q_imp_zero_consumed)
   apply (fastforce dest: invs_cur_sc_chargeableE valid_sched_valid_release_q
                          ct_active_not_receive_blocked_helper
                    simp: ct_in_state_def pred_tcb_at_def obj_at_def vs_all_heap_simps
                          receive_blocked_def)

  \<comment> \<open>handle_hypervisor_fault\<close>
  apply wpsimp
  apply (prop_tac "cur_sc_tcb_are_bound s")
   apply (rule invs_strengthen_cur_sc_tcb_are_bound; fastforce?)
  apply (intro conjI impI)
    apply (rule cur_sc_tcb_are_bound_cur_sc_in_release_q_imp_zero_consumed; assumption?)
    apply (erule invs_sym_refs)
   apply (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def)
  apply fastforce
  done

lemma handle_no_fault_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. thread = cur_thread s\<rbrace>
   handle_no_fault thread
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding handle_no_fault_def
  by (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong)

lemma handle_fault_ct_ready_if_schedulable_not_blocked_on_receive:
  "\<lbrace>(\<lambda>s. thread = cur_thread s)
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and ct_not_blocked_on_receive\<rbrace>
   handle_fault thread ft
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_fault_def send_fault_ipc_def
  by (wpsimp wp: send_ipc_ct_ready_if_schedulable_not_blocked_on_receive
                 thread_set_fault_fault_tcb_at thread_set_ct_in_state)

lemma handle_fault_ct_ready_if_schedulable_released_if_bound:
  "\<lbrace>(\<lambda>s. thread = cur_thread s)
    and released_ipc_queues
    and (\<lambda>s. released_if_bound_sc_tcb_at (cur_thread s) s)\<rbrace>
   handle_fault thread ft
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_fault_def send_fault_ipc_def
  by (wpsimp wp: send_ipc_ct_ready_if_schedulable_released_if_bound
                 thread_set_fault_fault_tcb_at thread_set_fault_released_ipc_queues)

crunches test_possible_switch_to, update_restart_pc
  for ct_ready_if_schedulable[wp]: ct_ready_if_schedulable

lemma sched_context_resume_ct_ready_if_schedulable_two:
  "\<lbrace>\<lambda>s. if (sc_tcb_sc_at (\<lambda>x. x = Some (cur_thread s)) scp s)
        then heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
        else ct_ready_if_schedulable s\<rbrace>
   sched_context_resume scp
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding sched_context_resume_def
  apply (wpsimp wp: postpone_ct_ready_if_schedulable thread_get_wp' is_schedulable_wp
             split: if_splits)
  apply (prop_tac "bound_sc_tcb_at (\<lambda>x. x = Some scp) (cur_thread s) s")
   apply (clarsimp simp: tcb_at_kh_simps sc_at_kh_simps heap_refs_inv_def2 pred_map_eq_normalise)
  by (auto simp: ct_ready_if_schedulable_def obj_at_def schedulable_def2 vs_all_heap_simps
                 tcb_at_kh_simps sc_at_kh_simps)

lemma restart_ct_ready_if_schedulable:
  "\<lbrace>\<lambda>s. budget_ready (cur_thread s) s\<rbrace>
   restart thread
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding restart_def if_cond_refill_unblock_check_def
  apply (wpsimp wp: maybeM_inv)
       apply (wpsimp wp: sched_context_resume_ct_ready_if_schedulable)

  apply (wpsimp wp: maybeM_wp)
      apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong)
     apply (rule_tac Q="\<lambda>_ s. budget_ready (cur_thread s) s" in hoare_post_imp)
      apply (fastforce simp: ct_ready_if_schedulable_def)
     apply (wpsimp wp: gts_wp)+
  apply (clarsimp simp: ct_ready_if_schedulable_def)
  done

lemma sched_context_cancel_yield_to_ct_ready_if_schedulable[wp]:
  "sched_context_cancel_yield_to thread \<lbrace>ct_ready_if_schedulable\<rbrace>"
  apply (clarsimp simp: sched_context_cancel_yield_to_def)
  by (wpsimp wp: get_tcb_obj_ref_wp)

lemma suspend_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. thread \<noteq> cur_thread s \<longrightarrow> ct_ready_if_schedulable s\<rbrace>
   suspend thread
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  supply if_split [split del]
  unfolding suspend_def
  apply wpsimp
        apply (fold ct_in_state_kh_simp)
        apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_if_lift2 set_thread_state_ct_st
                          set_thread_state_ct_ready_if_schedulable_strong)
       apply clarsimp
       apply (wpsimp wp: hoare_vcg_imp_lift')
      apply wpsimp
   apply (rule_tac Q="\<lambda>_ s. thread \<noteq> cur_thread s \<longrightarrow> ct_ready_if_schedulable s"
          in hoare_post_imp, simp)
   apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
  apply simp
  done

lemma bind_notification_ct_ready_if_schedulable[wp]:
  "bind_notification tcbptr ntfnptr \<lbrace>ct_ready_if_schedulable\<rbrace>"
  unfolding bind_notification_def
  by wpsimp

crunches suspend, unbind_from_sc
  for released_if_bound[wp]: "released_if_bound_sc_tcb_at t"
  (wp: crunch_wps hoare_vcg_all_lift ignore: update_sched_context set_tcb_obj_ref)

crunches deleting_irq_handler
  for released_if_bound[wp]: "released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _"

(*FIXME RT: move everything from here to the next comment*)
lemma set_ntfn_obj_ref_no_change_ntfn_at_pred_gen:
  assumes "\<And>obj. P (f (\<lambda>_. new) obj) = P obj"
  shows "set_ntfn_obj_ref f ref' new \<lbrace>\<lambda>s. Q (ntfn_at_pred P ref s)\<rbrace>"
  apply (wpsimp simp: update_sk_obj_ref_def simple_obj_at_def obj_at_def
                  wp: set_simple_ko_wp get_simple_ko_wp)
  apply (clarsimp simp: assms)
  done

lemmas set_ntfn_obj_ref_no_change_ntfn_at_pred = set_ntfn_obj_ref_no_change_ntfn_at_pred_gen[where Q="\<lambda>x. x"]

lemma unbind_maybe_notification_ntfn_q_refs_of[wp]:
  "unbind_maybe_notification ntfnptr
   \<lbrace>ntfn_at_pred (\<lambda>ntfn. P (ntfn_q_refs_of (ntfn_obj ntfn))) ptr\<rbrace>"
  unfolding unbind_maybe_notification_def
  by (wpsimp wp: set_ntfn_obj_ref_no_change_ntfn_at_pred get_sk_obj_ref_wp)

lemma sched_context_maybe_unbind_ntfn_ntfn_q_refs_of[wp]:
  "sched_context_maybe_unbind_ntfn ntfnptr
   \<lbrace>ntfn_at_pred (\<lambda>ntfn. P (ntfn_q_refs_of (ntfn_obj ntfn))) ptr\<rbrace>"
  unfolding sched_context_maybe_unbind_ntfn_def
  by (wpsimp wp: set_ntfn_obj_ref_no_change_ntfn_at_pred get_sk_obj_ref_wp)

lemma suspend_st_tcb_at_other:
  "\<lbrace>st_tcb_at P t and K (t \<noteq> thread)\<rbrace>
   suspend thread
   \<lbrace>\<lambda>_. st_tcb_at P t\<rbrace>"
  unfolding suspend_def sched_context_cancel_yield_to_def
  by (wpsimp wp: sts_st_tcb_at_other get_tcb_obj_ref_wp hoare_vcg_all_lift
                 hoare_drop_imps cancel_ipc_st_tcb_at_different_thread)

lemma suspend_st_tcb_at_halted:
  "\<lbrace>st_tcb_at (\<lambda>ts. P ts \<or> halted ts) t and valid_objs\<rbrace>
   suspend thread
   \<lbrace>\<lambda>yb s. st_tcb_at (\<lambda>ts. P ts \<or> halted ts) t s\<rbrace>"
  apply (cases "t = thread")
   apply (wpsimp wp: hoare_disjI2 suspend_makes_halted
               simp: pred_disj_def pred_tcb_at_disj)
  apply (wpsimp wp: suspend_st_tcb_at_other)
  done

lemma suspend_not_ipc_queued_thread[wp]:
  "\<lbrace>st_tcb_at (not ipc_queued_thread_state) t and valid_objs\<rbrace>
   suspend thread
   \<lbrace>\<lambda>_. st_tcb_at (not ipc_queued_thread_state) t\<rbrace>"
  apply (wp_pre, rule hoare_strengthen_post)
    apply (rule suspend_st_tcb_at_halted[where P=active])
   apply (erule pred_tcb_weakenE)
   apply (fastforce simp: pred_neg_def split: thread_state.splits)
  apply (clarsimp, erule pred_tcb_weakenE)
  apply (fastforce simp: pred_neg_def split: thread_state.splits)
  done

crunches unbind_from_sc, sched_context_zero_refill_max
  for st_tcb_at[wp]: "st_tcb_at P t"
  (wp: crunch_wps hoare_vcg_all_lift)
(*FIXME RT: move everything between the previous comment and this one*)

lemma finalise_cap_not_ipc_queued_thread[wp]:
  "\<lbrace>st_tcb_at (not ipc_queued_thread_state) t and invs\<rbrace>
   finalise_cap cap final
   \<lbrace>\<lambda>_. st_tcb_at (not ipc_queued_thread_state) t :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split[split del] pred_neg_def[simp]
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
      apply (wpsimp wp: cancel_all_ipc_st_tcb_at' split: if_split)
     apply (wpsimp wp: cancel_all_signals_st_tcb_at' hoare_vcg_imp_lift' split: if_split)
    apply (wpsimp wp: gts_wp get_simple_ko_wp reply_remove_released_if_bound_other
                      cancel_ipc_st_tcb_at_not_blocked
               split: if_split)
   apply (wpsimp wp: suspend_not_ipc_queued_thread[simplified pred_neg_def])
   apply (fastforce split: if_split)
  apply (wpsimp wp: deleting_irq_handler_st_tcb_at)
  done

lemma cap_delete_not_ipc_queued_thread[wp]:
  "\<lbrace>st_tcb_at (not ipc_queued_thread_state) t and invs\<rbrace>
   cap_delete slot
   \<lbrace>\<lambda>_. st_tcb_at (not ipc_queued_thread_state) t :: det_state \<Rightarrow> _\<rbrace>" (is "\<lbrace>?P\<rbrace> _ \<lbrace>_\<rbrace>")
  unfolding cap_delete_def
  apply (rule_tac Q="K ?P" in hoare_post_imp, simp)
  by (wpsimp wp: rec_del_invs''_CTEDeleteCall preemption_point_inv
      | fastforce simp: pred_tcb_at_def obj_at_def)+

lemma install_tcb_cap_not_ipc_queued_thread[wp]:
  "\<lbrace>st_tcb_at (not ipc_queued_thread_state) t and invs\<rbrace>
   install_tcb_cap target slot n slot_opt
   \<lbrace>\<lambda>_. st_tcb_at (not ipc_queued_thread_state) t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_drop_imp thread_set_not_state_valid_sched
      | fastforce simp: pred_tcb_weakenE)+

lemma finalise_cap_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and st_tcb_at (not ipc_queued_thread_state) t
    and (\<lambda>s. \<exists>slot. cte_wp_at ((=) cap) slot s) and invs
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   finalise_cap cap final
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split[split del]
  apply (case_tac cap; (solves \<open>wpsimp\<close>)?; simp)
     apply ((wpsimp split: if_split)+)[2]
   apply (wpsimp wp: gts_wp get_simple_ko_wp reply_remove_released_if_bound_other)
   apply (fastforce simp: pred_tcb_at_def obj_at_def pred_neg_def split: if_split)
  apply (wpsimp wp: sched_context_zero_refill_max_released_if_bound_other)
  apply (fastforce simp: invs_def valid_state_def cap_range_def
                  dest!: valid_global_refsD split: if_split)
  done

lemma update_time_stamp_released_if_bound_sc_tcb_at[wp]:
 "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> valid_machine_time s\<rbrace>
  preemption_point
  \<lbrace>\<lambda>_ s :: det_state. released_if_bound_sc_tcb_at t s\<rbrace>"
  apply (wpsimp simp: preemption_point_def
                  wp: hoare_drop_imps OR_choiceE_weak_wp)
  done

lemma preemption_point_pred_tcb_at[wp]:
  "preemption_point \<lbrace>pred_tcb_at proj test ptr\<rbrace>"
  apply (wpsimp wp: preemption_point_inv)
  done

crunches finalise_cap
  for active_sc_valid_refills[wp]: "active_sc_valid_refills :: det_state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps ignore: sched_context_zero_refill_max)

lemma cap_delete_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and st_tcb_at (not ipc_queued_thread_state) t
    and current_time_bounded and active_sc_valid_refills
    and valid_machine_time and invs\<rbrace>
   cap_delete slot
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>" (is "\<lbrace>?P and invs\<rbrace> _ \<lbrace>_\<rbrace>")
  unfolding cap_delete_def
  supply pred_neg_simp[simp del]
  apply (rule_tac Q="\<lambda>_. ?P and invs" in hoare_post_imp, simp)
   apply (wpsimp wp: rec_del_invs''_CTEDeleteCall[where Q="?P", simplified])
  done

lemma install_tcb_frame_cap_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and st_tcb_at (not ipc_queued_thread_state) t
    and valid_machine_time and invs
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   install_tcb_frame_cap target slot buffer
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_frame_cap_def
  by (wpsimp wp: check_cap_inv hoare_drop_imp thread_set_not_state_valid_sched
      | fastforce simp: pred_tcb_weakenE)+

lemma install_tcb_cap_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and st_tcb_at (not ipc_queued_thread_state) t
    and valid_machine_time and invs
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   install_tcb_cap target slot n slot_opt
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  unfolding install_tcb_cap_def
  by (wpsimp wp: check_cap_inv hoare_drop_imp thread_set_not_state_valid_sched
      | fastforce simp: pred_tcb_weakenE)+

lemma maybe_sched_context_unbind_tcb_released_if_bound[wp]:
  "maybe_sched_context_unbind_tcb target \<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s\<rbrace>"
  unfolding maybe_sched_context_unbind_tcb_def
  by (wpsimp wp: hoare_drop_imp)

lemma sched_context_bind_tcb_released_if_bound[wp]:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> tcb_ptr \<noteq> t \<and> active_sc_valid_refills s\<rbrace>
   sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding sched_context_bind_tcb_def if_cond_refill_unblock_check_def
  apply (wpsimp wp: valid_sched_wp is_schedulable_wp)
      apply (rule_tac Q="\<lambda>_. released_if_bound_sc_tcb_at t" in hoare_post_imp)
       apply clarsimp
      apply wpsimp
     apply (wp update_sched_context_wp)
    apply (rule_tac Q="\<lambda>_. released_if_bound_sc_tcb_at t and active_sc_valid_refills" in hoare_post_imp)
     apply clarsimp
    apply wpsimp
   apply (wp set_tcb_sched_context_valid_sched_pred)
  apply (auto simp: obj_at_def vs_all_heap_simps pred_map_eq_def pred_map_def map_join_def opt_map_def
             split: if_splits option.splits)
  done

lemma maybe_sched_context_bind_tcb_released_if_bound[wp]:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at t s \<and> tcb_ptr \<noteq> t \<and> active_sc_valid_refills s\<rbrace>
   maybe_sched_context_bind_tcb sc_ptr tcb_ptr
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding maybe_sched_context_bind_tcb_def
  by (wpsimp wp: hoare_drop_imp hoare_vcg_if_lift2)

crunches install_tcb_frame_cap, maybe_sched_context_bind_tcb, maybe_sched_context_unbind_tcb
  for cur_thread[wp]: "\<lambda>s. P (cur_thread s)"
  (wp: check_cap_inv crunch_wps)

lemma ct_ready_if_schedulable_streng[elim!]:
  "released_if_bound_sc_tcb_at (cur_thread s) s \<Longrightarrow> ct_ready_if_schedulable s"
  unfolding ct_ready_if_schedulable_def
  by (clarsimp simp: vs_all_heap_simps)

lemma ct_ready_if_schedulable_streng2[elim!]:
  "ct_released s \<Longrightarrow> ct_ready_if_schedulable s"
  unfolding ct_ready_if_schedulable_def
  by (clarsimp simp: vs_all_heap_simps)

lemma ct_ready_if_schedulable_streng3[elim!]:
  "ct_released s \<Longrightarrow> budget_ready (cur_thread s) s"
  unfolding ct_ready_if_schedulable_def
  by (clarsimp simp: vs_all_heap_simps)

lemma sched_context_zero_refill_max_active_sc_valid_refills[wp]:
  "sched_context_zero_refill_max scp \<lbrace>active_sc_valid_refills\<rbrace>"
  unfolding sched_context_zero_refill_max_def
  apply (wpsimp wp: update_sched_context_wp)
  apply (clarsimp simp: active_sc_valid_refills_def vs_all_heap_simps active_sc_def)
  done

crunches finalise_cap
  for active_sc_valid_refills[wp]: "active_sc_valid_refills :: det_state \<Rightarrow> _"
  (wp: crunch_wps simp: crunch_simps)

lemma cap_delete_active_sc_valid_refills[wp]:
  "\<lbrace>active_sc_valid_refills and current_time_bounded and valid_machine_time and invs\<rbrace>
   cap_delete slot
   \<lbrace>\<lambda>_. active_sc_valid_refills :: det_state \<Rightarrow> _\<rbrace>" (is "\<lbrace>?P\<rbrace> _ \<lbrace>_\<rbrace>")
  unfolding cap_delete_def
  apply (rule_tac Q="K ?P" in hoare_post_imp, simp)
  apply (wpsimp wp: rec_del_invs''_CTEDeleteCall
                      [where Q="active_sc_valid_refills and current_time_bounded and valid_machine_time", simplified]
         | fastforce simp: pred_tcb_at_def obj_at_def)+
  done

crunches cap_delete, install_tcb_cap
for active_sc_valid_refills[wp]: "active_sc_valid_refills :: det_ext state \<Rightarrow> _"
  (wp: crunch_wps check_cap_inv preemption_point_inv simp: crunch_simps ignore: preemption_point)

lemma invoke_tcb_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_released and ct_active and tcb_inv_wf iv and valid_machine_time and invs
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s)
    and current_time_bounded and active_sc_valid_refills\<rbrace>
   invoke_tcb iv
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del] pred_neg_simp[simp del]
  apply (cases iv; simp)
          subgoal
          apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' restart_ct_ready_if_schedulable)
          by fastforce
         subgoal
         apply wpsimp
         by (frule ct_ready_if_schedulable_streng2, clarsimp split: if_split)
        subgoal
        apply (wpsimp wp: mapM_x_inv_wp hoare_vcg_if_lift2 hoare_vcg_imp_lift' suspend_ct_in_state restart_ct_ready_if_schedulable)
        by (frule ct_ready_if_schedulable_streng2, clarsimp split: if_split)
       subgoal
       apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at (cur_thread s) s" in hoare_strengthen_post[rotated])
        apply (clarsimp simp: ct_ready_if_schedulable_def vs_all_heap_simps)
       apply (rule_tac hoare_weaken_pre)
        apply (rule hoare_lift_Pf2[where f = cur_thread, rotated])
         apply wpsimp
        apply wpsimp
           apply invoke_tcb_install_tcb_cap_helper+
        apply simp
        apply (strengthen tcb_cap_valid_ep_strgs)
        apply (clarsimp cong: conj_cong)
        apply (intro conjI impI;
               clarsimp simp: is_cnode_or_valid_arch_is_cap_simps tcb_ep_slot_cte_wp_ats
                              real_cte_at_cte ct_in_state_def
                       dest!: is_valid_vtable_root_is_arch_cap)
           apply (all \<open>clarsimp simp: is_cap_simps cte_wp_at_caps_of_state valid_fault_handler_def\<close>)
          apply (all \<open>clarsimp simp: obj_at_def is_tcb typ_at_eq_kheap_obj cap_table_at_typ\<close>)
          by auto
      subgoal for target slot fault_handler mcp priority sc
      apply (rule_tac Q="\<lambda>_ s. released_if_bound_sc_tcb_at (cur_thread s) s" in hoare_strengthen_post[rotated])
       apply (clarsimp simp: ct_ready_if_schedulable_def vs_all_heap_simps)
      apply wp_pre
       apply (rule hoare_lift_Pf2[where f = cur_thread, rotated])
        apply wpsimp
       apply wpsimp
       apply (rule_tac Q'="\<lambda>_ s. (sc \<noteq> None \<longrightarrow> target \<noteq> x) \<and> released_if_bound_sc_tcb_at x s
                                \<and> active_sc_valid_refills s"
              in hoare_post_imp_R[rotated])
        apply clarsimp
       apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
      apply (clarsimp simp: ct_in_state_def st_tcb_at_active_not_ipc_queued_thread)
      apply (case_tac y; clarsimp)
      apply (clarsimp simp: vs_all_heap_simps tcb_at_kh_simps)
      done
     apply wpsimp
    apply (wpsimp wp: restart_ct_ready_if_schedulable)
   subgoal for a b
   by (case_tac b; wpsimp)
  apply wpsimp
  done

lemma refill_update_budget_ready:
  "\<lbrace>budget_ready t and K (budget \<ge> MIN_BUDGET) and current_time_bounded\<rbrace>
   refill_update sc_ptr period budget mrefills
   \<lbrace>\<lambda>rv. budget_ready t\<rbrace>"
  unfolding budget_ready_def2
  apply (wpsimp wp: hoare_vcg_ex_lift)
  done

lemma refill_update_not_active[wp]:
  "\<lbrace>\<lambda>s. \<not> active_sc_tcb_at t s \<and> (bound_sc_tcb_at (\<lambda>x. x = Some (sc_ptr)) t s \<longrightarrow> mrefills = 0)\<rbrace>
    refill_update sc_ptr period budget mrefills
  \<lbrace>\<lambda>_ s. \<not> active_sc_tcb_at t s\<rbrace>"
  unfolding active_sc_tcb_at_def2
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
  by (clarsimp simp: active_sc_def)

lemma refill_new_not_active[wp]:
  "\<lbrace>\<lambda>s. \<not> active_sc_tcb_at t s \<and> (bound_sc_tcb_at (\<lambda>x. x = Some (sc_ptr)) t s \<longrightarrow> max_refills = 0)\<rbrace>
    refill_new sc_ptr max_refills budget period
  \<lbrace>\<lambda>_ s. \<not> active_sc_tcb_at t s\<rbrace>"
  unfolding active_sc_tcb_at_def2
  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
  by (clarsimp simp: active_sc_def)

lemma refill_update_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and current_time_bounded and K (budget \<ge> MIN_BUDGET)
    and (\<lambda>s. pred_map (\<lambda>x. x = Some sc_ptr) (tcb_scps_of s) (cur_thread s) \<and>
          0 < max_refills \<and> ct_not_in_release_q s \<longrightarrow> budget_ready (cur_thread s) s)\<rbrace>
   refill_update sc_ptr period budget max_refills
   \<lbrace>\<lambda>rv. ct_ready_if_schedulable\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (rule_tac Q="\<lambda>_ s.
            \<forall>t. t = cur_thread s
                \<longrightarrow> active_sc_tcb_at t s
                    \<and> st_tcb_at runnable t s
                    \<and> not_in_release_q t s
                \<longrightarrow> budget_ready t s" in hoare_strengthen_post)
    apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_update_budget_ready)
   apply (clarsimp simp: ct_ready_if_schedulable_def tcb_at_kh_simps)
  apply (clarsimp simp: ct_ready_if_schedulable_def tcb_at_kh_simps)
  done

lemma refill_new_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and current_time_bounded\<rbrace>
   refill_new sc_ptr max_refills budget period
   \<lbrace>\<lambda>rv. ct_ready_if_schedulable\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (rule_tac Q="\<lambda>_ s.
            \<forall>t. t = cur_thread s
                \<longrightarrow> active_sc_tcb_at t s
                    \<and> st_tcb_at runnable t s
                    \<and> not_in_release_q t s
                \<longrightarrow> budget_ready t s" in hoare_strengthen_post)
    apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' refill_new_budget_ready)
   apply (clarsimp simp: ct_ready_if_schedulable_def tcb_at_kh_simps)
  apply (clarsimp simp: ct_ready_if_schedulable_def tcb_at_kh_simps vs_all_heap_simps)
  done

lemma refill_budget_check_round_robin_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. bound_sc_tcb_at (\<lambda>a. a = Some (cur_sc s)) (cur_thread s) s
        \<and> current_time_bounded s
        \<and> cur_sc_offset_ready consumed s
        \<and> cur_sc_offset_sufficient consumed s \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   refill_budget_check_round_robin consumed
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding ct_ready_if_schedulable_def
  apply (wpsimp wp: hoare_vcg_imp_lift')
   apply (rule hoare_lift_Pf2[where f=cur_thread])
    apply (clarsimp simp: budget_ready_def2)
    apply (wpsimp wp: hoare_vcg_ex_lift refill_budget_check_round_robin_refill_ready_offset_ready_and_sufficient)
   apply wpsimp
  by fastforce

lemma refill_budget_check_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. valid_refills (cur_sc s) s \<and> bound_sc_tcb_at (\<lambda>a. a = Some (cur_sc s)) (cur_thread s) s
        \<and> current_time_bounded s
        \<and> cur_sc_offset_ready consumed s
        \<and> cur_sc_offset_sufficient consumed s \<and> cur_sc s \<noteq> idle_sc_ptr\<rbrace>
   refill_budget_check consumed
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding ct_ready_if_schedulable_def
  apply (wpsimp wp: hoare_vcg_imp_lift')
   apply (rule hoare_lift_Pf2[where f=cur_thread])
    apply (clarsimp simp: budget_ready_def2)
    apply (wpsimp wp: hoare_vcg_ex_lift refill_budget_check_refill_ready_offset_ready_and_sufficient)
   apply wpsimp
  by fastforce

lemma commit_time_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. ct_ready_if_schedulable s \<and>
        valid_refills (cur_sc s) s \<and> bound_sc_tcb_at (\<lambda>a. a = Some (cur_sc s)) (cur_thread s) s \<and>
        current_time_bounded s \<and>
        cur_sc_offset_ready (consumed_time s) s \<and>
        cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   commit_time
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding commit_time_def
  apply (wpsimp wp: gts_wp assert_inv is_round_robin_wp)
  done

lemma ct_ready_if_schedulableE:
  "ct_ready_if_schedulable s \<Longrightarrow> active_sc_tcb_at (cur_thread s) s \<and> ct_active s \<and> ct_not_in_release_q s \<Longrightarrow> budget_ready (cur_thread s) s"
  by (clarsimp simp: ct_ready_if_schedulable_def ct_in_state_def tcb_at_kh_simps runnable_eq_active)

crunches commit_time, tcb_sched_action
  for sc_tcbs_of[wp]: "\<lambda>s. P (sc_tcbs_of s)"
  (ignore: update_sched_context wp: crunch_wps)

lemma invoke_sched_control_configure_flags_ct_ready_if_schedulable[wp]:
  "\<lbrace>(\<lambda>s. cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s)
    and active_sc_valid_refills
    and cur_sc_active
    and schact_is_rct
    and invs
    and current_time_bounded
    and valid_sched_control_inv iv and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   invoke_sched_control_configure_flags iv
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  supply if_split [split del]
  unfolding invoke_sched_control_configure_flags_def
  apply (case_tac iv; clarsimp)
  apply (rename_tac sc_ptr budget period mrefills badge flags)
  apply (subst bind_assoc[symmetric])
  apply (wpsimp wp: sched_context_resume_ct_ready_if_schedulable)
       apply (wpsimp wp: gts_wp)
      apply (wpsimp wp: gts_wp)
     apply (wpsimp wp: gts_wp)
     apply (rule_tac Q="\<lambda>_ s. ct_ready_if_schedulable s
                              \<and> current_time_bounded s
                              \<and> MIN_BUDGET \<le> budget
                              \<and> (sc_active sc \<longrightarrow> is_active_sc sc_ptr s)
                              \<and> (sc_tcb_sc_at ((=) (sc_tcb sc)) sc_ptr s)
                              \<and> invs s \<and> cur_sc s \<noteq> idle_sc_ptr"
            in hoare_post_imp)
      apply (clarsimp simp: current_time_bounded_def)
      apply (subgoal_tac "y = cur_thread s")
       apply (erule ct_ready_if_schedulableE)
       apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps ct_in_state_def sc_at_kh_simps sc_at_pred_n_def obj_at_def
                             active_sc_def runnable_eq_active pred_map_eq_normalise)
      apply (clarsimp simp: pred_map_eq_normalise)
      apply (frule (1) heap_refs_retractD[OF heap_refs_inv_retract_symD[OF sym_refs_inv_sc_tcbs[OF invs_sym_refs]], rotated])
      apply (clarsimp simp: vs_all_heap_simps sc_at_kh_simps)
     apply (wpsimp wp: valid_sched_wp hoare_vcg_imp_lift' commit_time_invs hoare_vcg_all_lift)+
    apply (rule_tac Q="\<lambda>_ s. valid_refills (cur_sc s) s
                             \<and> bound_sc_tcb_at (\<lambda>a. a = Some (cur_sc s)) (cur_thread s) s
                             \<and> current_time_bounded s
                             \<and> cur_sc_chargeable s \<and> invs s
                             \<and> (sc_active sc \<longrightarrow> is_active_sc sc_ptr s)
                             \<and> sc_tcb_sc_at ((=) (sc_tcb sc)) sc_ptr s
                             \<and> cur_sc_offset_ready (consumed_time s) s
                             \<and> cur_sc_offset_sufficient (consumed_time s) s
                             \<and> MIN_BUDGET \<le> budget \<and> cur_sc s \<noteq> idle_sc_ptr"
           in hoare_post_imp)
    apply (subgoal_tac "budget_ready (cur_thread s) s")
     apply (fastforce simp: ct_ready_if_schedulable_def current_time_bounded_def split: if_split)
    apply (clarsimp simp: tcb_at_kh_simps pred_map_eq_normalise)
    apply (rule cur_sc_tcb_bound_ready; fastforce)
   apply (wpsimp wp: update_sc_badge_invs' update_sc_sporadic_invs' simp: sc_at_kh_simps)+
  apply (subgoal_tac "cur_sc_chargeable s", simp)
   apply (intro conjI)
       apply (erule (1) active_sc_valid_refillsE)
      apply (erule (1) invs_cur_sc_tcb_symref)
     apply (erule (1) ex_nonz_cap_to_not_idle_sc_ptr)
    apply (fastforce simp: vs_all_heap_simps obj_at_def)+
  apply (erule (1) invs_cur_sc_chargeableE)
  done

lemma restart_thread_if_no_fault_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. ct_ready_if_schedulable s \<and> t \<noteq> cur_thread s\<rbrace>
   restart_thread_if_no_fault t
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  unfolding restart_thread_if_no_fault_def if_cond_refill_unblock_check_def
  by (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong thread_get_wp' get_tcb_obj_ref_wp
                 hoare_vcg_all_lift hoare_drop_imp)

crunches invoke_cnode
  for cur_thread[wp]: "(\<lambda>s. P (cur_thread s))"
  (wp: crunch_wps cap_revoke_preservation preemption_point_inv filterM_preserved)

lemma cancel_badged_sends_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and current_time_bounded and active_sc_valid_refills\<rbrace>
   cancel_badged_sends epptr badge
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t\<rbrace>"
  unfolding cancel_badged_sends_def
  apply wpsimp
      apply (rule hoare_strengthen_post[where Q="\<lambda>_. released_if_bound_sc_tcb_at t
                                                     and active_sc_valid_refills and current_time_bounded"])
  by (wpsimp wp: filterM_preserved gts_wp get_simple_ko_wp)+

lemma preemption_point_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and valid_machine_time\<rbrace>
   preemption_point
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: preemption_point_def
                  wp: hoare_drop_imps OR_choiceE_weak_wp)
  done

lemma invoke_cnode_released_if_bound[wp]:
  "\<lbrace>released_if_bound_sc_tcb_at t and st_tcb_at active t and valid_machine_time
    and current_time_bounded and active_sc_valid_refills and invs\<rbrace>
   invoke_cnode i
   \<lbrace>\<lambda>_. released_if_bound_sc_tcb_at t :: det_state \<Rightarrow> _\<rbrace>" (is "\<lbrace>?P active\<rbrace> _ \<lbrace>_\<rbrace>")
  supply if_split [split del] pred_neg_simp[simp del]
  unfolding invoke_cnode_def
  apply (cases i; (solves \<open>wpsimp\<close>)?; simp)
   apply (rule_tac Q="\<lambda>_. ?P (not ipc_queued_thread_state)" in hoare_post_imp, simp)
   apply (wpsimp wp: cap_revoke_preservation | wpsimp wp: preemption_point_inv)+
  apply (clarsimp split: if_split simp: current_time_bounded_def)
  done

lemma perform_unsafe_invocation_ct_ready_if_schedulable:
  "\<lbrace>ct_released and invs and valid_sched and valid_machine_time and ct_active and valid_invocation i
    and schact_is_rct and K (\<not>safe_invocation i)
    and current_time_bounded
    and cur_sc_active
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s)
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s) and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_ s :: det_state. ct_ready_if_schedulable s\<rbrace>"
  apply (cases i; simp)
      apply wpsimp
      apply (clarsimp dest!: valid_sched_active_sc_valid_refills simp: current_time_bounded_def)
     apply wpsimp
    apply (strengthen ct_ready_if_schedulable_streng)
    apply (wp_pre, rule hoare_lift_Pf2[where f=cur_thread, rotated])
      apply (wpsimp, wpsimp, clarsimp simp: ct_in_state_def)
   apply wpsimp
  apply (strengthen ct_ready_if_schedulable_streng)
  apply (wp_pre, rule hoare_lift_Pf2[where f=cur_thread, rotated])
  apply (wpsimp, wpsimp, clarsimp simp: ct_in_state_def)
  done

(*FIXME RT: move*)
crunches perform_invocation
  for cur_thread[wp]: "\<lambda>s :: det_state. P (cur_thread s)"
  (wp: check_cap_inv crunch_wps cap_revoke_preservation filterM_preserved)

lemma perform_invocation_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_released and invs and valid_sched and valid_machine_time and ct_active and valid_invocation i
    and schact_is_rct
    and current_time_bounded
    and cur_sc_active
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s)
    and (\<lambda>s. bound_sc_tcb_at bound (cur_thread s) s) and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   perform_invocation block call can_donate i
   \<lbrace>\<lambda>_ s :: det_state. ct_ready_if_schedulable s\<rbrace>"
  apply (case_tac "safe_invocation i")
   apply (strengthen ct_ready_if_schedulable_streng)
   apply (rule_tac Q="\<lambda>_ s. \<forall>t. t = cur_thread s \<longrightarrow> released_if_bound_sc_tcb_at t s"
          in hoare_post_imp, clarsimp)
   apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' perform_invocation_first_phase_released_if_bound)
   apply (clarsimp simp: ct_in_state_def)
   apply (clarsimp simp: current_time_bounded_def)
   apply (erule st_tcb_ex_cap, clarsimp, fastforce)
  apply (wpsimp wp: perform_unsafe_invocation_ct_ready_if_schedulable)
  done

lemma check_budget_restart_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and cur_sc_chargeable and active_sc_valid_refills
    and cur_sc_active and current_time_bounded
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. unat (consumed_time s) + unat MAX_PERIOD \<le> unat max_time)\<rbrace>
   check_budget_restart
   \<lbrace>\<lambda>rv s:: det_state. ct_ready_if_schedulable s\<rbrace>"
  unfolding check_budget_restart_def
  apply (rule_tac hoare_seq_ext[where B=R and C=R for R])
   apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong gts_wp)
   apply (clarsimp simp: ct_ready_if_schedulable_def tcb_at_kh_simps vs_all_heap_simps)
  apply (wpsimp wp: check_budget_ct_ready_if_schedulable)
  done

lemma handle_invocation_ct_ready_if_schedulable[wp]:
  "\<lbrace>invs
    and valid_sched and valid_machine_time
    and ct_active and ct_released
    and schact_is_rct
    and cur_sc_active and ct_not_in_release_q
    and current_time_bounded
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s)
    and ct_released
    and (\<lambda>s. cur_sc s \<noteq> idle_sc_ptr)\<rbrace>
   handle_invocation calling blocking can_donate first_phase cptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding handle_invocation_def
  apply (wpsimp wp: syscall_valid handle_fault_ct_ready_if_schedulable_not_blocked_on_receive)
                apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong)
               apply (rule_tac Q="\<lambda>_. ct_ready_if_schedulable and ct_in_state runnable"
                      in hoare_post_imp)
                apply (clarsimp simp: ct_ready_if_schedulable_def ct_in_state_def tcb_at_kh_simps)
               apply wpsimp+
         apply (wpsimp wp: gts_wp)
        apply (rule_tac Q="\<lambda>_. ct_ready_if_schedulable and (\<lambda>s. thread = cur_thread s)" and
                        E="\<lambda>_. ct_ready_if_schedulable and (\<lambda>s. thread = cur_thread s)"
               in hoare_post_impErr[rotated]; clarsimp)
         apply (clarsimp simp: ct_in_state_def tcb_at_kh_simps vs_all_heap_simps)
        apply (rule valid_validE)
        apply (wpsimp wp: perform_invocation_ct_ready_if_schedulable)
       apply ((wpsimp wp: set_thread_state_runnable_valid_sched set_thread_state_ct_in_state
                          set_thread_state_schact_is_rct_strong | wps)+)[1]
      apply (clarsimp cong: conj_cong)
      apply (rule_tac Q="\<lambda>rv s.
               ct_active s \<and>
               cur_sc_active s \<and>
               invs s \<and>
               valid_sched s \<and> valid_machine_time s \<and> ct_released s \<and>
               valid_invocation rv s \<and>
               schact_is_rct s \<and>
               (active_sc_tcb_at (cur_thread s) s \<and> ct_not_in_release_q s) \<and>
               current_time_bounded s \<and>
               cur_sc_offset_ready (consumed_time s) s \<and> cur_sc_offset_sufficient (consumed_time s) s \<and>
               bound_sc_tcb_at bound (cur_thread s) s \<and> thread = cur_thread s \<and> cur_sc s \<noteq> idle_sc_ptr"
             and E="\<lambda>_. ct_ready_if_schedulable"
             in hoare_post_impErr[rotated])
        apply (clarsimp simp: ct_in_state_def runnable_eq_active)
       apply clarsimp
      apply wpsimp
     apply (wpsimp wp: hoare_vcg_if_lift2)
       apply (wpsimp wp: hoare_drop_imps)
      apply (wpsimp wp: hoare_drop_imps)
     apply (wpsimp wp: hoare_vcg_if_lift2 simp: cap_cap_slot_fold)
    apply wpsimp+
  apply (auto simp: vs_all_heap_simps tcb_at_kh_simps ct_ready_if_schedulable_def
             elim!: ct_in_state_weaken)
  done

lemma update_time_stamp_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and valid_machine_time\<rbrace>
   update_time_stamp
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  apply (rule hoare_weaken_pre)
   apply (rule_tac Q="\<lambda>_ s. \<forall>t. t = cur_thread s
                            \<longrightarrow> ct_ready_if_schedulable_2 (cur_time s) t (tcb_sts_of s)
                                    (tcb_scps_of s) (sc_refill_cfgs_of s) (release_queue s)"
          in hoare_post_imp, clarsimp)
   apply wpsimp
   apply (clarsimp simp: ct_ready_if_schedulable_def)
   apply (wpsimp wp: hoare_vcg_imp_lift')
  apply (clarsimp simp: ct_ready_if_schedulable_def)
  done

crunches do_nbrecv_failed_transfer
  for ct_ready_if_schedulable[wp]: ct_ready_if_schedulable

lemma maybe_donate_sc_ct_ready_if_schedulable_gen[wp]:
  "\<lbrace>ct_ready_if_schedulable and active_sc_valid_refills\<rbrace>
   maybe_donate_sc tptr ntfnptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable\<rbrace>"
  apply (rule_tac P="\<lambda>s. tptr = cur_thread s" in hoare_pre_tautI)
   apply (simp add: maybe_donate_sc_def)
   apply (rule_tac Q="\<lambda>_ s. tptr = cur_thread s \<and> (schedulable tptr s \<longrightarrow> budget_ready tptr s)"
          in hoare_strengthen_post)
    apply (wpsimp wp: sched_context_resume_schedulable_imp_ready
                      get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)
    apply (fastforce simp: ct_ready_if_schedulable_def schedulable_def2 tcb_at_kh_simps)+
  apply (wpsimp wp: maybe_donate_sc_ct_ready_if_schedulable)
  done

lemma complete_signal_ct_ready_if_schedulable[wp]:
  "\<lbrace>ct_ready_if_schedulable and active_sc_valid_refills\<rbrace>
   complete_signal ntfnptr tptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding complete_signal_def
  by (wpsimp wp: get_tcb_obj_ref_wp hoare_vcg_all_lift hoare_drop_imps)

lemma reply_push_ct_ready_if_schedulable_callee:
  "\<lbrace>ct_ready_if_schedulable
    and (\<lambda>s. can_donate \<longrightarrow> callee = cur_thread s \<and> released_if_bound_sc_tcb_at caller s)
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   reply_push caller callee reply_ptr can_donate
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding reply_push_def bind_sc_reply_def
  apply (simp add: bind_assoc)
  apply wpsimp
                 apply (wpsimp wp: sched_context_donate_ct_ready_if_schedulable_strong)
                apply (rule_tac Q="\<lambda>_ s. callee = cur_thread s \<and> is_refill_ready (the sc_caller) s
                                         \<and> bound_sc_tcb_at (\<lambda>x. x = None) (cur_thread s) s
                                         \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
                       in hoare_strengthen_post[rotated], simp)
                 apply clarsimp
                 apply (subgoal_tac "\<not>sc_tcb_sc_at (\<lambda>x. x = Some (cur_thread s)) y s")
                  apply (clarsimp simp: sc_at_kh_simps vs_all_heap_simps)
                 apply (prop_tac "\<not>bound_sc_tcb_at (\<lambda>x. x = Some y) (cur_thread s) s")
                  apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)
                 apply (fastforce simp: heap_refs_inv_def heap_refs_retract_def heap_refs_retract_at_def
                                        tcb_at_kh_simps sc_at_kh_simps pred_map_eq_normalise)
                apply (simp add: tcb_at_kh_simps)
                apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift')
               apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift')
              apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' get_simple_ko_wp)
             apply (wpsimp wp: hoare_vcg_if_lift2 hoare_vcg_imp_lift' get_simple_ko_wp)
            apply (rule_tac
                     Q="\<lambda>_ s. if sc_caller \<noteq> None \<and> sc_callee = None \<and> can_donate
                              then callee = cur_thread s \<and> is_refill_ready (the sc_caller) s
                                   \<and> pred_map (\<lambda>x. x = sc_callee) (tcb_scps_of s) (cur_thread s)
                                   \<and> pred_map (\<lambda>x. x = sc_caller) (tcb_scps_of s) caller
                                   \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
                              else ct_ready_if_schedulable s"
                   in hoare_post_imp)
             apply (fastforce split: if_split simp: obj_at_def)
            apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong assert_inv hoare_vcg_if_lift2
                              hoare_vcg_all_lift hoare_vcg_imp_lift)
         apply (rule_tac
                  Q="\<lambda>_ s. ct_ready_if_schedulable s
                           \<and> (can_donate \<longrightarrow>
                                callee = cur_thread s
                                \<and> (sc_caller = None \<or> is_refill_ready (the sc_caller) s)
                                \<and> pred_map (\<lambda>x. x = sc_callee) (tcb_scps_of s) callee
                                \<and> pred_map (\<lambda>x. x = sc_caller) (tcb_scps_of s) caller)
                           \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
                in hoare_post_imp, simp)
          apply (wpsimp wp: get_tcb_obj_ref_wp hoare_drop_imp)+
  apply (clarsimp simp: obj_at_def vs_all_heap_simps)
  done

lemma maybe_return_sc_tcb_sts_of[wp]:
  "maybe_return_sc ntfn_ptr thread \<lbrace>\<lambda>s. Q (tcb_sts_of s)\<rbrace>"
  unfolding maybe_return_sc_def
  by (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)

lemma maybe_return_sc_ct_ready_if_schedulable[wp]:
  "maybe_return_sc ntfnptr thread \<lbrace>ct_ready_if_schedulable\<rbrace>"
  unfolding maybe_return_sc_def
  by (wpsimp wp: get_tcb_obj_ref_wp get_sk_obj_ref_wp)

lemma maybe_return_sc_released_ipc_queues[wp]:
  "maybe_return_sc ntfn_ptr thread \<lbrace>\<lambda>s. released_ipc_queues s \<rbrace>"
  unfolding maybe_return_sc_def
  apply (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
  by (auto split: if_splits simp: pred_map_def vs_all_heap_simps obj_at_def released_ipc_queues_defs)

lemma maybe_return_sc_active_sc_valid_refills[wp]:
  "maybe_return_sc ntfn_ptr thread \<lbrace>active_sc_valid_refills\<rbrace>"
  unfolding maybe_return_sc_def
  apply (wpsimp wp: valid_sched_wp get_tcb_obj_ref_wp get_sk_obj_ref_wp)
  done

lemma receive_ipc_ct_ready_if_schedulable:
  "\<lbrace>\<lambda>s. ct_ready_if_schedulable s \<and> thread = cur_thread s \<and> valid_sched s
        \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   receive_ipc thread cap is_blocking reply_cap
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding receive_ipc_def if_cond_refill_unblock_check_def
  apply (cases cap; simp)
  apply (rule hoare_seq_ext_skip)
   apply (cases reply_cap; simp add: bind_assoc)
   apply (rule hoare_seq_ext[OF _ grt_sp])
   apply wpsimp
  apply (rule hoare_seq_ext[OF _ get_simple_ko_sp])
  apply (rename_tac ep)
  apply (rule hoare_seq_ext[OF _ gbn_sp])
  apply (rule hoare_seq_ext[OF _ get_notification_default_sp])
  apply (rule hoare_if)
   apply (wpsimp wp: complete_signal_ct_ready_if_schedulable)
  apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong reply_push_ct_ready_if_schedulable_callee
                    get_tcb_obj_ref_wp thread_get_wp' complete_signal_ct_ready_if_schedulable)
                apply (rule_tac Q="\<lambda>_ s. thread = cur_thread s \<and> ct_ready_if_schedulable s
                                         \<and> released_ipc_queues s \<and> blocked_on_send_tcb_at sender s
                                         \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
                       in hoare_post_imp)
                 apply (clarsimp split: if_split option.splits)
                 apply (case_tac "timeout_faulted_tcb_at sender s")
                  apply (fastforce simp: obj_at_def vs_all_heap_simps is_timeout_fault_opt_def split: option.splits)
                 apply (frule (1) released_ipc_queues_blocked_on_send_E1, clarsimp)
                 apply (clarsimp simp: vs_all_heap_simps obj_at_def is_timeout_fault_opt_def)
                apply (wpsimp+)[4]
            apply (wpsimp wp: get_tcb_obj_ref_wp)
           (* do_ipc_transfer *)
           apply (rule_tac Q="\<lambda>_ s. thread = cur_thread s \<and> ct_ready_if_schedulable s
                                    \<and> released_ipc_queues s \<and> blocked_on_send_tcb_at sender s
                                    \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)
                                    \<and> active_sc_valid_refills s"
                  in hoare_post_imp)
            apply (clarsimp split: if_split option.splits)
            apply (case_tac "timeout_faulted_tcb_at sender s")
             apply (fastforce simp: obj_at_def vs_all_heap_simps is_timeout_fault_opt_def)
            apply (frule (1) released_ipc_queues_blocked_on_send_E1, clarsimp)
            apply (fastforce simp: vs_all_heap_simps obj_at_def is_timeout_fault_opt_def)
           apply wpsimp
          apply wpsimp
         apply (wpsimp wp: gts_wp)
        (* set_endpoint *)
        apply (rule_tac Q="\<lambda>_ s. thread = cur_thread s \<and> ct_ready_if_schedulable s
                                 \<and> released_ipc_queues s \<and> active_sc_valid_refills s
                                 \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
               in hoare_post_imp)
         apply (clarsimp simp: tcb_at_kh_simps vs_all_heap_simps)[1]
        apply wpsimp+
     apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong)
    apply wpsimp
   apply (rule_tac Q="\<lambda>_ s. thread = cur_thread s \<and> ct_ready_if_schedulable s
                                    \<and> released_ipc_queues s \<and> active_sc_valid_refills s
                                    \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
          in hoare_post_imp)
    apply fastforce
   apply wpsimp
  apply (clarsimp simp: valid_sched_def)
  done

lemma sched_context_donate_heap_refs_inv[wp]:
  "\<lbrace>\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s) \<and> bound_sc_tcb_at ((=) None) tptr s\<rbrace>
   sched_context_donate scp tptr
   \<lbrace>\<lambda>_ s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>"
  unfolding sched_context_donate_def
  apply (simp add: sched_context_donate_def)
  apply (rule hoare_seq_ext[OF _ gsct_sp])
  apply (simp add: when_def)
  apply (intro conjI impI)
   defer
   apply (wpsimp wp: valid_sched_wp)
   apply (fastforce simp: heap_refs_inv_def sc_at_kh_simps tcb_at_kh_simps heap_refs_retract_def
                          heap_refs_retract_at_def vs_all_heap_simps heap_upd_def)[1]
  apply (clarsimp simp: bind_assoc )
  apply (subst bind_assoc[symmetric])
  apply (rule_tac hoare_seq_ext[where A=R and B="\<lambda>_. R" for R, rotated])
   apply (wpsimp simp: sc_at_kh_simps tcb_at_kh_simps)
  apply (rule hoare_weaken_pre)
   apply (wpsimp wp: set_tcb_sched_context_valid_sched_except_tcb_scp_heap)
      apply (rule valid_sched_wp)
     apply (rule valid_sched_wp)
    apply (rule valid_sched_wp)
   apply (rule_tac Q="\<lambda>_ s. heap_refs_inv (heap_upd (\<lambda>a. Some tptr) scp (sc_tcbs_of s))
              (tcb_scps_of s(tptr \<mapsto> Some scp))" in hoare_post_imp)
    apply (clarsimp simp: fun_upd_def)
   apply (rule valid_sched_wp)
  apply (clarsimp simp: sc_at_kh_simps tcb_at_kh_simps pred_map_eq_normalise)
  apply (clarsimp simp: heap_refs_inv_def2 heap_upd_def pred_map_eq_upd pred_map_eq_updupd pred_map_eq)
  apply (drule_tac x=scp in spec)
  apply (frule_tac x=q in spec)
  apply (drule_tac x=y in spec)
  apply clarsimp
  done

lemma sched_context_donate_not_sc_tcb_sc_at:
  "\<lbrace>\<lambda>_. tptr' \<noteq> tptr\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_ s. \<not> pred_map (\<lambda>x. x = Some tptr') (sc_tcbs_of s) scptr\<rbrace>"
  unfolding sched_context_donate_def
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext[where B="\<lambda>_ _. tptr' \<noteq> tptr"])
   apply (wpsimp wp: valid_sched_wp)
   apply (clarsimp simp: vs_all_heap_simps heap_upd_def)
  apply wpsimp
  done

lemma sched_context_donate_sc_tcb_sc_at':
  "\<lbrace>\<lambda>s. tptr' = tptr \<and> sc_tcb_sc_at \<top> scptr s\<rbrace>
   sched_context_donate scptr tptr
   \<lbrace>\<lambda>_ s. pred_map (\<lambda>x. x = Some tptr') (sc_tcbs_of s) scptr\<rbrace>"
  unfolding sched_context_donate_def
  apply (subst bind_assoc[symmetric])
  apply (rule hoare_seq_ext[where B="\<lambda>_ s. tptr' = tptr \<and> sc_tcb_sc_at \<top> scptr s"])
   apply (wpsimp wp: valid_sched_wp)
   apply (clarsimp simp: vs_all_heap_simps heap_upd_def sc_at_kh_simps)
  apply (wpsimp simp: sc_at_kh_simps)
  done

lemma maybe_donate_sc_ct_ready_if_schedulable_two:
  "\<lbrace>ct_ready_if_schedulable and (\<lambda>s. tptr = cur_thread s)
    and (\<lambda>s. heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s))\<rbrace>
   maybe_donate_sc tptr ntfnptr
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding maybe_donate_sc_def
  apply (wpsimp wp: hoare_vcg_if_lift2 sched_context_resume_ct_ready_if_schedulable_two
                    hoare_vcg_imp_lift'
              simp: sc_at_kh_simps
         | wps)+
        apply (rule sched_context_donate_not_sc_tcb_sc_at)
       apply wpsimp
      apply (wpsimp wp: hoare_vcg_if_lift2 sched_context_resume_ct_ready_if_schedulable_two
                        hoare_vcg_imp_lift'
                  simp: sc_at_kh_simps
             | wps)+
       apply (rule sched_context_donate_sc_tcb_sc_at')
      apply (wpsimp wp: sched_context_donate_ct_ready_if_schedulable_strong hoare_drop_imp)
     apply (wpsimp wp: get_sc_obj_ref_wp get_sk_obj_ref_wp get_tcb_obj_ref_wp)+
  apply (clarsimp simp: sc_at_kh_simps vs_all_heap_simps obj_at_def tcb_at_kh_simps)
  done

lemma receive_signal_ct_ready_if_schedulable:
  "\<lbrace>\<lambda>s. ct_ready_if_schedulable s \<and> thread = cur_thread s \<and> valid_machine_time s
        \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   receive_signal thread cap is_blocking
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding receive_signal_def if_cond_refill_unblock_check_def
  apply (wpsimp wp: set_thread_state_ct_ready_if_schedulable_strong get_simple_ko_wp
                    maybe_donate_sc_ct_ready_if_schedulable_two hoare_drop_imp
                    thread_get_wp' get_tcb_obj_ref_wp hoare_vcg_all_lift)
  done

lemma handle_recv_ct_ready_if_schedulable[wp]:
  "\<lbrace>\<lambda>s. released_if_bound_sc_tcb_at (cur_thread s) s \<and> valid_sched s
        \<and> valid_machine_time s \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)\<rbrace>
   handle_recv is_blocking can_reply
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  supply if_split [split del]
  unfolding handle_recv_def Let_def
  apply (wpsimp wp: handle_fault_ct_ready_if_schedulable_released_if_bound
                    receive_ipc_ct_ready_if_schedulable
                    receive_signal_ct_ready_if_schedulable
                    get_sk_obj_ref_wp)
     apply (rule_tac Q'="\<lambda>_ s. thread = cur_thread s \<and> released_if_bound_sc_tcb_at thread s
                               \<and> valid_sched s \<and> valid_machine_time s
                               \<and> heap_refs_inv (sc_tcbs_of s) (tcb_scps_of s)"
            in hoare_post_imp_R[rotated], clarsimp)
      apply (strengthen ct_ready_if_schedulable_streng)
      apply fastforce
     by wpsimp+

lemma handle_yield_ct_ready_if_schedulable[wp]:
  "\<lbrace>active_sc_valid_refills
    and invs
    and cur_sc_chargeable
    and current_time_bounded
    and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
    and cur_sc_active\<rbrace>
   handle_yield
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  unfolding handle_yield_def
  apply (wpsimp wp: charge_budget_ready_if_schedulable get_refills_wp)
  apply (intro conjI)
   apply (rule_tac y=" unat MAX_PERIOD + unat MAX_PERIOD" in order_trans[rotated])
    apply (clarsimp simp: current_time_bounded_def)
   apply (rule add_mono[rotated], simp)
   apply (clarsimp simp: valid_sched_def active_sc_valid_refills_def)
   apply (drule_tac x="cur_sc s" in spec, clarsimp)
   apply (clarsimp simp: word_le_nat_alt[symmetric])
   apply (rule valid_refills_r_amount_bounded_max_sc_period)
   apply (clarsimp simp: valid_refills_def2 obj_at_def)
  apply (clarsimp simp: cur_sc_offset_ready_def obj_at_def refill_ready_def)
   apply (clarsimp simp: current_time_bounded_def)
  apply (clarsimp simp: vs_all_heap_simps)
  done

lemmas move_Q_to_front_conj
  = conj_left_commute[where Q=Q] conj_commute[where Q=Q] for Q

lemma factor_imp_on_left:
  "((X \<longrightarrow> P) \<and> (X \<longrightarrow> Q) \<and> R) = ((X \<longrightarrow> (P \<and> Q)) \<and> R)"
  by (simp add: imp_conjR)

(*FIXME RT: generalise and move to lib*)
method wpsimp_str uses wp simp str
  = ((wpsimp wp: wp simp: simp
      | strengthen valid_sched_active_sc_valid_refills sym_refs_inv_sc_tcbs invs_sym_refs
                   consumed_time_bounded_helper)+)[1]

method he_ctris_handle_recv
  = wpsimp_str wp: check_budget_restart_false check_budget_restart_true
                   update_time_stamp_current_time_bounded,
    fastforce intro!: schact_is_rct_ct_released
                elim: invs_cur_sc_chargeableE

method he_ctris_handle_fault
  = wpsimp_str wp: check_budget_restart_if_lift
                     handle_fault_ct_ready_if_schedulable_not_blocked_on_receive
                     update_time_stamp_current_time_bounded,
    fastforce intro!: schact_is_rct_ct_released
                elim: invs_cur_sc_chargeableE ct_in_state_weaken

method he_ctris_two_phase_wp
 = wpsimp_str wp: check_budget_restart_false handle_invocation_valid_sched,
   wpsimp simp: factor_imp_on_left
                conj_commute[where Q="schact_is_rct s" for s]
                move_Q_to_front_conj[where Q="cur_sc_offset_sufficient a b" for a b],
   wpsimp wp: check_budget_restart_false check_budget_restart_true,
   wpsimp_str simp: schedulable_def2
               wp: check_budget_restart_false handle_invocation_valid_sched
                   update_time_stamp_current_time_bounded

method he_ctris_two_phase_ff
 = clarsimp?,
   (frule invs_strengthen_cur_sc_tcb_are_bound; fastforce?),
   fastforce dest: cur_sc_not_idle_sc_ptr' valid_sched_ct_not_queued
           intro!: schact_is_rct_ct_released invs_strengthen_cur_sc_tcb_are_bound
                   schact_is_rct_ct_active_sc invs_cur_sc_chargeableE
             simp: runnable_eq_active ct_in_state_def in_release_queue_def not_in_release_q_def
                   schedulable_def2 pred_tcb_at_def obj_at_def current_time_bounded_def

lemma handle_event_ct_ready_if_schedulable[wp]:
  "\<lbrace>invs
    and valid_sched
    and valid_machine_time
    and schact_is_rct
    and cur_sc_active
    and (\<lambda>s. ct_running s \<or> ct_idle s) and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)
    and ct_not_in_release_q
    and consumed_time_bounded
    and (\<lambda>s. ct_running s \<longrightarrow> ct_released s)
    and (\<lambda>s. cur_sc_offset_ready (consumed_time s) s) \<rbrace>
   handle_event e
   \<lbrace>\<lambda>_. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  apply (cases e; simp)
  subgoal for syscall
    apply (case_tac syscall; simp add: handle_call_def handle_send_def)
              apply (wpsimp simp: conj_commute[where Q="schact_is_rct s" for s]
                                  move_Q_to_front_conj[where Q="cur_sc_offset_sufficient a b" for a b])
                apply (wpsimp wp: check_budget_restart_false check_budget_restart_true
                                  update_time_stamp_current_time_bounded)
               apply (wpsimp_str wp: update_time_stamp_current_time_bounded)
              apply he_ctris_two_phase_ff
             apply (he_ctris_two_phase_wp, he_ctris_two_phase_ff)
            apply (he_ctris_two_phase_wp, he_ctris_two_phase_ff)
           apply (he_ctris_two_phase_wp, he_ctris_two_phase_ff)
          apply (he_ctris_two_phase_wp, he_ctris_two_phase_ff)
         apply (he_ctris_two_phase_wp, he_ctris_two_phase_ff)
        apply he_ctris_handle_recv
       apply he_ctris_handle_recv
      apply he_ctris_handle_recv
     apply he_ctris_handle_recv
    apply he_ctris_handle_recv
    done

      apply he_ctris_handle_fault
     apply he_ctris_handle_fault
  subgoal \<comment>\<open>Interrupt\<close>
    apply wpsimp
       apply (wp hoare_drop_imp)
      apply (wpsimp_str wp: update_time_stamp_current_time_bounded)
     apply wpsimp
     apply (clarsimp simp: ct_in_state_def)
    apply (fastforce intro!: schact_is_rct_ct_released
                       elim: invs_cur_sc_chargeableE
                       simp: ct_ready_if_schedulable_def vs_all_heap_simps ct_in_state_def
                             pred_tcb_at_def obj_at_def is_blocked_on_receive_def)
    done
  apply he_ctris_handle_fault
  apply (wpsimp wp: handle_fault_ct_ready_if_schedulable_not_blocked_on_receive)
  done

lemma ct_active_sc_cur_sc_active:
  "cur_sc_chargeable s \<Longrightarrow> active_sc_tcb_at (cur_thread s) s \<Longrightarrow> cur_sc_active (s::det_state)"
  apply (frule (1) cur_sc_chargeable_when_ct_active_sc)
  apply (rule ct_active_sc_cur_sc_active, simp)
  apply (clarsimp simp: tcb_at_kh_simps pred_map_eq_normalise)
  done

lemma preemption_path_cur_sc_in_release_q_imp_zero_consumed:
  "\<lbrace>(invs and valid_sched and consumed_time_bounded and ct_not_in_release_q
     and valid_machine_time and cur_sc_chargeable
     and (\<lambda>s. cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s))
    and current_time_bounded\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. cur_sc_in_release_q_imp_zero_consumed :: det_state \<Rightarrow> _\<rbrace>"
  (is "valid (?cond and _) _ _")
  apply (rule_tac R1="cur_sc_in_release_q_imp_zero_consumed" in hoare_pre_add[THEN iffD2])
   apply (fastforce intro: cur_sc_chargeable_cur_sc_in_release_q_imp_zero_consumed)
  apply (clarsimp simp: preemption_path_def)
  apply (rule hoare_seq_ext_skip, solves wpsimp)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (rule_tac B="\<lambda>_. cur_sc_in_release_q_imp_zero_consumed and invs and active_sc_valid_refills and valid_release_q
                         and cur_sc_more_than_ready
                         and current_time_bounded and cur_sc_in_release_q_imp_zero_consumed"
               in hoare_seq_ext)
   apply (wpsimp wp: handle_interrupt_cur_sc_in_release_q_imp_zero_consumed)
  apply (clarsimp simp: pred_conj_def split del: if_split)
  apply (rule hoare_if)
   apply (wpsimp wp: check_budget_active_sc_valid_refills check_budget_valid_release_q)
   apply (fastforce simp: schedulable_def2 cur_sc_chargeable_def vs_all_heap_simps
                          current_time_bounded_def)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
   apply (wpsimp wp: charge_budget_active_sc_valid_refills)
   apply (fastforce simp: obj_at_def vs_all_heap_simps refill_ready_no_overflow_def
                    dest: consumed_time_bounded_helper
                          valid_sched_active_sc_valid_refills)
  apply (wpsimp wp: charge_budget_valid_release_q)
  apply (fastforce intro: active_sc_valid_refillsE
                    simp: obj_at_def vs_all_heap_simps active_sc_def)
  done

lemma preemption_path_cur_sc_more_than_ready:
  "\<lbrace>\<lambda>s. invs s \<and> valid_machine_time s \<and> ct_not_queued s
        \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. cur_sc_more_than_ready :: det_state \<Rightarrow> _\<rbrace>"
  (is "valid (?cond) _ _")
  apply (clarsimp simp: preemption_path_def)
  apply (rule hoare_seq_ext_skip, wpsimp)
  apply (wpsimp wp: is_schedulable_wp | intro conjI impI)+
  done

lemma preemption_path_ct_ready_if_schedulable:
  "\<lbrace>(\<lambda>s. valid_sched s \<and> invs s \<and> consumed_time_bounded s \<and> ct_not_blocked s
         \<and> valid_machine_time s \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
         \<and> cur_sc_chargeable s \<and> ct_ready_if_schedulable s)
    and current_time_bounded\<rbrace>
    preemption_path
    \<lbrace>\<lambda>rv. ct_ready_if_schedulable :: det_state \<Rightarrow> _\<rbrace>"
  (is "valid (?cond and _ ) _ _")
  apply (clarsimp simp: preemption_path_def)
  apply (rule hoare_seq_ext_skip, wpsimp simp: ct_in_state_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (rule_tac B="\<lambda>_. ct_not_blocked_on_receive and ct_not_blocked_on_ntfn
                         and invs and ct_ready_if_schedulable"
               in hoare_seq_ext)
   apply wpsimp
  apply (simp add: pred_conj_def split del: if_split)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
    apply wpsimp
    apply (fastforce intro: ct_in_state_weaken simp: is_blocked_on_receive_def)
   apply wpsimp
   apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def is_blocked_on_receive_def)
   apply (rename_tac tcb, case_tac "tcb_state tcb"; clarsimp)
  apply (rule hoare_if)
   apply (wpsimp wp: check_budget_ct_ready_if_schedulable)
   apply (fastforce simp: vs_all_heap_simps schedulable_def2 cur_sc_chargeable_def
                    dest: consumed_time_bounded_helper)
  apply (wpsimp wp: charge_budget_ready_if_schedulable)
  apply (fastforce simp: obj_at_def vs_all_heap_simps refill_ready_no_overflow_def
                   dest: consumed_time_bounded_helper
                         valid_sched_active_sc_valid_refills)
  done

lemma preemption_path_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> invs s \<and> consumed_time_bounded s
        \<and> ct_not_in_release_q s \<and> scheduler_act_sane s \<and> ct_not_blocked s \<and> valid_machine_time s
        \<and> ct_not_queued s \<and> (cur_sc_active s \<longrightarrow> cur_sc_offset_ready (consumed_time s) s)
        \<and> cur_sc_chargeable s \<and> current_time_bounded s\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: preemption_path_def)
  apply (rule hoare_seq_ext_skip, wpsimp simp: ct_in_state_def)
  apply (rule hoare_seq_ext[OF _ gets_sp])
  apply (rule hoare_seq_ext[OF _ is_schedulable_sp'])
  apply (rule_tac B="\<lambda>_. invs and valid_sched and scheduler_act_sane and current_time_bounded"
               in hoare_seq_ext)
   apply (wpsimp wp: handle_interrupt_valid_sched)
  apply (simp add: pred_conj_def split del: if_split)
  apply (intro hoare_vcg_conj_lift_pre_fix; (solves wpsimp)?)
  apply (rule hoare_if)
   apply (wpsimp wp: check_budget_valid_sched)
   apply (clarsimp simp: schedulable_def2)
   apply (intro conjI impI)
      apply (erule (1) ct_not_blocked_cur_sc_not_blocked)
     apply (fastforce simp: cur_sc_chargeable_def vs_all_heap_simps)
    apply (clarsimp simp: vs_all_heap_simps)
   apply (fastforce simp: cur_sc_chargeable_def vs_all_heap_simps)
  apply (wpsimp wp: charge_budget_valid_sched)
  apply (fastforce intro: ct_not_blocked_cur_sc_not_blocked
                          consumed_time_bounded_helper
                    simp: obj_at_def vs_all_heap_simps refill_ready_no_overflow_def)
  done

lemma preemption_path_invs[wp]:
  "preemption_path \<lbrace>invs\<rbrace>"
  apply (wpsimp simp: preemption_path_def
                  wp: is_schedulable_wp hoare_drop_imps hoare_vcg_if_lift2)
  done

lemma preemption_path_current_time_bounded:
  "\<lbrace>current_time_bounded and valid_machine_time\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. current_time_bounded :: det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: preemption_path_def
                  wp: is_schedulable_wp hoare_drop_imps hoare_vcg_if_lift2
                      update_time_stamp_current_time_bounded)
  done

lemma preemption_path_consumed_time_bounded:
  "\<lbrace>consumed_time_bounded and valid_machine_time\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. consumed_time_bounded :: det_state \<Rightarrow> _\<rbrace>"
  apply (wpsimp simp: preemption_path_def
                  wp: is_schedulable_wp hoare_drop_imps hoare_vcg_if_lift2)
  done

lemma preemption_point_scheduler_act_sane:
  "\<lbrace>scheduler_act_sane and invs and ct_not_blocked\<rbrace>
   preemption_path
   \<lbrace>\<lambda>_. scheduler_act_sane :: det_state \<Rightarrow> _\<rbrace>"
  apply (clarsimp simp: preemption_path_def)
  apply (wpsimp wp: is_schedulable_wp hoare_vcg_if_lift2 hoare_drop_imps)
   apply (fastforce simp: ct_in_state_def is_blocked_on_receive_def)
  apply (clarsimp simp: ct_in_state_def pred_tcb_at_def obj_at_def is_blocked_on_receive_def)
  apply (rename_tac tcb, case_tac "tcb_state tcb"; clarsimp)
  done

crunches handle_event
  for current_time_bounded[wp]: "current_time_bounded :: det_state \<Rightarrow> _"
  (wp: crunch_wps)

lemma handle_event_preemption_path_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> invs s \<and> schact_is_rct s \<and> cur_sc_active s \<and> ct_not_in_release_q s
        \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
        \<and> cur_sc_offset_ready (consumed_time s) s
        \<and> current_time_bounded s \<and> valid_machine_time s \<and> consumed_time_bounded s\<rbrace>
   handle_event e <handle> (\<lambda>_. liftE preemption_path)
   \<lbrace>\<lambda>_ s :: det_state. valid_sched s\<rbrace>"
  apply (rule validE_valid)
  apply (rule handleE_wp)
   apply (subst liftE_validE)
   apply (wpsimp wp: preemption_path_valid_sched)
  apply (rule hoare_weaken_preE)
   apply (rule hoare_vcg_E_elim)
    apply (wpsimp wp: handle_event_valid_sched handle_event_cur_sc_chargeable
                      handle_event_scheduler_act_sane)
   apply (wpsimp wp: handle_event_valid_sched handle_event_scheduler_act_sane)
  apply (fold schact_is_rct_def)
  apply (clarsimp cong: conj_cong)
  apply (intro conjI impI)
       apply (fastforce simp: ct_in_state_def runnable_eq_active pred_tcb_at_def obj_at_def)
      apply (fastforce intro: schact_is_rct_ct_active_sc
                        simp: schedulable_def2 ct_in_state_def runnable_eq_active pred_tcb_at_def
                              obj_at_def)
     apply (fastforce simp: valid_sched_ct_not_queued)
    apply fastforce
   apply (fastforce simp: ct_in_state_def runnable_eq_active pred_tcb_at_def obj_at_def)
  apply (fastforce intro: invs_strengthen_cur_sc_tcb_are_bound)
  done

lemma call_kernel_valid_sched:
  "\<lbrace>\<lambda>s. valid_sched s \<and> invs s \<and> schact_is_rct s
        \<and> cur_sc_active s \<and> ct_not_in_release_q s
        \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
        \<and> valid_machine_time s \<and> current_time_bounded s \<and> consumed_time_bounded s
        \<and> cur_sc_offset_ready (consumed_time s) s
        \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
   call_kernel e
   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
  apply (simp add: call_kernel_def)
  apply (simp flip: bind_assoc)
  apply (rule hoare_seq_ext, wpsimp)
  apply (rule hoare_seq_ext, wpsimp wp: schedule_valid_sched)
  apply (clarsimp simp: pred_conj_def)
   apply (rule hoare_vcg_conj_lift_pre_fix)
    apply (wpsimp wp: handle_event_preemption_path_valid_sched)
  apply (rule validE_valid)
  apply (rule handleE_wp)
   apply (subst liftE_validE)
   apply (wpsimp wp: preemption_path_current_time_bounded preemption_path_consumed_time_bounded
                     preemption_point_scheduler_act_sane preemption_path_cur_sc_more_than_ready
                     preemption_path_cur_sc_in_release_q_imp_zero_consumed
                     preemption_path_ct_ready_if_schedulable)
  apply (clarsimp cong: conj_cong)
  apply (rule hoare_weaken_preE)
   apply (rule hoare_vcg_E_elim)
    apply (wpsimp wp: handle_event_valid_sched handle_event_cur_sc_chargeable
                      handle_event_scheduler_act_sane)
   apply (wpsimp wp: handle_event_scheduler_act_sane
                     handle_event_cur_sc_in_release_q_imp_zero_consumed)
  apply (clarsimp simp: schedulable_def2
                   cong: conj_cong)
  apply (strengthen invs_strengthen_cur_sc_tcb_are_bound)
  apply (frule schact_is_rct_ct_active_sc; simp add: schact_is_rct_def)
  apply (prop_tac "ct_not_queued s")
   apply (fastforce simp: valid_sched_def ct_not_in_q_def)
  apply (intro conjI impI; (fastforce simp: ct_in_state_def pred_tcb_at_def obj_at_def)?)
  apply (rule schact_is_rct_ct_released; (fastforce simp: schact_is_rct_def)?)
  apply (rule cur_sc_not_idle_sc_ptr;
         (fastforce simp: runnable_eq_active ct_in_state_def pred_tcb_at_def obj_at_def)?)
  apply (fastforce intro: invs_strengthen_cur_sc_tcb_are_bound simp: schact_is_rct_def)
  done

end

end
